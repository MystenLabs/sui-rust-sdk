impl serde::Serialize for Ability {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "ABILITY_UNKNOWN",
            Self::Copy => "COPY",
            Self::Drop => "DROP",
            Self::Store => "STORE",
            Self::Key => "KEY",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for Ability {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ABILITY_UNKNOWN",
            "COPY",
            "DROP",
            "STORE",
            "KEY",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Ability;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ABILITY_UNKNOWN" => Ok(Ability::Unknown),
                    "COPY" => Ok(Ability::Copy),
                    "DROP" => Ok(Ability::Drop),
                    "STORE" => Ok(Ability::Store),
                    "KEY" => Ok(Ability::Key),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ActiveJwk {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.jwk.is_some() {
            len += 1;
        }
        if self.epoch.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ActiveJwk", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("id", v)?;
        }
        if let Some(v) = self.jwk.as_ref() {
            struct_ser.serialize_field("jwk", v)?;
        }
        if let Some(v) = self.epoch.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("epoch", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ActiveJwk {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "jwk",
            "epoch",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Jwk,
            Epoch,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "jwk" => Ok(GeneratedField::Jwk),
                            "epoch" => Ok(GeneratedField::Epoch),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ActiveJwk;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ActiveJwk")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ActiveJwk, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut jwk__ = None;
                let mut epoch__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = map_.next_value()?;
                        }
                        GeneratedField::Jwk => {
                            if jwk__.is_some() {
                                return Err(serde::de::Error::duplicate_field("jwk"));
                            }
                            jwk__ = map_.next_value()?;
                        }
                        GeneratedField::Epoch => {
                            if epoch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("epoch"));
                            }
                            epoch__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ActiveJwk {
                    id: id__,
                    jwk: jwk__,
                    epoch: epoch__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ActiveJwk", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Argument {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind.is_some() {
            len += 1;
        }
        if self.input.is_some() {
            len += 1;
        }
        if self.result.is_some() {
            len += 1;
        }
        if self.subresult.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.Argument", len)?;
        if let Some(v) = self.kind.as_ref() {
            let v = argument::ArgumentKind::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if let Some(v) = self.input.as_ref() {
            struct_ser.serialize_field("input", v)?;
        }
        if let Some(v) = self.result.as_ref() {
            struct_ser.serialize_field("result", v)?;
        }
        if let Some(v) = self.subresult.as_ref() {
            struct_ser.serialize_field("subresult", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Argument {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kind",
            "input",
            "result",
            "subresult",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Kind,
            Input,
            Result,
            Subresult,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kind" => Ok(GeneratedField::Kind),
                            "input" => Ok(GeneratedField::Input),
                            "result" => Ok(GeneratedField::Result),
                            "subresult" => Ok(GeneratedField::Subresult),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Argument;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.Argument")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Argument, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                let mut input__ = None;
                let mut result__ = None;
                let mut subresult__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<argument::ArgumentKind>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Input => {
                            if input__.is_some() {
                                return Err(serde::de::Error::duplicate_field("input"));
                            }
                            input__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Result => {
                            if result__.is_some() {
                                return Err(serde::de::Error::duplicate_field("result"));
                            }
                            result__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Subresult => {
                            if subresult__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subresult"));
                            }
                            subresult__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Argument {
                    kind: kind__,
                    input: input__,
                    result: result__,
                    subresult: subresult__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.Argument", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for argument::ArgumentKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "ARGUMENT_KIND_UNKNOWN",
            Self::Gas => "GAS",
            Self::Input => "INPUT",
            Self::Result => "RESULT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for argument::ArgumentKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ARGUMENT_KIND_UNKNOWN",
            "GAS",
            "INPUT",
            "RESULT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = argument::ArgumentKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ARGUMENT_KIND_UNKNOWN" => Ok(argument::ArgumentKind::Unknown),
                    "GAS" => Ok(argument::ArgumentKind::Gas),
                    "INPUT" => Ok(argument::ArgumentKind::Input),
                    "RESULT" => Ok(argument::ArgumentKind::Result),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for AuthenticatorStateExpire {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.min_epoch.is_some() {
            len += 1;
        }
        if self.authenticator_object_initial_shared_version.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.AuthenticatorStateExpire", len)?;
        if let Some(v) = self.min_epoch.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("minEpoch", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.authenticator_object_initial_shared_version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("authenticatorObjectInitialSharedVersion", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AuthenticatorStateExpire {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "min_epoch",
            "minEpoch",
            "authenticator_object_initial_shared_version",
            "authenticatorObjectInitialSharedVersion",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MinEpoch,
            AuthenticatorObjectInitialSharedVersion,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "minEpoch" | "min_epoch" => Ok(GeneratedField::MinEpoch),
                            "authenticatorObjectInitialSharedVersion" | "authenticator_object_initial_shared_version" => Ok(GeneratedField::AuthenticatorObjectInitialSharedVersion),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AuthenticatorStateExpire;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.AuthenticatorStateExpire")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AuthenticatorStateExpire, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut min_epoch__ = None;
                let mut authenticator_object_initial_shared_version__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MinEpoch => {
                            if min_epoch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minEpoch"));
                            }
                            min_epoch__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::AuthenticatorObjectInitialSharedVersion => {
                            if authenticator_object_initial_shared_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("authenticatorObjectInitialSharedVersion"));
                            }
                            authenticator_object_initial_shared_version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(AuthenticatorStateExpire {
                    min_epoch: min_epoch__,
                    authenticator_object_initial_shared_version: authenticator_object_initial_shared_version__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.AuthenticatorStateExpire", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for AuthenticatorStateUpdate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.epoch.is_some() {
            len += 1;
        }
        if self.round.is_some() {
            len += 1;
        }
        if !self.new_active_jwks.is_empty() {
            len += 1;
        }
        if self.authenticator_object_initial_shared_version.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.AuthenticatorStateUpdate", len)?;
        if let Some(v) = self.epoch.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("epoch", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.round.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("round", ToString::to_string(&v).as_str())?;
        }
        if !self.new_active_jwks.is_empty() {
            struct_ser.serialize_field("newActiveJwks", &self.new_active_jwks)?;
        }
        if let Some(v) = self.authenticator_object_initial_shared_version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("authenticatorObjectInitialSharedVersion", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for AuthenticatorStateUpdate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "epoch",
            "round",
            "new_active_jwks",
            "newActiveJwks",
            "authenticator_object_initial_shared_version",
            "authenticatorObjectInitialSharedVersion",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Epoch,
            Round,
            NewActiveJwks,
            AuthenticatorObjectInitialSharedVersion,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "epoch" => Ok(GeneratedField::Epoch),
                            "round" => Ok(GeneratedField::Round),
                            "newActiveJwks" | "new_active_jwks" => Ok(GeneratedField::NewActiveJwks),
                            "authenticatorObjectInitialSharedVersion" | "authenticator_object_initial_shared_version" => Ok(GeneratedField::AuthenticatorObjectInitialSharedVersion),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = AuthenticatorStateUpdate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.AuthenticatorStateUpdate")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<AuthenticatorStateUpdate, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut epoch__ = None;
                let mut round__ = None;
                let mut new_active_jwks__ = None;
                let mut authenticator_object_initial_shared_version__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Epoch => {
                            if epoch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("epoch"));
                            }
                            epoch__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Round => {
                            if round__.is_some() {
                                return Err(serde::de::Error::duplicate_field("round"));
                            }
                            round__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NewActiveJwks => {
                            if new_active_jwks__.is_some() {
                                return Err(serde::de::Error::duplicate_field("newActiveJwks"));
                            }
                            new_active_jwks__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AuthenticatorObjectInitialSharedVersion => {
                            if authenticator_object_initial_shared_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("authenticatorObjectInitialSharedVersion"));
                            }
                            authenticator_object_initial_shared_version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(AuthenticatorStateUpdate {
                    epoch: epoch__,
                    round: round__,
                    new_active_jwks: new_active_jwks__.unwrap_or_default(),
                    authenticator_object_initial_shared_version: authenticator_object_initial_shared_version__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.AuthenticatorStateUpdate", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Balance {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.coin_type.is_some() {
            len += 1;
        }
        if self.balance.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.Balance", len)?;
        if let Some(v) = self.coin_type.as_ref() {
            struct_ser.serialize_field("coinType", v)?;
        }
        if let Some(v) = self.balance.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("balance", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Balance {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "coin_type",
            "coinType",
            "balance",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CoinType,
            Balance,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "coinType" | "coin_type" => Ok(GeneratedField::CoinType),
                            "balance" => Ok(GeneratedField::Balance),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Balance;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.Balance")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Balance, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut coin_type__ = None;
                let mut balance__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CoinType => {
                            if coin_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coinType"));
                            }
                            coin_type__ = map_.next_value()?;
                        }
                        GeneratedField::Balance => {
                            if balance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("balance"));
                            }
                            balance__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Balance {
                    coin_type: coin_type__,
                    balance: balance__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.Balance", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BalanceChange {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.address.is_some() {
            len += 1;
        }
        if self.coin_type.is_some() {
            len += 1;
        }
        if self.amount.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.BalanceChange", len)?;
        if let Some(v) = self.address.as_ref() {
            struct_ser.serialize_field("address", v)?;
        }
        if let Some(v) = self.coin_type.as_ref() {
            struct_ser.serialize_field("coinType", v)?;
        }
        if let Some(v) = self.amount.as_ref() {
            struct_ser.serialize_field("amount", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BalanceChange {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "address",
            "coin_type",
            "coinType",
            "amount",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Address,
            CoinType,
            Amount,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "address" => Ok(GeneratedField::Address),
                            "coinType" | "coin_type" => Ok(GeneratedField::CoinType),
                            "amount" => Ok(GeneratedField::Amount),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BalanceChange;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.BalanceChange")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BalanceChange, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut address__ = None;
                let mut coin_type__ = None;
                let mut amount__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Address => {
                            if address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("address"));
                            }
                            address__ = map_.next_value()?;
                        }
                        GeneratedField::CoinType => {
                            if coin_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coinType"));
                            }
                            coin_type__ = map_.next_value()?;
                        }
                        GeneratedField::Amount => {
                            if amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("amount"));
                            }
                            amount__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(BalanceChange {
                    address: address__,
                    coin_type: coin_type__,
                    amount: amount__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.BalanceChange", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BatchGetObjectsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.requests.is_empty() {
            len += 1;
        }
        if self.read_mask.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.BatchGetObjectsRequest", len)?;
        if !self.requests.is_empty() {
            struct_ser.serialize_field("requests", &self.requests)?;
        }
        if let Some(v) = self.read_mask.as_ref() {
            struct_ser.serialize_field("readMask", &crate::_serde::FieldMaskSerializer(v))?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BatchGetObjectsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "requests",
            "read_mask",
            "readMask",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Requests,
            ReadMask,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "requests" => Ok(GeneratedField::Requests),
                            "readMask" | "read_mask" => Ok(GeneratedField::ReadMask),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BatchGetObjectsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.BatchGetObjectsRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BatchGetObjectsRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut requests__ = None;
                let mut read_mask__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Requests => {
                            if requests__.is_some() {
                                return Err(serde::de::Error::duplicate_field("requests"));
                            }
                            requests__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ReadMask => {
                            if read_mask__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readMask"));
                            }
                            read_mask__ = map_.next_value::<::std::option::Option<crate::_serde::FieldMaskDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(BatchGetObjectsRequest {
                    requests: requests__.unwrap_or_default(),
                    read_mask: read_mask__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.BatchGetObjectsRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BatchGetObjectsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.objects.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.BatchGetObjectsResponse", len)?;
        if !self.objects.is_empty() {
            struct_ser.serialize_field("objects", &self.objects)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BatchGetObjectsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "objects",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Objects,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "objects" => Ok(GeneratedField::Objects),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BatchGetObjectsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.BatchGetObjectsResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BatchGetObjectsResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut objects__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Objects => {
                            if objects__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objects"));
                            }
                            objects__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(BatchGetObjectsResponse {
                    objects: objects__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.BatchGetObjectsResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BatchGetTransactionsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.digests.is_empty() {
            len += 1;
        }
        if self.read_mask.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.BatchGetTransactionsRequest", len)?;
        if !self.digests.is_empty() {
            struct_ser.serialize_field("digests", &self.digests)?;
        }
        if let Some(v) = self.read_mask.as_ref() {
            struct_ser.serialize_field("readMask", &crate::_serde::FieldMaskSerializer(v))?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BatchGetTransactionsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "digests",
            "read_mask",
            "readMask",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Digests,
            ReadMask,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "digests" => Ok(GeneratedField::Digests),
                            "readMask" | "read_mask" => Ok(GeneratedField::ReadMask),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BatchGetTransactionsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.BatchGetTransactionsRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BatchGetTransactionsRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut digests__ = None;
                let mut read_mask__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Digests => {
                            if digests__.is_some() {
                                return Err(serde::de::Error::duplicate_field("digests"));
                            }
                            digests__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ReadMask => {
                            if read_mask__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readMask"));
                            }
                            read_mask__ = map_.next_value::<::std::option::Option<crate::_serde::FieldMaskDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(BatchGetTransactionsRequest {
                    digests: digests__.unwrap_or_default(),
                    read_mask: read_mask__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.BatchGetTransactionsRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for BatchGetTransactionsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.transactions.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.BatchGetTransactionsResponse", len)?;
        if !self.transactions.is_empty() {
            struct_ser.serialize_field("transactions", &self.transactions)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for BatchGetTransactionsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "transactions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Transactions,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "transactions" => Ok(GeneratedField::Transactions),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = BatchGetTransactionsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.BatchGetTransactionsResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<BatchGetTransactionsResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut transactions__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Transactions => {
                            if transactions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transactions"));
                            }
                            transactions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(BatchGetTransactionsResponse {
                    transactions: transactions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.BatchGetTransactionsResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Bcs {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.Bcs", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.value.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("value", crate::_serde::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Bcs {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "value",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Value,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "value" => Ok(GeneratedField::Value),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Bcs;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.Bcs")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Bcs, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map_.next_value()?;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Bcs {
                    name: name__,
                    value: value__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.Bcs", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CanceledTransaction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.digest.is_some() {
            len += 1;
        }
        if !self.version_assignments.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.CanceledTransaction", len)?;
        if let Some(v) = self.digest.as_ref() {
            struct_ser.serialize_field("digest", v)?;
        }
        if !self.version_assignments.is_empty() {
            struct_ser.serialize_field("versionAssignments", &self.version_assignments)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CanceledTransaction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "digest",
            "version_assignments",
            "versionAssignments",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Digest,
            VersionAssignments,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "digest" => Ok(GeneratedField::Digest),
                            "versionAssignments" | "version_assignments" => Ok(GeneratedField::VersionAssignments),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CanceledTransaction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.CanceledTransaction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CanceledTransaction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut digest__ = None;
                let mut version_assignments__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Digest => {
                            if digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("digest"));
                            }
                            digest__ = map_.next_value()?;
                        }
                        GeneratedField::VersionAssignments => {
                            if version_assignments__.is_some() {
                                return Err(serde::de::Error::duplicate_field("versionAssignments"));
                            }
                            version_assignments__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(CanceledTransaction {
                    digest: digest__,
                    version_assignments: version_assignments__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.CanceledTransaction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ChangeEpoch {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.epoch.is_some() {
            len += 1;
        }
        if self.protocol_version.is_some() {
            len += 1;
        }
        if self.storage_charge.is_some() {
            len += 1;
        }
        if self.computation_charge.is_some() {
            len += 1;
        }
        if self.storage_rebate.is_some() {
            len += 1;
        }
        if self.non_refundable_storage_fee.is_some() {
            len += 1;
        }
        if self.epoch_start_timestamp.is_some() {
            len += 1;
        }
        if !self.system_packages.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ChangeEpoch", len)?;
        if let Some(v) = self.epoch.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("epoch", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.protocol_version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("protocolVersion", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.storage_charge.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("storageCharge", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.computation_charge.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("computationCharge", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.storage_rebate.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("storageRebate", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.non_refundable_storage_fee.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("nonRefundableStorageFee", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.epoch_start_timestamp.as_ref() {
            struct_ser.serialize_field("epochStartTimestamp", &crate::_serde::TimestampSerializer(v))?;
        }
        if !self.system_packages.is_empty() {
            struct_ser.serialize_field("systemPackages", &self.system_packages)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ChangeEpoch {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "epoch",
            "protocol_version",
            "protocolVersion",
            "storage_charge",
            "storageCharge",
            "computation_charge",
            "computationCharge",
            "storage_rebate",
            "storageRebate",
            "non_refundable_storage_fee",
            "nonRefundableStorageFee",
            "epoch_start_timestamp",
            "epochStartTimestamp",
            "system_packages",
            "systemPackages",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Epoch,
            ProtocolVersion,
            StorageCharge,
            ComputationCharge,
            StorageRebate,
            NonRefundableStorageFee,
            EpochStartTimestamp,
            SystemPackages,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "epoch" => Ok(GeneratedField::Epoch),
                            "protocolVersion" | "protocol_version" => Ok(GeneratedField::ProtocolVersion),
                            "storageCharge" | "storage_charge" => Ok(GeneratedField::StorageCharge),
                            "computationCharge" | "computation_charge" => Ok(GeneratedField::ComputationCharge),
                            "storageRebate" | "storage_rebate" => Ok(GeneratedField::StorageRebate),
                            "nonRefundableStorageFee" | "non_refundable_storage_fee" => Ok(GeneratedField::NonRefundableStorageFee),
                            "epochStartTimestamp" | "epoch_start_timestamp" => Ok(GeneratedField::EpochStartTimestamp),
                            "systemPackages" | "system_packages" => Ok(GeneratedField::SystemPackages),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ChangeEpoch;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ChangeEpoch")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ChangeEpoch, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut epoch__ = None;
                let mut protocol_version__ = None;
                let mut storage_charge__ = None;
                let mut computation_charge__ = None;
                let mut storage_rebate__ = None;
                let mut non_refundable_storage_fee__ = None;
                let mut epoch_start_timestamp__ = None;
                let mut system_packages__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Epoch => {
                            if epoch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("epoch"));
                            }
                            epoch__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ProtocolVersion => {
                            if protocol_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("protocolVersion"));
                            }
                            protocol_version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StorageCharge => {
                            if storage_charge__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storageCharge"));
                            }
                            storage_charge__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ComputationCharge => {
                            if computation_charge__.is_some() {
                                return Err(serde::de::Error::duplicate_field("computationCharge"));
                            }
                            computation_charge__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StorageRebate => {
                            if storage_rebate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storageRebate"));
                            }
                            storage_rebate__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NonRefundableStorageFee => {
                            if non_refundable_storage_fee__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nonRefundableStorageFee"));
                            }
                            non_refundable_storage_fee__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EpochStartTimestamp => {
                            if epoch_start_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("epochStartTimestamp"));
                            }
                            epoch_start_timestamp__ = map_.next_value::<::std::option::Option<crate::_serde::TimestampDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::SystemPackages => {
                            if system_packages__.is_some() {
                                return Err(serde::de::Error::duplicate_field("systemPackages"));
                            }
                            system_packages__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ChangeEpoch {
                    epoch: epoch__,
                    protocol_version: protocol_version__,
                    storage_charge: storage_charge__,
                    computation_charge: computation_charge__,
                    storage_rebate: storage_rebate__,
                    non_refundable_storage_fee: non_refundable_storage_fee__,
                    epoch_start_timestamp: epoch_start_timestamp__,
                    system_packages: system_packages__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ChangeEpoch", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ChangedObject {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.object_id.is_some() {
            len += 1;
        }
        if self.input_state.is_some() {
            len += 1;
        }
        if self.input_version.is_some() {
            len += 1;
        }
        if self.input_digest.is_some() {
            len += 1;
        }
        if self.input_owner.is_some() {
            len += 1;
        }
        if self.output_state.is_some() {
            len += 1;
        }
        if self.output_version.is_some() {
            len += 1;
        }
        if self.output_digest.is_some() {
            len += 1;
        }
        if self.output_owner.is_some() {
            len += 1;
        }
        if self.id_operation.is_some() {
            len += 1;
        }
        if self.object_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ChangedObject", len)?;
        if let Some(v) = self.object_id.as_ref() {
            struct_ser.serialize_field("objectId", v)?;
        }
        if let Some(v) = self.input_state.as_ref() {
            let v = changed_object::InputObjectState::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("inputState", &v)?;
        }
        if let Some(v) = self.input_version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("inputVersion", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.input_digest.as_ref() {
            struct_ser.serialize_field("inputDigest", v)?;
        }
        if let Some(v) = self.input_owner.as_ref() {
            struct_ser.serialize_field("inputOwner", v)?;
        }
        if let Some(v) = self.output_state.as_ref() {
            let v = changed_object::OutputObjectState::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("outputState", &v)?;
        }
        if let Some(v) = self.output_version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("outputVersion", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.output_digest.as_ref() {
            struct_ser.serialize_field("outputDigest", v)?;
        }
        if let Some(v) = self.output_owner.as_ref() {
            struct_ser.serialize_field("outputOwner", v)?;
        }
        if let Some(v) = self.id_operation.as_ref() {
            let v = changed_object::IdOperation::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("idOperation", &v)?;
        }
        if let Some(v) = self.object_type.as_ref() {
            struct_ser.serialize_field("objectType", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ChangedObject {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "object_id",
            "objectId",
            "input_state",
            "inputState",
            "input_version",
            "inputVersion",
            "input_digest",
            "inputDigest",
            "input_owner",
            "inputOwner",
            "output_state",
            "outputState",
            "output_version",
            "outputVersion",
            "output_digest",
            "outputDigest",
            "output_owner",
            "outputOwner",
            "id_operation",
            "idOperation",
            "object_type",
            "objectType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ObjectId,
            InputState,
            InputVersion,
            InputDigest,
            InputOwner,
            OutputState,
            OutputVersion,
            OutputDigest,
            OutputOwner,
            IdOperation,
            ObjectType,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "objectId" | "object_id" => Ok(GeneratedField::ObjectId),
                            "inputState" | "input_state" => Ok(GeneratedField::InputState),
                            "inputVersion" | "input_version" => Ok(GeneratedField::InputVersion),
                            "inputDigest" | "input_digest" => Ok(GeneratedField::InputDigest),
                            "inputOwner" | "input_owner" => Ok(GeneratedField::InputOwner),
                            "outputState" | "output_state" => Ok(GeneratedField::OutputState),
                            "outputVersion" | "output_version" => Ok(GeneratedField::OutputVersion),
                            "outputDigest" | "output_digest" => Ok(GeneratedField::OutputDigest),
                            "outputOwner" | "output_owner" => Ok(GeneratedField::OutputOwner),
                            "idOperation" | "id_operation" => Ok(GeneratedField::IdOperation),
                            "objectType" | "object_type" => Ok(GeneratedField::ObjectType),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ChangedObject;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ChangedObject")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ChangedObject, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut object_id__ = None;
                let mut input_state__ = None;
                let mut input_version__ = None;
                let mut input_digest__ = None;
                let mut input_owner__ = None;
                let mut output_state__ = None;
                let mut output_version__ = None;
                let mut output_digest__ = None;
                let mut output_owner__ = None;
                let mut id_operation__ = None;
                let mut object_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ObjectId => {
                            if object_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objectId"));
                            }
                            object_id__ = map_.next_value()?;
                        }
                        GeneratedField::InputState => {
                            if input_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inputState"));
                            }
                            input_state__ = map_.next_value::<::std::option::Option<changed_object::InputObjectState>>()?.map(|x| x as i32);
                        }
                        GeneratedField::InputVersion => {
                            if input_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inputVersion"));
                            }
                            input_version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::InputDigest => {
                            if input_digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inputDigest"));
                            }
                            input_digest__ = map_.next_value()?;
                        }
                        GeneratedField::InputOwner => {
                            if input_owner__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inputOwner"));
                            }
                            input_owner__ = map_.next_value()?;
                        }
                        GeneratedField::OutputState => {
                            if output_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("outputState"));
                            }
                            output_state__ = map_.next_value::<::std::option::Option<changed_object::OutputObjectState>>()?.map(|x| x as i32);
                        }
                        GeneratedField::OutputVersion => {
                            if output_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("outputVersion"));
                            }
                            output_version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OutputDigest => {
                            if output_digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("outputDigest"));
                            }
                            output_digest__ = map_.next_value()?;
                        }
                        GeneratedField::OutputOwner => {
                            if output_owner__.is_some() {
                                return Err(serde::de::Error::duplicate_field("outputOwner"));
                            }
                            output_owner__ = map_.next_value()?;
                        }
                        GeneratedField::IdOperation => {
                            if id_operation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("idOperation"));
                            }
                            id_operation__ = map_.next_value::<::std::option::Option<changed_object::IdOperation>>()?.map(|x| x as i32);
                        }
                        GeneratedField::ObjectType => {
                            if object_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objectType"));
                            }
                            object_type__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ChangedObject {
                    object_id: object_id__,
                    input_state: input_state__,
                    input_version: input_version__,
                    input_digest: input_digest__,
                    input_owner: input_owner__,
                    output_state: output_state__,
                    output_version: output_version__,
                    output_digest: output_digest__,
                    output_owner: output_owner__,
                    id_operation: id_operation__,
                    object_type: object_type__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ChangedObject", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for changed_object::IdOperation {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "ID_OPERATION_UNKNOWN",
            Self::None => "NONE",
            Self::Created => "CREATED",
            Self::Deleted => "DELETED",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for changed_object::IdOperation {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ID_OPERATION_UNKNOWN",
            "NONE",
            "CREATED",
            "DELETED",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = changed_object::IdOperation;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ID_OPERATION_UNKNOWN" => Ok(changed_object::IdOperation::Unknown),
                    "NONE" => Ok(changed_object::IdOperation::None),
                    "CREATED" => Ok(changed_object::IdOperation::Created),
                    "DELETED" => Ok(changed_object::IdOperation::Deleted),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for changed_object::InputObjectState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "INPUT_OBJECT_STATE_UNKNOWN",
            Self::DoesNotExist => "INPUT_OBJECT_STATE_DOES_NOT_EXIST",
            Self::Exists => "INPUT_OBJECT_STATE_EXISTS",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for changed_object::InputObjectState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "INPUT_OBJECT_STATE_UNKNOWN",
            "INPUT_OBJECT_STATE_DOES_NOT_EXIST",
            "INPUT_OBJECT_STATE_EXISTS",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = changed_object::InputObjectState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "INPUT_OBJECT_STATE_UNKNOWN" => Ok(changed_object::InputObjectState::Unknown),
                    "INPUT_OBJECT_STATE_DOES_NOT_EXIST" => Ok(changed_object::InputObjectState::DoesNotExist),
                    "INPUT_OBJECT_STATE_EXISTS" => Ok(changed_object::InputObjectState::Exists),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for changed_object::OutputObjectState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "OUTPUT_OBJECT_STATE_UNKNOWN",
            Self::DoesNotExist => "OUTPUT_OBJECT_STATE_DOES_NOT_EXIST",
            Self::ObjectWrite => "OUTPUT_OBJECT_STATE_OBJECT_WRITE",
            Self::PackageWrite => "OUTPUT_OBJECT_STATE_PACKAGE_WRITE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for changed_object::OutputObjectState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OUTPUT_OBJECT_STATE_UNKNOWN",
            "OUTPUT_OBJECT_STATE_DOES_NOT_EXIST",
            "OUTPUT_OBJECT_STATE_OBJECT_WRITE",
            "OUTPUT_OBJECT_STATE_PACKAGE_WRITE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = changed_object::OutputObjectState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "OUTPUT_OBJECT_STATE_UNKNOWN" => Ok(changed_object::OutputObjectState::Unknown),
                    "OUTPUT_OBJECT_STATE_DOES_NOT_EXIST" => Ok(changed_object::OutputObjectState::DoesNotExist),
                    "OUTPUT_OBJECT_STATE_OBJECT_WRITE" => Ok(changed_object::OutputObjectState::ObjectWrite),
                    "OUTPUT_OBJECT_STATE_PACKAGE_WRITE" => Ok(changed_object::OutputObjectState::PackageWrite),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Checkpoint {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.sequence_number.is_some() {
            len += 1;
        }
        if self.digest.is_some() {
            len += 1;
        }
        if self.summary.is_some() {
            len += 1;
        }
        if self.signature.is_some() {
            len += 1;
        }
        if self.contents.is_some() {
            len += 1;
        }
        if !self.transactions.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.Checkpoint", len)?;
        if let Some(v) = self.sequence_number.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("sequenceNumber", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.digest.as_ref() {
            struct_ser.serialize_field("digest", v)?;
        }
        if let Some(v) = self.summary.as_ref() {
            struct_ser.serialize_field("summary", v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            struct_ser.serialize_field("signature", v)?;
        }
        if let Some(v) = self.contents.as_ref() {
            struct_ser.serialize_field("contents", v)?;
        }
        if !self.transactions.is_empty() {
            struct_ser.serialize_field("transactions", &self.transactions)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Checkpoint {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "sequence_number",
            "sequenceNumber",
            "digest",
            "summary",
            "signature",
            "contents",
            "transactions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            SequenceNumber,
            Digest,
            Summary,
            Signature,
            Contents,
            Transactions,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "sequenceNumber" | "sequence_number" => Ok(GeneratedField::SequenceNumber),
                            "digest" => Ok(GeneratedField::Digest),
                            "summary" => Ok(GeneratedField::Summary),
                            "signature" => Ok(GeneratedField::Signature),
                            "contents" => Ok(GeneratedField::Contents),
                            "transactions" => Ok(GeneratedField::Transactions),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Checkpoint;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.Checkpoint")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Checkpoint, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut sequence_number__ = None;
                let mut digest__ = None;
                let mut summary__ = None;
                let mut signature__ = None;
                let mut contents__ = None;
                let mut transactions__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::SequenceNumber => {
                            if sequence_number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sequenceNumber"));
                            }
                            sequence_number__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Digest => {
                            if digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("digest"));
                            }
                            digest__ = map_.next_value()?;
                        }
                        GeneratedField::Summary => {
                            if summary__.is_some() {
                                return Err(serde::de::Error::duplicate_field("summary"));
                            }
                            summary__ = map_.next_value()?;
                        }
                        GeneratedField::Signature => {
                            if signature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("signature"));
                            }
                            signature__ = map_.next_value()?;
                        }
                        GeneratedField::Contents => {
                            if contents__.is_some() {
                                return Err(serde::de::Error::duplicate_field("contents"));
                            }
                            contents__ = map_.next_value()?;
                        }
                        GeneratedField::Transactions => {
                            if transactions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transactions"));
                            }
                            transactions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Checkpoint {
                    sequence_number: sequence_number__,
                    digest: digest__,
                    summary: summary__,
                    signature: signature__,
                    contents: contents__,
                    transactions: transactions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.Checkpoint", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CheckpointCommitment {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind.is_some() {
            len += 1;
        }
        if self.digest.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.CheckpointCommitment", len)?;
        if let Some(v) = self.kind.as_ref() {
            let v = checkpoint_commitment::CheckpointCommitmentKind::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if let Some(v) = self.digest.as_ref() {
            struct_ser.serialize_field("digest", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CheckpointCommitment {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kind",
            "digest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Kind,
            Digest,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kind" => Ok(GeneratedField::Kind),
                            "digest" => Ok(GeneratedField::Digest),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CheckpointCommitment;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.CheckpointCommitment")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CheckpointCommitment, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                let mut digest__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<checkpoint_commitment::CheckpointCommitmentKind>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Digest => {
                            if digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("digest"));
                            }
                            digest__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(CheckpointCommitment {
                    kind: kind__,
                    digest: digest__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.CheckpointCommitment", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for checkpoint_commitment::CheckpointCommitmentKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "CHECKPOINT_COMMITMENT_KIND_UNKNOWN",
            Self::EcmhLiveObjectSet => "ECMH_LIVE_OBJECT_SET",
            Self::CheckpointArtifacts => "CHECKPOINT_ARTIFACTS",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for checkpoint_commitment::CheckpointCommitmentKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "CHECKPOINT_COMMITMENT_KIND_UNKNOWN",
            "ECMH_LIVE_OBJECT_SET",
            "CHECKPOINT_ARTIFACTS",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = checkpoint_commitment::CheckpointCommitmentKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "CHECKPOINT_COMMITMENT_KIND_UNKNOWN" => Ok(checkpoint_commitment::CheckpointCommitmentKind::Unknown),
                    "ECMH_LIVE_OBJECT_SET" => Ok(checkpoint_commitment::CheckpointCommitmentKind::EcmhLiveObjectSet),
                    "CHECKPOINT_ARTIFACTS" => Ok(checkpoint_commitment::CheckpointCommitmentKind::CheckpointArtifacts),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for CheckpointContents {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.bcs.is_some() {
            len += 1;
        }
        if self.digest.is_some() {
            len += 1;
        }
        if self.version.is_some() {
            len += 1;
        }
        if !self.transactions.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.CheckpointContents", len)?;
        if let Some(v) = self.bcs.as_ref() {
            struct_ser.serialize_field("bcs", v)?;
        }
        if let Some(v) = self.digest.as_ref() {
            struct_ser.serialize_field("digest", v)?;
        }
        if let Some(v) = self.version.as_ref() {
            struct_ser.serialize_field("version", v)?;
        }
        if !self.transactions.is_empty() {
            struct_ser.serialize_field("transactions", &self.transactions)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CheckpointContents {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "bcs",
            "digest",
            "version",
            "transactions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Bcs,
            Digest,
            Version,
            Transactions,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "bcs" => Ok(GeneratedField::Bcs),
                            "digest" => Ok(GeneratedField::Digest),
                            "version" => Ok(GeneratedField::Version),
                            "transactions" => Ok(GeneratedField::Transactions),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CheckpointContents;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.CheckpointContents")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CheckpointContents, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut bcs__ = None;
                let mut digest__ = None;
                let mut version__ = None;
                let mut transactions__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Bcs => {
                            if bcs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bcs"));
                            }
                            bcs__ = map_.next_value()?;
                        }
                        GeneratedField::Digest => {
                            if digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("digest"));
                            }
                            digest__ = map_.next_value()?;
                        }
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Transactions => {
                            if transactions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transactions"));
                            }
                            transactions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(CheckpointContents {
                    bcs: bcs__,
                    digest: digest__,
                    version: version__,
                    transactions: transactions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.CheckpointContents", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CheckpointSummary {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.bcs.is_some() {
            len += 1;
        }
        if self.digest.is_some() {
            len += 1;
        }
        if self.epoch.is_some() {
            len += 1;
        }
        if self.sequence_number.is_some() {
            len += 1;
        }
        if self.total_network_transactions.is_some() {
            len += 1;
        }
        if self.content_digest.is_some() {
            len += 1;
        }
        if self.previous_digest.is_some() {
            len += 1;
        }
        if self.epoch_rolling_gas_cost_summary.is_some() {
            len += 1;
        }
        if self.timestamp.is_some() {
            len += 1;
        }
        if !self.commitments.is_empty() {
            len += 1;
        }
        if self.end_of_epoch_data.is_some() {
            len += 1;
        }
        if self.version_specific_data.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.CheckpointSummary", len)?;
        if let Some(v) = self.bcs.as_ref() {
            struct_ser.serialize_field("bcs", v)?;
        }
        if let Some(v) = self.digest.as_ref() {
            struct_ser.serialize_field("digest", v)?;
        }
        if let Some(v) = self.epoch.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("epoch", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.sequence_number.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("sequenceNumber", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.total_network_transactions.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("totalNetworkTransactions", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.content_digest.as_ref() {
            struct_ser.serialize_field("contentDigest", v)?;
        }
        if let Some(v) = self.previous_digest.as_ref() {
            struct_ser.serialize_field("previousDigest", v)?;
        }
        if let Some(v) = self.epoch_rolling_gas_cost_summary.as_ref() {
            struct_ser.serialize_field("epochRollingGasCostSummary", v)?;
        }
        if let Some(v) = self.timestamp.as_ref() {
            struct_ser.serialize_field("timestamp", &crate::_serde::TimestampSerializer(v))?;
        }
        if !self.commitments.is_empty() {
            struct_ser.serialize_field("commitments", &self.commitments)?;
        }
        if let Some(v) = self.end_of_epoch_data.as_ref() {
            struct_ser.serialize_field("endOfEpochData", v)?;
        }
        if let Some(v) = self.version_specific_data.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("versionSpecificData", crate::_serde::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CheckpointSummary {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "bcs",
            "digest",
            "epoch",
            "sequence_number",
            "sequenceNumber",
            "total_network_transactions",
            "totalNetworkTransactions",
            "content_digest",
            "contentDigest",
            "previous_digest",
            "previousDigest",
            "epoch_rolling_gas_cost_summary",
            "epochRollingGasCostSummary",
            "timestamp",
            "commitments",
            "end_of_epoch_data",
            "endOfEpochData",
            "version_specific_data",
            "versionSpecificData",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Bcs,
            Digest,
            Epoch,
            SequenceNumber,
            TotalNetworkTransactions,
            ContentDigest,
            PreviousDigest,
            EpochRollingGasCostSummary,
            Timestamp,
            Commitments,
            EndOfEpochData,
            VersionSpecificData,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "bcs" => Ok(GeneratedField::Bcs),
                            "digest" => Ok(GeneratedField::Digest),
                            "epoch" => Ok(GeneratedField::Epoch),
                            "sequenceNumber" | "sequence_number" => Ok(GeneratedField::SequenceNumber),
                            "totalNetworkTransactions" | "total_network_transactions" => Ok(GeneratedField::TotalNetworkTransactions),
                            "contentDigest" | "content_digest" => Ok(GeneratedField::ContentDigest),
                            "previousDigest" | "previous_digest" => Ok(GeneratedField::PreviousDigest),
                            "epochRollingGasCostSummary" | "epoch_rolling_gas_cost_summary" => Ok(GeneratedField::EpochRollingGasCostSummary),
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "commitments" => Ok(GeneratedField::Commitments),
                            "endOfEpochData" | "end_of_epoch_data" => Ok(GeneratedField::EndOfEpochData),
                            "versionSpecificData" | "version_specific_data" => Ok(GeneratedField::VersionSpecificData),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CheckpointSummary;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.CheckpointSummary")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CheckpointSummary, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut bcs__ = None;
                let mut digest__ = None;
                let mut epoch__ = None;
                let mut sequence_number__ = None;
                let mut total_network_transactions__ = None;
                let mut content_digest__ = None;
                let mut previous_digest__ = None;
                let mut epoch_rolling_gas_cost_summary__ = None;
                let mut timestamp__ = None;
                let mut commitments__ = None;
                let mut end_of_epoch_data__ = None;
                let mut version_specific_data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Bcs => {
                            if bcs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bcs"));
                            }
                            bcs__ = map_.next_value()?;
                        }
                        GeneratedField::Digest => {
                            if digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("digest"));
                            }
                            digest__ = map_.next_value()?;
                        }
                        GeneratedField::Epoch => {
                            if epoch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("epoch"));
                            }
                            epoch__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SequenceNumber => {
                            if sequence_number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sequenceNumber"));
                            }
                            sequence_number__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TotalNetworkTransactions => {
                            if total_network_transactions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("totalNetworkTransactions"));
                            }
                            total_network_transactions__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ContentDigest => {
                            if content_digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("contentDigest"));
                            }
                            content_digest__ = map_.next_value()?;
                        }
                        GeneratedField::PreviousDigest => {
                            if previous_digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("previousDigest"));
                            }
                            previous_digest__ = map_.next_value()?;
                        }
                        GeneratedField::EpochRollingGasCostSummary => {
                            if epoch_rolling_gas_cost_summary__.is_some() {
                                return Err(serde::de::Error::duplicate_field("epochRollingGasCostSummary"));
                            }
                            epoch_rolling_gas_cost_summary__ = map_.next_value()?;
                        }
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = map_.next_value::<::std::option::Option<crate::_serde::TimestampDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::Commitments => {
                            if commitments__.is_some() {
                                return Err(serde::de::Error::duplicate_field("commitments"));
                            }
                            commitments__ = Some(map_.next_value()?);
                        }
                        GeneratedField::EndOfEpochData => {
                            if end_of_epoch_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("endOfEpochData"));
                            }
                            end_of_epoch_data__ = map_.next_value()?;
                        }
                        GeneratedField::VersionSpecificData => {
                            if version_specific_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("versionSpecificData"));
                            }
                            version_specific_data__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(CheckpointSummary {
                    bcs: bcs__,
                    digest: digest__,
                    epoch: epoch__,
                    sequence_number: sequence_number__,
                    total_network_transactions: total_network_transactions__,
                    content_digest: content_digest__,
                    previous_digest: previous_digest__,
                    epoch_rolling_gas_cost_summary: epoch_rolling_gas_cost_summary__,
                    timestamp: timestamp__,
                    commitments: commitments__.unwrap_or_default(),
                    end_of_epoch_data: end_of_epoch_data__,
                    version_specific_data: version_specific_data__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.CheckpointSummary", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CheckpointedTransactionInfo {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.transaction.is_some() {
            len += 1;
        }
        if self.effects.is_some() {
            len += 1;
        }
        if !self.signatures.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.CheckpointedTransactionInfo", len)?;
        if let Some(v) = self.transaction.as_ref() {
            struct_ser.serialize_field("transaction", v)?;
        }
        if let Some(v) = self.effects.as_ref() {
            struct_ser.serialize_field("effects", v)?;
        }
        if !self.signatures.is_empty() {
            struct_ser.serialize_field("signatures", &self.signatures)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CheckpointedTransactionInfo {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "transaction",
            "effects",
            "signatures",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Transaction,
            Effects,
            Signatures,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "transaction" => Ok(GeneratedField::Transaction),
                            "effects" => Ok(GeneratedField::Effects),
                            "signatures" => Ok(GeneratedField::Signatures),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CheckpointedTransactionInfo;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.CheckpointedTransactionInfo")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CheckpointedTransactionInfo, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut transaction__ = None;
                let mut effects__ = None;
                let mut signatures__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Transaction => {
                            if transaction__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transaction"));
                            }
                            transaction__ = map_.next_value()?;
                        }
                        GeneratedField::Effects => {
                            if effects__.is_some() {
                                return Err(serde::de::Error::duplicate_field("effects"));
                            }
                            effects__ = map_.next_value()?;
                        }
                        GeneratedField::Signatures => {
                            if signatures__.is_some() {
                                return Err(serde::de::Error::duplicate_field("signatures"));
                            }
                            signatures__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(CheckpointedTransactionInfo {
                    transaction: transaction__,
                    effects: effects__,
                    signatures: signatures__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.CheckpointedTransactionInfo", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CircomG1 {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.e0.is_some() {
            len += 1;
        }
        if self.e1.is_some() {
            len += 1;
        }
        if self.e2.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.CircomG1", len)?;
        if let Some(v) = self.e0.as_ref() {
            struct_ser.serialize_field("e0", v)?;
        }
        if let Some(v) = self.e1.as_ref() {
            struct_ser.serialize_field("e1", v)?;
        }
        if let Some(v) = self.e2.as_ref() {
            struct_ser.serialize_field("e2", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CircomG1 {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "e0",
            "e1",
            "e2",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            E0,
            E1,
            E2,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "e0" => Ok(GeneratedField::E0),
                            "e1" => Ok(GeneratedField::E1),
                            "e2" => Ok(GeneratedField::E2),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CircomG1;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.CircomG1")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CircomG1, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut e0__ = None;
                let mut e1__ = None;
                let mut e2__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::E0 => {
                            if e0__.is_some() {
                                return Err(serde::de::Error::duplicate_field("e0"));
                            }
                            e0__ = map_.next_value()?;
                        }
                        GeneratedField::E1 => {
                            if e1__.is_some() {
                                return Err(serde::de::Error::duplicate_field("e1"));
                            }
                            e1__ = map_.next_value()?;
                        }
                        GeneratedField::E2 => {
                            if e2__.is_some() {
                                return Err(serde::de::Error::duplicate_field("e2"));
                            }
                            e2__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(CircomG1 {
                    e0: e0__,
                    e1: e1__,
                    e2: e2__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.CircomG1", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CircomG2 {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.e00.is_some() {
            len += 1;
        }
        if self.e01.is_some() {
            len += 1;
        }
        if self.e10.is_some() {
            len += 1;
        }
        if self.e11.is_some() {
            len += 1;
        }
        if self.e20.is_some() {
            len += 1;
        }
        if self.e21.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.CircomG2", len)?;
        if let Some(v) = self.e00.as_ref() {
            struct_ser.serialize_field("e00", v)?;
        }
        if let Some(v) = self.e01.as_ref() {
            struct_ser.serialize_field("e01", v)?;
        }
        if let Some(v) = self.e10.as_ref() {
            struct_ser.serialize_field("e10", v)?;
        }
        if let Some(v) = self.e11.as_ref() {
            struct_ser.serialize_field("e11", v)?;
        }
        if let Some(v) = self.e20.as_ref() {
            struct_ser.serialize_field("e20", v)?;
        }
        if let Some(v) = self.e21.as_ref() {
            struct_ser.serialize_field("e21", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CircomG2 {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "e00",
            "e01",
            "e10",
            "e11",
            "e20",
            "e21",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            E00,
            E01,
            E10,
            E11,
            E20,
            E21,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "e00" => Ok(GeneratedField::E00),
                            "e01" => Ok(GeneratedField::E01),
                            "e10" => Ok(GeneratedField::E10),
                            "e11" => Ok(GeneratedField::E11),
                            "e20" => Ok(GeneratedField::E20),
                            "e21" => Ok(GeneratedField::E21),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CircomG2;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.CircomG2")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CircomG2, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut e00__ = None;
                let mut e01__ = None;
                let mut e10__ = None;
                let mut e11__ = None;
                let mut e20__ = None;
                let mut e21__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::E00 => {
                            if e00__.is_some() {
                                return Err(serde::de::Error::duplicate_field("e00"));
                            }
                            e00__ = map_.next_value()?;
                        }
                        GeneratedField::E01 => {
                            if e01__.is_some() {
                                return Err(serde::de::Error::duplicate_field("e01"));
                            }
                            e01__ = map_.next_value()?;
                        }
                        GeneratedField::E10 => {
                            if e10__.is_some() {
                                return Err(serde::de::Error::duplicate_field("e10"));
                            }
                            e10__ = map_.next_value()?;
                        }
                        GeneratedField::E11 => {
                            if e11__.is_some() {
                                return Err(serde::de::Error::duplicate_field("e11"));
                            }
                            e11__ = map_.next_value()?;
                        }
                        GeneratedField::E20 => {
                            if e20__.is_some() {
                                return Err(serde::de::Error::duplicate_field("e20"));
                            }
                            e20__ = map_.next_value()?;
                        }
                        GeneratedField::E21 => {
                            if e21__.is_some() {
                                return Err(serde::de::Error::duplicate_field("e21"));
                            }
                            e21__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(CircomG2 {
                    e00: e00__,
                    e01: e01__,
                    e10: e10__,
                    e11: e11__,
                    e20: e20__,
                    e21: e21__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.CircomG2", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CleverError {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.error_code.is_some() {
            len += 1;
        }
        if self.line_number.is_some() {
            len += 1;
        }
        if self.constant_name.is_some() {
            len += 1;
        }
        if self.constant_type.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.CleverError", len)?;
        if let Some(v) = self.error_code.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("errorCode", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.line_number.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("lineNumber", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.constant_name.as_ref() {
            struct_ser.serialize_field("constantName", v)?;
        }
        if let Some(v) = self.constant_type.as_ref() {
            struct_ser.serialize_field("constantType", v)?;
        }
        if let Some(v) = self.value.as_ref() {
            match v {
                clever_error::Value::Rendered(v) => {
                    struct_ser.serialize_field("rendered", v)?;
                }
                clever_error::Value::Raw(v) => {
                    #[allow(clippy::needless_borrow)]
                    #[allow(clippy::needless_borrows_for_generic_args)]
                    struct_ser.serialize_field("raw", crate::_serde::base64::encode(&v).as_str())?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CleverError {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "error_code",
            "errorCode",
            "line_number",
            "lineNumber",
            "constant_name",
            "constantName",
            "constant_type",
            "constantType",
            "rendered",
            "raw",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ErrorCode,
            LineNumber,
            ConstantName,
            ConstantType,
            Rendered,
            Raw,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "errorCode" | "error_code" => Ok(GeneratedField::ErrorCode),
                            "lineNumber" | "line_number" => Ok(GeneratedField::LineNumber),
                            "constantName" | "constant_name" => Ok(GeneratedField::ConstantName),
                            "constantType" | "constant_type" => Ok(GeneratedField::ConstantType),
                            "rendered" => Ok(GeneratedField::Rendered),
                            "raw" => Ok(GeneratedField::Raw),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CleverError;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.CleverError")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CleverError, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut error_code__ = None;
                let mut line_number__ = None;
                let mut constant_name__ = None;
                let mut constant_type__ = None;
                let mut value__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ErrorCode => {
                            if error_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("errorCode"));
                            }
                            error_code__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LineNumber => {
                            if line_number__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lineNumber"));
                            }
                            line_number__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ConstantName => {
                            if constant_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("constantName"));
                            }
                            constant_name__ = map_.next_value()?;
                        }
                        GeneratedField::ConstantType => {
                            if constant_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("constantType"));
                            }
                            constant_type__ = map_.next_value()?;
                        }
                        GeneratedField::Rendered => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rendered"));
                            }
                            value__ = map_.next_value::<::std::option::Option<_>>()?.map(clever_error::Value::Rendered);
                        }
                        GeneratedField::Raw => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("raw"));
                            }
                            value__ = map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| clever_error::Value::Raw(x.0));
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(CleverError {
                    error_code: error_code__,
                    line_number: line_number__,
                    constant_name: constant_name__,
                    constant_type: constant_type__,
                    value: value__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.CleverError", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CoinDenyListError {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.address.is_some() {
            len += 1;
        }
        if self.coin_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.CoinDenyListError", len)?;
        if let Some(v) = self.address.as_ref() {
            struct_ser.serialize_field("address", v)?;
        }
        if let Some(v) = self.coin_type.as_ref() {
            struct_ser.serialize_field("coinType", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CoinDenyListError {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "address",
            "coin_type",
            "coinType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Address,
            CoinType,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "address" => Ok(GeneratedField::Address),
                            "coinType" | "coin_type" => Ok(GeneratedField::CoinType),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CoinDenyListError;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.CoinDenyListError")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CoinDenyListError, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut address__ = None;
                let mut coin_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Address => {
                            if address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("address"));
                            }
                            address__ = map_.next_value()?;
                        }
                        GeneratedField::CoinType => {
                            if coin_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coinType"));
                            }
                            coin_type__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(CoinDenyListError {
                    address: address__,
                    coin_type: coin_type__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.CoinDenyListError", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CoinMetadata {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.decimals.is_some() {
            len += 1;
        }
        if self.name.is_some() {
            len += 1;
        }
        if self.symbol.is_some() {
            len += 1;
        }
        if self.description.is_some() {
            len += 1;
        }
        if self.icon_url.is_some() {
            len += 1;
        }
        if self.metadata_cap_id.is_some() {
            len += 1;
        }
        if self.metadata_cap_state.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.CoinMetadata", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("id", v)?;
        }
        if let Some(v) = self.decimals.as_ref() {
            struct_ser.serialize_field("decimals", v)?;
        }
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.symbol.as_ref() {
            struct_ser.serialize_field("symbol", v)?;
        }
        if let Some(v) = self.description.as_ref() {
            struct_ser.serialize_field("description", v)?;
        }
        if let Some(v) = self.icon_url.as_ref() {
            struct_ser.serialize_field("iconUrl", v)?;
        }
        if let Some(v) = self.metadata_cap_id.as_ref() {
            struct_ser.serialize_field("metadataCapId", v)?;
        }
        if let Some(v) = self.metadata_cap_state.as_ref() {
            let v = coin_metadata::MetadataCapState::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("metadataCapState", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CoinMetadata {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "decimals",
            "name",
            "symbol",
            "description",
            "icon_url",
            "iconUrl",
            "metadata_cap_id",
            "metadataCapId",
            "metadata_cap_state",
            "metadataCapState",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Decimals,
            Name,
            Symbol,
            Description,
            IconUrl,
            MetadataCapId,
            MetadataCapState,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "decimals" => Ok(GeneratedField::Decimals),
                            "name" => Ok(GeneratedField::Name),
                            "symbol" => Ok(GeneratedField::Symbol),
                            "description" => Ok(GeneratedField::Description),
                            "iconUrl" | "icon_url" => Ok(GeneratedField::IconUrl),
                            "metadataCapId" | "metadata_cap_id" => Ok(GeneratedField::MetadataCapId),
                            "metadataCapState" | "metadata_cap_state" => Ok(GeneratedField::MetadataCapState),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CoinMetadata;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.CoinMetadata")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CoinMetadata, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut decimals__ = None;
                let mut name__ = None;
                let mut symbol__ = None;
                let mut description__ = None;
                let mut icon_url__ = None;
                let mut metadata_cap_id__ = None;
                let mut metadata_cap_state__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = map_.next_value()?;
                        }
                        GeneratedField::Decimals => {
                            if decimals__.is_some() {
                                return Err(serde::de::Error::duplicate_field("decimals"));
                            }
                            decimals__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map_.next_value()?;
                        }
                        GeneratedField::Symbol => {
                            if symbol__.is_some() {
                                return Err(serde::de::Error::duplicate_field("symbol"));
                            }
                            symbol__ = map_.next_value()?;
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = map_.next_value()?;
                        }
                        GeneratedField::IconUrl => {
                            if icon_url__.is_some() {
                                return Err(serde::de::Error::duplicate_field("iconUrl"));
                            }
                            icon_url__ = map_.next_value()?;
                        }
                        GeneratedField::MetadataCapId => {
                            if metadata_cap_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadataCapId"));
                            }
                            metadata_cap_id__ = map_.next_value()?;
                        }
                        GeneratedField::MetadataCapState => {
                            if metadata_cap_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadataCapState"));
                            }
                            metadata_cap_state__ = map_.next_value::<::std::option::Option<coin_metadata::MetadataCapState>>()?.map(|x| x as i32);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(CoinMetadata {
                    id: id__,
                    decimals: decimals__,
                    name: name__,
                    symbol: symbol__,
                    description: description__,
                    icon_url: icon_url__,
                    metadata_cap_id: metadata_cap_id__,
                    metadata_cap_state: metadata_cap_state__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.CoinMetadata", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for coin_metadata::MetadataCapState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "METADATA_CAP_STATE_UNKNOWN",
            Self::Claimed => "CLAIMED",
            Self::Unclaimed => "UNCLAIMED",
            Self::Deleted => "DELETED",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for coin_metadata::MetadataCapState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "METADATA_CAP_STATE_UNKNOWN",
            "CLAIMED",
            "UNCLAIMED",
            "DELETED",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = coin_metadata::MetadataCapState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "METADATA_CAP_STATE_UNKNOWN" => Ok(coin_metadata::MetadataCapState::Unknown),
                    "CLAIMED" => Ok(coin_metadata::MetadataCapState::Claimed),
                    "UNCLAIMED" => Ok(coin_metadata::MetadataCapState::Unclaimed),
                    "DELETED" => Ok(coin_metadata::MetadataCapState::Deleted),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for CoinTreasury {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.total_supply.is_some() {
            len += 1;
        }
        if self.supply_state.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.CoinTreasury", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("id", v)?;
        }
        if let Some(v) = self.total_supply.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("totalSupply", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.supply_state.as_ref() {
            let v = coin_treasury::SupplyState::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("supplyState", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CoinTreasury {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "total_supply",
            "totalSupply",
            "supply_state",
            "supplyState",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            TotalSupply,
            SupplyState,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "totalSupply" | "total_supply" => Ok(GeneratedField::TotalSupply),
                            "supplyState" | "supply_state" => Ok(GeneratedField::SupplyState),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CoinTreasury;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.CoinTreasury")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CoinTreasury, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut total_supply__ = None;
                let mut supply_state__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = map_.next_value()?;
                        }
                        GeneratedField::TotalSupply => {
                            if total_supply__.is_some() {
                                return Err(serde::de::Error::duplicate_field("totalSupply"));
                            }
                            total_supply__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SupplyState => {
                            if supply_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("supplyState"));
                            }
                            supply_state__ = map_.next_value::<::std::option::Option<coin_treasury::SupplyState>>()?.map(|x| x as i32);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(CoinTreasury {
                    id: id__,
                    total_supply: total_supply__,
                    supply_state: supply_state__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.CoinTreasury", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for coin_treasury::SupplyState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "SUPPLY_STATE_UNKNOWN",
            Self::Fixed => "FIXED",
            Self::BurnOnly => "BURN_ONLY",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for coin_treasury::SupplyState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "SUPPLY_STATE_UNKNOWN",
            "FIXED",
            "BURN_ONLY",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = coin_treasury::SupplyState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "SUPPLY_STATE_UNKNOWN" => Ok(coin_treasury::SupplyState::Unknown),
                    "FIXED" => Ok(coin_treasury::SupplyState::Fixed),
                    "BURN_ONLY" => Ok(coin_treasury::SupplyState::BurnOnly),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Command {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.command.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.Command", len)?;
        if let Some(v) = self.command.as_ref() {
            match v {
                command::Command::MoveCall(v) => {
                    struct_ser.serialize_field("moveCall", v)?;
                }
                command::Command::TransferObjects(v) => {
                    struct_ser.serialize_field("transferObjects", v)?;
                }
                command::Command::SplitCoins(v) => {
                    struct_ser.serialize_field("splitCoins", v)?;
                }
                command::Command::MergeCoins(v) => {
                    struct_ser.serialize_field("mergeCoins", v)?;
                }
                command::Command::Publish(v) => {
                    struct_ser.serialize_field("publish", v)?;
                }
                command::Command::MakeMoveVector(v) => {
                    struct_ser.serialize_field("makeMoveVector", v)?;
                }
                command::Command::Upgrade(v) => {
                    struct_ser.serialize_field("upgrade", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Command {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "move_call",
            "moveCall",
            "transfer_objects",
            "transferObjects",
            "split_coins",
            "splitCoins",
            "merge_coins",
            "mergeCoins",
            "publish",
            "make_move_vector",
            "makeMoveVector",
            "upgrade",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            MoveCall,
            TransferObjects,
            SplitCoins,
            MergeCoins,
            Publish,
            MakeMoveVector,
            Upgrade,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "moveCall" | "move_call" => Ok(GeneratedField::MoveCall),
                            "transferObjects" | "transfer_objects" => Ok(GeneratedField::TransferObjects),
                            "splitCoins" | "split_coins" => Ok(GeneratedField::SplitCoins),
                            "mergeCoins" | "merge_coins" => Ok(GeneratedField::MergeCoins),
                            "publish" => Ok(GeneratedField::Publish),
                            "makeMoveVector" | "make_move_vector" => Ok(GeneratedField::MakeMoveVector),
                            "upgrade" => Ok(GeneratedField::Upgrade),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Command;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.Command")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Command, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut command__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::MoveCall => {
                            if command__.is_some() {
                                return Err(serde::de::Error::duplicate_field("moveCall"));
                            }
                            command__ = map_.next_value::<::std::option::Option<_>>()?.map(command::Command::MoveCall)
;
                        }
                        GeneratedField::TransferObjects => {
                            if command__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transferObjects"));
                            }
                            command__ = map_.next_value::<::std::option::Option<_>>()?.map(command::Command::TransferObjects)
;
                        }
                        GeneratedField::SplitCoins => {
                            if command__.is_some() {
                                return Err(serde::de::Error::duplicate_field("splitCoins"));
                            }
                            command__ = map_.next_value::<::std::option::Option<_>>()?.map(command::Command::SplitCoins)
;
                        }
                        GeneratedField::MergeCoins => {
                            if command__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mergeCoins"));
                            }
                            command__ = map_.next_value::<::std::option::Option<_>>()?.map(command::Command::MergeCoins)
;
                        }
                        GeneratedField::Publish => {
                            if command__.is_some() {
                                return Err(serde::de::Error::duplicate_field("publish"));
                            }
                            command__ = map_.next_value::<::std::option::Option<_>>()?.map(command::Command::Publish)
;
                        }
                        GeneratedField::MakeMoveVector => {
                            if command__.is_some() {
                                return Err(serde::de::Error::duplicate_field("makeMoveVector"));
                            }
                            command__ = map_.next_value::<::std::option::Option<_>>()?.map(command::Command::MakeMoveVector)
;
                        }
                        GeneratedField::Upgrade => {
                            if command__.is_some() {
                                return Err(serde::de::Error::duplicate_field("upgrade"));
                            }
                            command__ = map_.next_value::<::std::option::Option<_>>()?.map(command::Command::Upgrade)
;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Command {
                    command: command__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.Command", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CommandArgumentError {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.argument.is_some() {
            len += 1;
        }
        if self.kind.is_some() {
            len += 1;
        }
        if self.index_error.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.CommandArgumentError", len)?;
        if let Some(v) = self.argument.as_ref() {
            struct_ser.serialize_field("argument", v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            let v = command_argument_error::CommandArgumentErrorKind::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if let Some(v) = self.index_error.as_ref() {
            struct_ser.serialize_field("indexError", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommandArgumentError {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "argument",
            "kind",
            "index_error",
            "indexError",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Argument,
            Kind,
            IndexError,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "argument" => Ok(GeneratedField::Argument),
                            "kind" => Ok(GeneratedField::Kind),
                            "indexError" | "index_error" => Ok(GeneratedField::IndexError),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommandArgumentError;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.CommandArgumentError")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommandArgumentError, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut argument__ = None;
                let mut kind__ = None;
                let mut index_error__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Argument => {
                            if argument__.is_some() {
                                return Err(serde::de::Error::duplicate_field("argument"));
                            }
                            argument__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<command_argument_error::CommandArgumentErrorKind>>()?.map(|x| x as i32);
                        }
                        GeneratedField::IndexError => {
                            if index_error__.is_some() {
                                return Err(serde::de::Error::duplicate_field("indexError"));
                            }
                            index_error__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(CommandArgumentError {
                    argument: argument__,
                    kind: kind__,
                    index_error: index_error__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.CommandArgumentError", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for command_argument_error::CommandArgumentErrorKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "COMMAND_ARGUMENT_ERROR_KIND_UNKNOWN",
            Self::TypeMismatch => "TYPE_MISMATCH",
            Self::InvalidBcsBytes => "INVALID_BCS_BYTES",
            Self::InvalidUsageOfPureArgument => "INVALID_USAGE_OF_PURE_ARGUMENT",
            Self::InvalidArgumentToPrivateEntryFunction => "INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION",
            Self::IndexOutOfBounds => "INDEX_OUT_OF_BOUNDS",
            Self::SecondaryIndexOutOfBounds => "SECONDARY_INDEX_OUT_OF_BOUNDS",
            Self::InvalidResultArity => "INVALID_RESULT_ARITY",
            Self::InvalidGasCoinUsage => "INVALID_GAS_COIN_USAGE",
            Self::InvalidValueUsage => "INVALID_VALUE_USAGE",
            Self::InvalidObjectByValue => "INVALID_OBJECT_BY_VALUE",
            Self::InvalidObjectByMutRef => "INVALID_OBJECT_BY_MUT_REF",
            Self::ConsensusObjectOperationNotAllowed => "CONSENSUS_OBJECT_OPERATION_NOT_ALLOWED",
            Self::InvalidArgumentArity => "INVALID_ARGUMENT_ARITY",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for command_argument_error::CommandArgumentErrorKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "COMMAND_ARGUMENT_ERROR_KIND_UNKNOWN",
            "TYPE_MISMATCH",
            "INVALID_BCS_BYTES",
            "INVALID_USAGE_OF_PURE_ARGUMENT",
            "INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION",
            "INDEX_OUT_OF_BOUNDS",
            "SECONDARY_INDEX_OUT_OF_BOUNDS",
            "INVALID_RESULT_ARITY",
            "INVALID_GAS_COIN_USAGE",
            "INVALID_VALUE_USAGE",
            "INVALID_OBJECT_BY_VALUE",
            "INVALID_OBJECT_BY_MUT_REF",
            "CONSENSUS_OBJECT_OPERATION_NOT_ALLOWED",
            "INVALID_ARGUMENT_ARITY",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = command_argument_error::CommandArgumentErrorKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "COMMAND_ARGUMENT_ERROR_KIND_UNKNOWN" => Ok(command_argument_error::CommandArgumentErrorKind::Unknown),
                    "TYPE_MISMATCH" => Ok(command_argument_error::CommandArgumentErrorKind::TypeMismatch),
                    "INVALID_BCS_BYTES" => Ok(command_argument_error::CommandArgumentErrorKind::InvalidBcsBytes),
                    "INVALID_USAGE_OF_PURE_ARGUMENT" => Ok(command_argument_error::CommandArgumentErrorKind::InvalidUsageOfPureArgument),
                    "INVALID_ARGUMENT_TO_PRIVATE_ENTRY_FUNCTION" => Ok(command_argument_error::CommandArgumentErrorKind::InvalidArgumentToPrivateEntryFunction),
                    "INDEX_OUT_OF_BOUNDS" => Ok(command_argument_error::CommandArgumentErrorKind::IndexOutOfBounds),
                    "SECONDARY_INDEX_OUT_OF_BOUNDS" => Ok(command_argument_error::CommandArgumentErrorKind::SecondaryIndexOutOfBounds),
                    "INVALID_RESULT_ARITY" => Ok(command_argument_error::CommandArgumentErrorKind::InvalidResultArity),
                    "INVALID_GAS_COIN_USAGE" => Ok(command_argument_error::CommandArgumentErrorKind::InvalidGasCoinUsage),
                    "INVALID_VALUE_USAGE" => Ok(command_argument_error::CommandArgumentErrorKind::InvalidValueUsage),
                    "INVALID_OBJECT_BY_VALUE" => Ok(command_argument_error::CommandArgumentErrorKind::InvalidObjectByValue),
                    "INVALID_OBJECT_BY_MUT_REF" => Ok(command_argument_error::CommandArgumentErrorKind::InvalidObjectByMutRef),
                    "CONSENSUS_OBJECT_OPERATION_NOT_ALLOWED" => Ok(command_argument_error::CommandArgumentErrorKind::ConsensusObjectOperationNotAllowed),
                    "INVALID_ARGUMENT_ARITY" => Ok(command_argument_error::CommandArgumentErrorKind::InvalidArgumentArity),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for CommandOutput {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.argument.is_some() {
            len += 1;
        }
        if self.value.is_some() {
            len += 1;
        }
        if self.json.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.CommandOutput", len)?;
        if let Some(v) = self.argument.as_ref() {
            struct_ser.serialize_field("argument", v)?;
        }
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("value", v)?;
        }
        if let Some(v) = self.json.as_ref() {
            struct_ser.serialize_field("json", &crate::_serde::ValueSerializer(v))?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommandOutput {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "argument",
            "value",
            "json",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Argument,
            Value,
            Json,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "argument" => Ok(GeneratedField::Argument),
                            "value" => Ok(GeneratedField::Value),
                            "json" => Ok(GeneratedField::Json),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommandOutput;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.CommandOutput")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommandOutput, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut argument__ = None;
                let mut value__ = None;
                let mut json__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Argument => {
                            if argument__.is_some() {
                                return Err(serde::de::Error::duplicate_field("argument"));
                            }
                            argument__ = map_.next_value()?;
                        }
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = map_.next_value()?;
                        }
                        GeneratedField::Json => {
                            if json__.is_some() {
                                return Err(serde::de::Error::duplicate_field("json"));
                            }
                            json__ = map_.next_value::<::std::option::Option<crate::_serde::ValueDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(CommandOutput {
                    argument: argument__,
                    value: value__,
                    json: json__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.CommandOutput", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CommandResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.return_values.is_empty() {
            len += 1;
        }
        if !self.mutated_by_ref.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.CommandResult", len)?;
        if !self.return_values.is_empty() {
            struct_ser.serialize_field("returnValues", &self.return_values)?;
        }
        if !self.mutated_by_ref.is_empty() {
            struct_ser.serialize_field("mutatedByRef", &self.mutated_by_ref)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CommandResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "return_values",
            "returnValues",
            "mutated_by_ref",
            "mutatedByRef",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ReturnValues,
            MutatedByRef,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "returnValues" | "return_values" => Ok(GeneratedField::ReturnValues),
                            "mutatedByRef" | "mutated_by_ref" => Ok(GeneratedField::MutatedByRef),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CommandResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.CommandResult")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CommandResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut return_values__ = None;
                let mut mutated_by_ref__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ReturnValues => {
                            if return_values__.is_some() {
                                return Err(serde::de::Error::duplicate_field("returnValues"));
                            }
                            return_values__ = Some(map_.next_value()?);
                        }
                        GeneratedField::MutatedByRef => {
                            if mutated_by_ref__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mutatedByRef"));
                            }
                            mutated_by_ref__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(CommandResult {
                    return_values: return_values__.unwrap_or_default(),
                    mutated_by_ref: mutated_by_ref__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.CommandResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for CongestedObjects {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.objects.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.CongestedObjects", len)?;
        if !self.objects.is_empty() {
            struct_ser.serialize_field("objects", &self.objects)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for CongestedObjects {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "objects",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Objects,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "objects" => Ok(GeneratedField::Objects),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = CongestedObjects;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.CongestedObjects")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<CongestedObjects, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut objects__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Objects => {
                            if objects__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objects"));
                            }
                            objects__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(CongestedObjects {
                    objects: objects__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.CongestedObjects", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ConsensusCommitPrologue {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.epoch.is_some() {
            len += 1;
        }
        if self.round.is_some() {
            len += 1;
        }
        if self.commit_timestamp.is_some() {
            len += 1;
        }
        if self.consensus_commit_digest.is_some() {
            len += 1;
        }
        if self.sub_dag_index.is_some() {
            len += 1;
        }
        if self.consensus_determined_version_assignments.is_some() {
            len += 1;
        }
        if self.additional_state_digest.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ConsensusCommitPrologue", len)?;
        if let Some(v) = self.epoch.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("epoch", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.round.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("round", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.commit_timestamp.as_ref() {
            struct_ser.serialize_field("commitTimestamp", &crate::_serde::TimestampSerializer(v))?;
        }
        if let Some(v) = self.consensus_commit_digest.as_ref() {
            struct_ser.serialize_field("consensusCommitDigest", v)?;
        }
        if let Some(v) = self.sub_dag_index.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("subDagIndex", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.consensus_determined_version_assignments.as_ref() {
            struct_ser.serialize_field("consensusDeterminedVersionAssignments", v)?;
        }
        if let Some(v) = self.additional_state_digest.as_ref() {
            struct_ser.serialize_field("additionalStateDigest", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ConsensusCommitPrologue {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "epoch",
            "round",
            "commit_timestamp",
            "commitTimestamp",
            "consensus_commit_digest",
            "consensusCommitDigest",
            "sub_dag_index",
            "subDagIndex",
            "consensus_determined_version_assignments",
            "consensusDeterminedVersionAssignments",
            "additional_state_digest",
            "additionalStateDigest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Epoch,
            Round,
            CommitTimestamp,
            ConsensusCommitDigest,
            SubDagIndex,
            ConsensusDeterminedVersionAssignments,
            AdditionalStateDigest,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "epoch" => Ok(GeneratedField::Epoch),
                            "round" => Ok(GeneratedField::Round),
                            "commitTimestamp" | "commit_timestamp" => Ok(GeneratedField::CommitTimestamp),
                            "consensusCommitDigest" | "consensus_commit_digest" => Ok(GeneratedField::ConsensusCommitDigest),
                            "subDagIndex" | "sub_dag_index" => Ok(GeneratedField::SubDagIndex),
                            "consensusDeterminedVersionAssignments" | "consensus_determined_version_assignments" => Ok(GeneratedField::ConsensusDeterminedVersionAssignments),
                            "additionalStateDigest" | "additional_state_digest" => Ok(GeneratedField::AdditionalStateDigest),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ConsensusCommitPrologue;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ConsensusCommitPrologue")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ConsensusCommitPrologue, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut epoch__ = None;
                let mut round__ = None;
                let mut commit_timestamp__ = None;
                let mut consensus_commit_digest__ = None;
                let mut sub_dag_index__ = None;
                let mut consensus_determined_version_assignments__ = None;
                let mut additional_state_digest__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Epoch => {
                            if epoch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("epoch"));
                            }
                            epoch__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Round => {
                            if round__.is_some() {
                                return Err(serde::de::Error::duplicate_field("round"));
                            }
                            round__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CommitTimestamp => {
                            if commit_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("commitTimestamp"));
                            }
                            commit_timestamp__ = map_.next_value::<::std::option::Option<crate::_serde::TimestampDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::ConsensusCommitDigest => {
                            if consensus_commit_digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("consensusCommitDigest"));
                            }
                            consensus_commit_digest__ = map_.next_value()?;
                        }
                        GeneratedField::SubDagIndex => {
                            if sub_dag_index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subDagIndex"));
                            }
                            sub_dag_index__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ConsensusDeterminedVersionAssignments => {
                            if consensus_determined_version_assignments__.is_some() {
                                return Err(serde::de::Error::duplicate_field("consensusDeterminedVersionAssignments"));
                            }
                            consensus_determined_version_assignments__ = map_.next_value()?;
                        }
                        GeneratedField::AdditionalStateDigest => {
                            if additional_state_digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("additionalStateDigest"));
                            }
                            additional_state_digest__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ConsensusCommitPrologue {
                    epoch: epoch__,
                    round: round__,
                    commit_timestamp: commit_timestamp__,
                    consensus_commit_digest: consensus_commit_digest__,
                    sub_dag_index: sub_dag_index__,
                    consensus_determined_version_assignments: consensus_determined_version_assignments__,
                    additional_state_digest: additional_state_digest__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ConsensusCommitPrologue", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ConsensusDeterminedVersionAssignments {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.version.is_some() {
            len += 1;
        }
        if !self.canceled_transactions.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ConsensusDeterminedVersionAssignments", len)?;
        if let Some(v) = self.version.as_ref() {
            struct_ser.serialize_field("version", v)?;
        }
        if !self.canceled_transactions.is_empty() {
            struct_ser.serialize_field("canceledTransactions", &self.canceled_transactions)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ConsensusDeterminedVersionAssignments {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "version",
            "canceled_transactions",
            "canceledTransactions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Version,
            CanceledTransactions,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "version" => Ok(GeneratedField::Version),
                            "canceledTransactions" | "canceled_transactions" => Ok(GeneratedField::CanceledTransactions),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ConsensusDeterminedVersionAssignments;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ConsensusDeterminedVersionAssignments")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ConsensusDeterminedVersionAssignments, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut version__ = None;
                let mut canceled_transactions__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CanceledTransactions => {
                            if canceled_transactions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("canceledTransactions"));
                            }
                            canceled_transactions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ConsensusDeterminedVersionAssignments {
                    version: version__,
                    canceled_transactions: canceled_transactions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ConsensusDeterminedVersionAssignments", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for DatatypeDescriptor {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_name.is_some() {
            len += 1;
        }
        if self.defining_id.is_some() {
            len += 1;
        }
        if self.module.is_some() {
            len += 1;
        }
        if self.name.is_some() {
            len += 1;
        }
        if !self.abilities.is_empty() {
            len += 1;
        }
        if !self.type_parameters.is_empty() {
            len += 1;
        }
        if self.kind.is_some() {
            len += 1;
        }
        if !self.fields.is_empty() {
            len += 1;
        }
        if !self.variants.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.DatatypeDescriptor", len)?;
        if let Some(v) = self.type_name.as_ref() {
            struct_ser.serialize_field("typeName", v)?;
        }
        if let Some(v) = self.defining_id.as_ref() {
            struct_ser.serialize_field("definingId", v)?;
        }
        if let Some(v) = self.module.as_ref() {
            struct_ser.serialize_field("module", v)?;
        }
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if !self.abilities.is_empty() {
            let v = self.abilities.iter().cloned().map(|v| {
                Ability::try_from(v)
                    .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", v)))
                }).collect::<std::result::Result<Vec<_>, _>>()?;
            struct_ser.serialize_field("abilities", &v)?;
        }
        if !self.type_parameters.is_empty() {
            struct_ser.serialize_field("typeParameters", &self.type_parameters)?;
        }
        if let Some(v) = self.kind.as_ref() {
            let v = datatype_descriptor::DatatypeKind::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if !self.fields.is_empty() {
            struct_ser.serialize_field("fields", &self.fields)?;
        }
        if !self.variants.is_empty() {
            struct_ser.serialize_field("variants", &self.variants)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DatatypeDescriptor {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_name",
            "typeName",
            "defining_id",
            "definingId",
            "module",
            "name",
            "abilities",
            "type_parameters",
            "typeParameters",
            "kind",
            "fields",
            "variants",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeName,
            DefiningId,
            Module,
            Name,
            Abilities,
            TypeParameters,
            Kind,
            Fields,
            Variants,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeName" | "type_name" => Ok(GeneratedField::TypeName),
                            "definingId" | "defining_id" => Ok(GeneratedField::DefiningId),
                            "module" => Ok(GeneratedField::Module),
                            "name" => Ok(GeneratedField::Name),
                            "abilities" => Ok(GeneratedField::Abilities),
                            "typeParameters" | "type_parameters" => Ok(GeneratedField::TypeParameters),
                            "kind" => Ok(GeneratedField::Kind),
                            "fields" => Ok(GeneratedField::Fields),
                            "variants" => Ok(GeneratedField::Variants),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DatatypeDescriptor;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.DatatypeDescriptor")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DatatypeDescriptor, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_name__ = None;
                let mut defining_id__ = None;
                let mut module__ = None;
                let mut name__ = None;
                let mut abilities__ = None;
                let mut type_parameters__ = None;
                let mut kind__ = None;
                let mut fields__ = None;
                let mut variants__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeName => {
                            if type_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeName"));
                            }
                            type_name__ = map_.next_value()?;
                        }
                        GeneratedField::DefiningId => {
                            if defining_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("definingId"));
                            }
                            defining_id__ = map_.next_value()?;
                        }
                        GeneratedField::Module => {
                            if module__.is_some() {
                                return Err(serde::de::Error::duplicate_field("module"));
                            }
                            module__ = map_.next_value()?;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map_.next_value()?;
                        }
                        GeneratedField::Abilities => {
                            if abilities__.is_some() {
                                return Err(serde::de::Error::duplicate_field("abilities"));
                            }
                            abilities__ = Some(map_.next_value::<Vec<Ability>>()?.into_iter().map(|x| x as i32).collect());
                        }
                        GeneratedField::TypeParameters => {
                            if type_parameters__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeParameters"));
                            }
                            type_parameters__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<datatype_descriptor::DatatypeKind>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Fields => {
                            if fields__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fields"));
                            }
                            fields__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Variants => {
                            if variants__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variants"));
                            }
                            variants__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(DatatypeDescriptor {
                    type_name: type_name__,
                    defining_id: defining_id__,
                    module: module__,
                    name: name__,
                    abilities: abilities__.unwrap_or_default(),
                    type_parameters: type_parameters__.unwrap_or_default(),
                    kind: kind__,
                    fields: fields__.unwrap_or_default(),
                    variants: variants__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.DatatypeDescriptor", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for datatype_descriptor::DatatypeKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "DATATYPE_KIND_UNKNOWN",
            Self::Struct => "STRUCT",
            Self::Enum => "ENUM",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for datatype_descriptor::DatatypeKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DATATYPE_KIND_UNKNOWN",
            "STRUCT",
            "ENUM",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = datatype_descriptor::DatatypeKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "DATATYPE_KIND_UNKNOWN" => Ok(datatype_descriptor::DatatypeKind::Unknown),
                    "STRUCT" => Ok(datatype_descriptor::DatatypeKind::Struct),
                    "ENUM" => Ok(datatype_descriptor::DatatypeKind::Enum),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for DynamicField {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind.is_some() {
            len += 1;
        }
        if self.parent.is_some() {
            len += 1;
        }
        if self.field_id.is_some() {
            len += 1;
        }
        if self.name_type.is_some() {
            len += 1;
        }
        if self.name_value.is_some() {
            len += 1;
        }
        if self.value_type.is_some() {
            len += 1;
        }
        if self.dynamic_object_id.is_some() {
            len += 1;
        }
        if self.object.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.DynamicField", len)?;
        if let Some(v) = self.kind.as_ref() {
            let v = dynamic_field::DynamicFieldKind::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if let Some(v) = self.parent.as_ref() {
            struct_ser.serialize_field("parent", v)?;
        }
        if let Some(v) = self.field_id.as_ref() {
            struct_ser.serialize_field("fieldId", v)?;
        }
        if let Some(v) = self.name_type.as_ref() {
            struct_ser.serialize_field("nameType", v)?;
        }
        if let Some(v) = self.name_value.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("nameValue", crate::_serde::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.value_type.as_ref() {
            struct_ser.serialize_field("valueType", v)?;
        }
        if let Some(v) = self.dynamic_object_id.as_ref() {
            struct_ser.serialize_field("dynamicObjectId", v)?;
        }
        if let Some(v) = self.object.as_ref() {
            struct_ser.serialize_field("object", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for DynamicField {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kind",
            "parent",
            "field_id",
            "fieldId",
            "name_type",
            "nameType",
            "name_value",
            "nameValue",
            "value_type",
            "valueType",
            "dynamic_object_id",
            "dynamicObjectId",
            "object",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Kind,
            Parent,
            FieldId,
            NameType,
            NameValue,
            ValueType,
            DynamicObjectId,
            Object,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kind" => Ok(GeneratedField::Kind),
                            "parent" => Ok(GeneratedField::Parent),
                            "fieldId" | "field_id" => Ok(GeneratedField::FieldId),
                            "nameType" | "name_type" => Ok(GeneratedField::NameType),
                            "nameValue" | "name_value" => Ok(GeneratedField::NameValue),
                            "valueType" | "value_type" => Ok(GeneratedField::ValueType),
                            "dynamicObjectId" | "dynamic_object_id" => Ok(GeneratedField::DynamicObjectId),
                            "object" => Ok(GeneratedField::Object),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = DynamicField;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.DynamicField")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<DynamicField, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                let mut parent__ = None;
                let mut field_id__ = None;
                let mut name_type__ = None;
                let mut name_value__ = None;
                let mut value_type__ = None;
                let mut dynamic_object_id__ = None;
                let mut object__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<dynamic_field::DynamicFieldKind>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Parent => {
                            if parent__.is_some() {
                                return Err(serde::de::Error::duplicate_field("parent"));
                            }
                            parent__ = map_.next_value()?;
                        }
                        GeneratedField::FieldId => {
                            if field_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fieldId"));
                            }
                            field_id__ = map_.next_value()?;
                        }
                        GeneratedField::NameType => {
                            if name_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nameType"));
                            }
                            name_type__ = map_.next_value()?;
                        }
                        GeneratedField::NameValue => {
                            if name_value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nameValue"));
                            }
                            name_value__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ValueType => {
                            if value_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("valueType"));
                            }
                            value_type__ = map_.next_value()?;
                        }
                        GeneratedField::DynamicObjectId => {
                            if dynamic_object_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dynamicObjectId"));
                            }
                            dynamic_object_id__ = map_.next_value()?;
                        }
                        GeneratedField::Object => {
                            if object__.is_some() {
                                return Err(serde::de::Error::duplicate_field("object"));
                            }
                            object__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(DynamicField {
                    kind: kind__,
                    parent: parent__,
                    field_id: field_id__,
                    name_type: name_type__,
                    name_value: name_value__,
                    value_type: value_type__,
                    dynamic_object_id: dynamic_object_id__,
                    object: object__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.DynamicField", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for dynamic_field::DynamicFieldKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "DYNAMIC_FIELD_KIND_UNKNOWN",
            Self::Field => "FIELD",
            Self::Object => "OBJECT",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for dynamic_field::DynamicFieldKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "DYNAMIC_FIELD_KIND_UNKNOWN",
            "FIELD",
            "OBJECT",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = dynamic_field::DynamicFieldKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "DYNAMIC_FIELD_KIND_UNKNOWN" => Ok(dynamic_field::DynamicFieldKind::Unknown),
                    "FIELD" => Ok(dynamic_field::DynamicFieldKind::Field),
                    "OBJECT" => Ok(dynamic_field::DynamicFieldKind::Object),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for EndOfEpochData {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.next_epoch_committee.is_empty() {
            len += 1;
        }
        if self.next_epoch_protocol_version.is_some() {
            len += 1;
        }
        if !self.epoch_commitments.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.EndOfEpochData", len)?;
        if !self.next_epoch_committee.is_empty() {
            struct_ser.serialize_field("nextEpochCommittee", &self.next_epoch_committee)?;
        }
        if let Some(v) = self.next_epoch_protocol_version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("nextEpochProtocolVersion", ToString::to_string(&v).as_str())?;
        }
        if !self.epoch_commitments.is_empty() {
            struct_ser.serialize_field("epochCommitments", &self.epoch_commitments)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EndOfEpochData {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "next_epoch_committee",
            "nextEpochCommittee",
            "next_epoch_protocol_version",
            "nextEpochProtocolVersion",
            "epoch_commitments",
            "epochCommitments",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            NextEpochCommittee,
            NextEpochProtocolVersion,
            EpochCommitments,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "nextEpochCommittee" | "next_epoch_committee" => Ok(GeneratedField::NextEpochCommittee),
                            "nextEpochProtocolVersion" | "next_epoch_protocol_version" => Ok(GeneratedField::NextEpochProtocolVersion),
                            "epochCommitments" | "epoch_commitments" => Ok(GeneratedField::EpochCommitments),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EndOfEpochData;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.EndOfEpochData")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EndOfEpochData, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut next_epoch_committee__ = None;
                let mut next_epoch_protocol_version__ = None;
                let mut epoch_commitments__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::NextEpochCommittee => {
                            if next_epoch_committee__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nextEpochCommittee"));
                            }
                            next_epoch_committee__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NextEpochProtocolVersion => {
                            if next_epoch_protocol_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nextEpochProtocolVersion"));
                            }
                            next_epoch_protocol_version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EpochCommitments => {
                            if epoch_commitments__.is_some() {
                                return Err(serde::de::Error::duplicate_field("epochCommitments"));
                            }
                            epoch_commitments__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(EndOfEpochData {
                    next_epoch_committee: next_epoch_committee__.unwrap_or_default(),
                    next_epoch_protocol_version: next_epoch_protocol_version__,
                    epoch_commitments: epoch_commitments__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.EndOfEpochData", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EndOfEpochTransaction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.transactions.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.EndOfEpochTransaction", len)?;
        if !self.transactions.is_empty() {
            struct_ser.serialize_field("transactions", &self.transactions)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EndOfEpochTransaction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "transactions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Transactions,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "transactions" => Ok(GeneratedField::Transactions),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EndOfEpochTransaction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.EndOfEpochTransaction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EndOfEpochTransaction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut transactions__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Transactions => {
                            if transactions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transactions"));
                            }
                            transactions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(EndOfEpochTransaction {
                    transactions: transactions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.EndOfEpochTransaction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for EndOfEpochTransactionKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.EndOfEpochTransactionKind", len)?;
        if let Some(v) = self.kind.as_ref() {
            match v {
                end_of_epoch_transaction_kind::Kind::ChangeEpoch(v) => {
                    struct_ser.serialize_field("changeEpoch", v)?;
                }
                end_of_epoch_transaction_kind::Kind::AuthenticatorStateExpire(v) => {
                    struct_ser.serialize_field("authenticatorStateExpire", v)?;
                }
                end_of_epoch_transaction_kind::Kind::ExecutionTimeObservations(v) => {
                    struct_ser.serialize_field("executionTimeObservations", v)?;
                }
                end_of_epoch_transaction_kind::Kind::AuthenticatorStateCreate(v) => {
                    struct_ser.serialize_field("authenticatorStateCreate", &crate::_serde::EmptySerializer(v))?;
                }
                end_of_epoch_transaction_kind::Kind::RandomnessStateCreate(v) => {
                    struct_ser.serialize_field("randomnessStateCreate", &crate::_serde::EmptySerializer(v))?;
                }
                end_of_epoch_transaction_kind::Kind::DenyListStateCreate(v) => {
                    struct_ser.serialize_field("denyListStateCreate", &crate::_serde::EmptySerializer(v))?;
                }
                end_of_epoch_transaction_kind::Kind::BridgeStateCreate(v) => {
                    struct_ser.serialize_field("bridgeStateCreate", v)?;
                }
                end_of_epoch_transaction_kind::Kind::BridgeCommitteeInit(v) => {
                    #[allow(clippy::needless_borrow)]
                    #[allow(clippy::needless_borrows_for_generic_args)]
                    struct_ser.serialize_field("bridgeCommitteeInit", ToString::to_string(&v).as_str())?;
                }
                end_of_epoch_transaction_kind::Kind::AccumulatorRootCreate(v) => {
                    struct_ser.serialize_field("accumulatorRootCreate", &crate::_serde::EmptySerializer(v))?;
                }
                end_of_epoch_transaction_kind::Kind::CoinRegistryCreate(v) => {
                    struct_ser.serialize_field("coinRegistryCreate", &crate::_serde::EmptySerializer(v))?;
                }
                end_of_epoch_transaction_kind::Kind::DisplayRegistryCreate(v) => {
                    struct_ser.serialize_field("displayRegistryCreate", &crate::_serde::EmptySerializer(v))?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for EndOfEpochTransactionKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "change_epoch",
            "changeEpoch",
            "authenticator_state_expire",
            "authenticatorStateExpire",
            "execution_time_observations",
            "executionTimeObservations",
            "authenticator_state_create",
            "authenticatorStateCreate",
            "randomness_state_create",
            "randomnessStateCreate",
            "deny_list_state_create",
            "denyListStateCreate",
            "bridge_state_create",
            "bridgeStateCreate",
            "bridge_committee_init",
            "bridgeCommitteeInit",
            "accumulator_root_create",
            "accumulatorRootCreate",
            "coin_registry_create",
            "coinRegistryCreate",
            "display_registry_create",
            "displayRegistryCreate",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ChangeEpoch,
            AuthenticatorStateExpire,
            ExecutionTimeObservations,
            AuthenticatorStateCreate,
            RandomnessStateCreate,
            DenyListStateCreate,
            BridgeStateCreate,
            BridgeCommitteeInit,
            AccumulatorRootCreate,
            CoinRegistryCreate,
            DisplayRegistryCreate,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "changeEpoch" | "change_epoch" => Ok(GeneratedField::ChangeEpoch),
                            "authenticatorStateExpire" | "authenticator_state_expire" => Ok(GeneratedField::AuthenticatorStateExpire),
                            "executionTimeObservations" | "execution_time_observations" => Ok(GeneratedField::ExecutionTimeObservations),
                            "authenticatorStateCreate" | "authenticator_state_create" => Ok(GeneratedField::AuthenticatorStateCreate),
                            "randomnessStateCreate" | "randomness_state_create" => Ok(GeneratedField::RandomnessStateCreate),
                            "denyListStateCreate" | "deny_list_state_create" => Ok(GeneratedField::DenyListStateCreate),
                            "bridgeStateCreate" | "bridge_state_create" => Ok(GeneratedField::BridgeStateCreate),
                            "bridgeCommitteeInit" | "bridge_committee_init" => Ok(GeneratedField::BridgeCommitteeInit),
                            "accumulatorRootCreate" | "accumulator_root_create" => Ok(GeneratedField::AccumulatorRootCreate),
                            "coinRegistryCreate" | "coin_registry_create" => Ok(GeneratedField::CoinRegistryCreate),
                            "displayRegistryCreate" | "display_registry_create" => Ok(GeneratedField::DisplayRegistryCreate),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = EndOfEpochTransactionKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.EndOfEpochTransactionKind")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<EndOfEpochTransactionKind, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ChangeEpoch => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("changeEpoch"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(end_of_epoch_transaction_kind::Kind::ChangeEpoch)
;
                        }
                        GeneratedField::AuthenticatorStateExpire => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("authenticatorStateExpire"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(end_of_epoch_transaction_kind::Kind::AuthenticatorStateExpire)
;
                        }
                        GeneratedField::ExecutionTimeObservations => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("executionTimeObservations"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(end_of_epoch_transaction_kind::Kind::ExecutionTimeObservations)
;
                        }
                        GeneratedField::AuthenticatorStateCreate => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("authenticatorStateCreate"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<crate::_serde::EmptyDeserializer>>()?.map(|x| end_of_epoch_transaction_kind::Kind::AuthenticatorStateCreate(x.0));
                        }
                        GeneratedField::RandomnessStateCreate => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("randomnessStateCreate"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<crate::_serde::EmptyDeserializer>>()?.map(|x| end_of_epoch_transaction_kind::Kind::RandomnessStateCreate(x.0));
                        }
                        GeneratedField::DenyListStateCreate => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("denyListStateCreate"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<crate::_serde::EmptyDeserializer>>()?.map(|x| end_of_epoch_transaction_kind::Kind::DenyListStateCreate(x.0));
                        }
                        GeneratedField::BridgeStateCreate => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bridgeStateCreate"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(end_of_epoch_transaction_kind::Kind::BridgeStateCreate);
                        }
                        GeneratedField::BridgeCommitteeInit => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bridgeCommitteeInit"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| end_of_epoch_transaction_kind::Kind::BridgeCommitteeInit(x.0));
                        }
                        GeneratedField::AccumulatorRootCreate => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("accumulatorRootCreate"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<crate::_serde::EmptyDeserializer>>()?.map(|x| end_of_epoch_transaction_kind::Kind::AccumulatorRootCreate(x.0));
                        }
                        GeneratedField::CoinRegistryCreate => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coinRegistryCreate"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<crate::_serde::EmptyDeserializer>>()?.map(|x| end_of_epoch_transaction_kind::Kind::CoinRegistryCreate(x.0));
                        }
                        GeneratedField::DisplayRegistryCreate => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("displayRegistryCreate"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<crate::_serde::EmptyDeserializer>>()?.map(|x| end_of_epoch_transaction_kind::Kind::DisplayRegistryCreate(x.0));
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(EndOfEpochTransactionKind {
                    kind: kind__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.EndOfEpochTransactionKind", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Epoch {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.epoch.is_some() {
            len += 1;
        }
        if self.committee.is_some() {
            len += 1;
        }
        if self.system_state.is_some() {
            len += 1;
        }
        if self.first_checkpoint.is_some() {
            len += 1;
        }
        if self.last_checkpoint.is_some() {
            len += 1;
        }
        if self.start.is_some() {
            len += 1;
        }
        if self.end.is_some() {
            len += 1;
        }
        if self.reference_gas_price.is_some() {
            len += 1;
        }
        if self.protocol_config.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.Epoch", len)?;
        if let Some(v) = self.epoch.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("epoch", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.committee.as_ref() {
            struct_ser.serialize_field("committee", v)?;
        }
        if let Some(v) = self.system_state.as_ref() {
            struct_ser.serialize_field("systemState", v)?;
        }
        if let Some(v) = self.first_checkpoint.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("firstCheckpoint", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.last_checkpoint.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("lastCheckpoint", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.start.as_ref() {
            struct_ser.serialize_field("start", &crate::_serde::TimestampSerializer(v))?;
        }
        if let Some(v) = self.end.as_ref() {
            struct_ser.serialize_field("end", &crate::_serde::TimestampSerializer(v))?;
        }
        if let Some(v) = self.reference_gas_price.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("referenceGasPrice", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.protocol_config.as_ref() {
            struct_ser.serialize_field("protocolConfig", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Epoch {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "epoch",
            "committee",
            "system_state",
            "systemState",
            "first_checkpoint",
            "firstCheckpoint",
            "last_checkpoint",
            "lastCheckpoint",
            "start",
            "end",
            "reference_gas_price",
            "referenceGasPrice",
            "protocol_config",
            "protocolConfig",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Epoch,
            Committee,
            SystemState,
            FirstCheckpoint,
            LastCheckpoint,
            Start,
            End,
            ReferenceGasPrice,
            ProtocolConfig,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "epoch" => Ok(GeneratedField::Epoch),
                            "committee" => Ok(GeneratedField::Committee),
                            "systemState" | "system_state" => Ok(GeneratedField::SystemState),
                            "firstCheckpoint" | "first_checkpoint" => Ok(GeneratedField::FirstCheckpoint),
                            "lastCheckpoint" | "last_checkpoint" => Ok(GeneratedField::LastCheckpoint),
                            "start" => Ok(GeneratedField::Start),
                            "end" => Ok(GeneratedField::End),
                            "referenceGasPrice" | "reference_gas_price" => Ok(GeneratedField::ReferenceGasPrice),
                            "protocolConfig" | "protocol_config" => Ok(GeneratedField::ProtocolConfig),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Epoch;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.Epoch")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Epoch, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut epoch__ = None;
                let mut committee__ = None;
                let mut system_state__ = None;
                let mut first_checkpoint__ = None;
                let mut last_checkpoint__ = None;
                let mut start__ = None;
                let mut end__ = None;
                let mut reference_gas_price__ = None;
                let mut protocol_config__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Epoch => {
                            if epoch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("epoch"));
                            }
                            epoch__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Committee => {
                            if committee__.is_some() {
                                return Err(serde::de::Error::duplicate_field("committee"));
                            }
                            committee__ = map_.next_value()?;
                        }
                        GeneratedField::SystemState => {
                            if system_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("systemState"));
                            }
                            system_state__ = map_.next_value()?;
                        }
                        GeneratedField::FirstCheckpoint => {
                            if first_checkpoint__.is_some() {
                                return Err(serde::de::Error::duplicate_field("firstCheckpoint"));
                            }
                            first_checkpoint__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LastCheckpoint => {
                            if last_checkpoint__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lastCheckpoint"));
                            }
                            last_checkpoint__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Start => {
                            if start__.is_some() {
                                return Err(serde::de::Error::duplicate_field("start"));
                            }
                            start__ = map_.next_value::<::std::option::Option<crate::_serde::TimestampDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::End => {
                            if end__.is_some() {
                                return Err(serde::de::Error::duplicate_field("end"));
                            }
                            end__ = map_.next_value::<::std::option::Option<crate::_serde::TimestampDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::ReferenceGasPrice => {
                            if reference_gas_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("referenceGasPrice"));
                            }
                            reference_gas_price__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ProtocolConfig => {
                            if protocol_config__.is_some() {
                                return Err(serde::de::Error::duplicate_field("protocolConfig"));
                            }
                            protocol_config__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Epoch {
                    epoch: epoch__,
                    committee: committee__,
                    system_state: system_state__,
                    first_checkpoint: first_checkpoint__,
                    last_checkpoint: last_checkpoint__,
                    start: start__,
                    end: end__,
                    reference_gas_price: reference_gas_price__,
                    protocol_config: protocol_config__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.Epoch", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ErrorReason {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "ERROR_REASON_UNKNOWN",
            Self::FieldInvalid => "FIELD_INVALID",
            Self::FieldMissing => "FIELD_MISSING",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for ErrorReason {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ERROR_REASON_UNKNOWN",
            "FIELD_INVALID",
            "FIELD_MISSING",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ErrorReason;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ERROR_REASON_UNKNOWN" => Ok(ErrorReason::Unknown),
                    "FIELD_INVALID" => Ok(ErrorReason::FieldInvalid),
                    "FIELD_MISSING" => Ok(ErrorReason::FieldMissing),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Event {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.package_id.is_some() {
            len += 1;
        }
        if self.module.is_some() {
            len += 1;
        }
        if self.sender.is_some() {
            len += 1;
        }
        if self.event_type.is_some() {
            len += 1;
        }
        if self.contents.is_some() {
            len += 1;
        }
        if self.json.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.Event", len)?;
        if let Some(v) = self.package_id.as_ref() {
            struct_ser.serialize_field("packageId", v)?;
        }
        if let Some(v) = self.module.as_ref() {
            struct_ser.serialize_field("module", v)?;
        }
        if let Some(v) = self.sender.as_ref() {
            struct_ser.serialize_field("sender", v)?;
        }
        if let Some(v) = self.event_type.as_ref() {
            struct_ser.serialize_field("eventType", v)?;
        }
        if let Some(v) = self.contents.as_ref() {
            struct_ser.serialize_field("contents", v)?;
        }
        if let Some(v) = self.json.as_ref() {
            struct_ser.serialize_field("json", &crate::_serde::ValueSerializer(v))?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Event {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "package_id",
            "packageId",
            "module",
            "sender",
            "event_type",
            "eventType",
            "contents",
            "json",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PackageId,
            Module,
            Sender,
            EventType,
            Contents,
            Json,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "packageId" | "package_id" => Ok(GeneratedField::PackageId),
                            "module" => Ok(GeneratedField::Module),
                            "sender" => Ok(GeneratedField::Sender),
                            "eventType" | "event_type" => Ok(GeneratedField::EventType),
                            "contents" => Ok(GeneratedField::Contents),
                            "json" => Ok(GeneratedField::Json),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Event;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.Event")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Event, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut package_id__ = None;
                let mut module__ = None;
                let mut sender__ = None;
                let mut event_type__ = None;
                let mut contents__ = None;
                let mut json__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PackageId => {
                            if package_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("packageId"));
                            }
                            package_id__ = map_.next_value()?;
                        }
                        GeneratedField::Module => {
                            if module__.is_some() {
                                return Err(serde::de::Error::duplicate_field("module"));
                            }
                            module__ = map_.next_value()?;
                        }
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = map_.next_value()?;
                        }
                        GeneratedField::EventType => {
                            if event_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("eventType"));
                            }
                            event_type__ = map_.next_value()?;
                        }
                        GeneratedField::Contents => {
                            if contents__.is_some() {
                                return Err(serde::de::Error::duplicate_field("contents"));
                            }
                            contents__ = map_.next_value()?;
                        }
                        GeneratedField::Json => {
                            if json__.is_some() {
                                return Err(serde::de::Error::duplicate_field("json"));
                            }
                            json__ = map_.next_value::<::std::option::Option<crate::_serde::ValueDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Event {
                    package_id: package_id__,
                    module: module__,
                    sender: sender__,
                    event_type: event_type__,
                    contents: contents__,
                    json: json__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.Event", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ExecuteTransactionRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.transaction.is_some() {
            len += 1;
        }
        if !self.signatures.is_empty() {
            len += 1;
        }
        if self.read_mask.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ExecuteTransactionRequest", len)?;
        if let Some(v) = self.transaction.as_ref() {
            struct_ser.serialize_field("transaction", v)?;
        }
        if !self.signatures.is_empty() {
            struct_ser.serialize_field("signatures", &self.signatures)?;
        }
        if let Some(v) = self.read_mask.as_ref() {
            struct_ser.serialize_field("readMask", &crate::_serde::FieldMaskSerializer(v))?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExecuteTransactionRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "transaction",
            "signatures",
            "read_mask",
            "readMask",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Transaction,
            Signatures,
            ReadMask,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "transaction" => Ok(GeneratedField::Transaction),
                            "signatures" => Ok(GeneratedField::Signatures),
                            "readMask" | "read_mask" => Ok(GeneratedField::ReadMask),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExecuteTransactionRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ExecuteTransactionRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ExecuteTransactionRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut transaction__ = None;
                let mut signatures__ = None;
                let mut read_mask__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Transaction => {
                            if transaction__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transaction"));
                            }
                            transaction__ = map_.next_value()?;
                        }
                        GeneratedField::Signatures => {
                            if signatures__.is_some() {
                                return Err(serde::de::Error::duplicate_field("signatures"));
                            }
                            signatures__ = Some(map_.next_value()?);
                        }
                        GeneratedField::ReadMask => {
                            if read_mask__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readMask"));
                            }
                            read_mask__ = map_.next_value::<::std::option::Option<crate::_serde::FieldMaskDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ExecuteTransactionRequest {
                    transaction: transaction__,
                    signatures: signatures__.unwrap_or_default(),
                    read_mask: read_mask__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ExecuteTransactionRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ExecuteTransactionResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.finality.is_some() {
            len += 1;
        }
        if self.transaction.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ExecuteTransactionResponse", len)?;
        if let Some(v) = self.finality.as_ref() {
            struct_ser.serialize_field("finality", v)?;
        }
        if let Some(v) = self.transaction.as_ref() {
            struct_ser.serialize_field("transaction", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExecuteTransactionResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "finality",
            "transaction",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Finality,
            Transaction,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "finality" => Ok(GeneratedField::Finality),
                            "transaction" => Ok(GeneratedField::Transaction),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExecuteTransactionResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ExecuteTransactionResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ExecuteTransactionResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut finality__ = None;
                let mut transaction__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Finality => {
                            if finality__.is_some() {
                                return Err(serde::de::Error::duplicate_field("finality"));
                            }
                            finality__ = map_.next_value()?;
                        }
                        GeneratedField::Transaction => {
                            if transaction__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transaction"));
                            }
                            transaction__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ExecuteTransactionResponse {
                    finality: finality__,
                    transaction: transaction__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ExecuteTransactionResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ExecutedTransaction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.digest.is_some() {
            len += 1;
        }
        if self.transaction.is_some() {
            len += 1;
        }
        if !self.signatures.is_empty() {
            len += 1;
        }
        if self.effects.is_some() {
            len += 1;
        }
        if self.events.is_some() {
            len += 1;
        }
        if self.checkpoint.is_some() {
            len += 1;
        }
        if self.timestamp.is_some() {
            len += 1;
        }
        if !self.balance_changes.is_empty() {
            len += 1;
        }
        if !self.input_objects.is_empty() {
            len += 1;
        }
        if !self.output_objects.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ExecutedTransaction", len)?;
        if let Some(v) = self.digest.as_ref() {
            struct_ser.serialize_field("digest", v)?;
        }
        if let Some(v) = self.transaction.as_ref() {
            struct_ser.serialize_field("transaction", v)?;
        }
        if !self.signatures.is_empty() {
            struct_ser.serialize_field("signatures", &self.signatures)?;
        }
        if let Some(v) = self.effects.as_ref() {
            struct_ser.serialize_field("effects", v)?;
        }
        if let Some(v) = self.events.as_ref() {
            struct_ser.serialize_field("events", v)?;
        }
        if let Some(v) = self.checkpoint.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("checkpoint", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.timestamp.as_ref() {
            struct_ser.serialize_field("timestamp", &crate::_serde::TimestampSerializer(v))?;
        }
        if !self.balance_changes.is_empty() {
            struct_ser.serialize_field("balanceChanges", &self.balance_changes)?;
        }
        if !self.input_objects.is_empty() {
            struct_ser.serialize_field("inputObjects", &self.input_objects)?;
        }
        if !self.output_objects.is_empty() {
            struct_ser.serialize_field("outputObjects", &self.output_objects)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExecutedTransaction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "digest",
            "transaction",
            "signatures",
            "effects",
            "events",
            "checkpoint",
            "timestamp",
            "balance_changes",
            "balanceChanges",
            "input_objects",
            "inputObjects",
            "output_objects",
            "outputObjects",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Digest,
            Transaction,
            Signatures,
            Effects,
            Events,
            Checkpoint,
            Timestamp,
            BalanceChanges,
            InputObjects,
            OutputObjects,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "digest" => Ok(GeneratedField::Digest),
                            "transaction" => Ok(GeneratedField::Transaction),
                            "signatures" => Ok(GeneratedField::Signatures),
                            "effects" => Ok(GeneratedField::Effects),
                            "events" => Ok(GeneratedField::Events),
                            "checkpoint" => Ok(GeneratedField::Checkpoint),
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "balanceChanges" | "balance_changes" => Ok(GeneratedField::BalanceChanges),
                            "inputObjects" | "input_objects" => Ok(GeneratedField::InputObjects),
                            "outputObjects" | "output_objects" => Ok(GeneratedField::OutputObjects),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExecutedTransaction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ExecutedTransaction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ExecutedTransaction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut digest__ = None;
                let mut transaction__ = None;
                let mut signatures__ = None;
                let mut effects__ = None;
                let mut events__ = None;
                let mut checkpoint__ = None;
                let mut timestamp__ = None;
                let mut balance_changes__ = None;
                let mut input_objects__ = None;
                let mut output_objects__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Digest => {
                            if digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("digest"));
                            }
                            digest__ = map_.next_value()?;
                        }
                        GeneratedField::Transaction => {
                            if transaction__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transaction"));
                            }
                            transaction__ = map_.next_value()?;
                        }
                        GeneratedField::Signatures => {
                            if signatures__.is_some() {
                                return Err(serde::de::Error::duplicate_field("signatures"));
                            }
                            signatures__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Effects => {
                            if effects__.is_some() {
                                return Err(serde::de::Error::duplicate_field("effects"));
                            }
                            effects__ = map_.next_value()?;
                        }
                        GeneratedField::Events => {
                            if events__.is_some() {
                                return Err(serde::de::Error::duplicate_field("events"));
                            }
                            events__ = map_.next_value()?;
                        }
                        GeneratedField::Checkpoint => {
                            if checkpoint__.is_some() {
                                return Err(serde::de::Error::duplicate_field("checkpoint"));
                            }
                            checkpoint__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = map_.next_value::<::std::option::Option<crate::_serde::TimestampDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::BalanceChanges => {
                            if balance_changes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("balanceChanges"));
                            }
                            balance_changes__ = Some(map_.next_value()?);
                        }
                        GeneratedField::InputObjects => {
                            if input_objects__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inputObjects"));
                            }
                            input_objects__ = Some(map_.next_value()?);
                        }
                        GeneratedField::OutputObjects => {
                            if output_objects__.is_some() {
                                return Err(serde::de::Error::duplicate_field("outputObjects"));
                            }
                            output_objects__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ExecutedTransaction {
                    digest: digest__,
                    transaction: transaction__,
                    signatures: signatures__.unwrap_or_default(),
                    effects: effects__,
                    events: events__,
                    checkpoint: checkpoint__,
                    timestamp: timestamp__,
                    balance_changes: balance_changes__.unwrap_or_default(),
                    input_objects: input_objects__.unwrap_or_default(),
                    output_objects: output_objects__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ExecutedTransaction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ExecutionError {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.description.is_some() {
            len += 1;
        }
        if self.command.is_some() {
            len += 1;
        }
        if self.kind.is_some() {
            len += 1;
        }
        if self.error_details.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ExecutionError", len)?;
        if let Some(v) = self.description.as_ref() {
            struct_ser.serialize_field("description", v)?;
        }
        if let Some(v) = self.command.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("command", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.kind.as_ref() {
            let v = execution_error::ExecutionErrorKind::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if let Some(v) = self.error_details.as_ref() {
            match v {
                execution_error::ErrorDetails::Abort(v) => {
                    struct_ser.serialize_field("abort", v)?;
                }
                execution_error::ErrorDetails::SizeError(v) => {
                    struct_ser.serialize_field("sizeError", v)?;
                }
                execution_error::ErrorDetails::CommandArgumentError(v) => {
                    struct_ser.serialize_field("commandArgumentError", v)?;
                }
                execution_error::ErrorDetails::TypeArgumentError(v) => {
                    struct_ser.serialize_field("typeArgumentError", v)?;
                }
                execution_error::ErrorDetails::PackageUpgradeError(v) => {
                    struct_ser.serialize_field("packageUpgradeError", v)?;
                }
                execution_error::ErrorDetails::IndexError(v) => {
                    struct_ser.serialize_field("indexError", v)?;
                }
                execution_error::ErrorDetails::ObjectId(v) => {
                    struct_ser.serialize_field("objectId", v)?;
                }
                execution_error::ErrorDetails::CoinDenyListError(v) => {
                    struct_ser.serialize_field("coinDenyListError", v)?;
                }
                execution_error::ErrorDetails::CongestedObjects(v) => {
                    struct_ser.serialize_field("congestedObjects", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExecutionError {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "description",
            "command",
            "kind",
            "abort",
            "size_error",
            "sizeError",
            "command_argument_error",
            "commandArgumentError",
            "type_argument_error",
            "typeArgumentError",
            "package_upgrade_error",
            "packageUpgradeError",
            "index_error",
            "indexError",
            "object_id",
            "objectId",
            "coin_deny_list_error",
            "coinDenyListError",
            "congested_objects",
            "congestedObjects",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Description,
            Command,
            Kind,
            Abort,
            SizeError,
            CommandArgumentError,
            TypeArgumentError,
            PackageUpgradeError,
            IndexError,
            ObjectId,
            CoinDenyListError,
            CongestedObjects,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "description" => Ok(GeneratedField::Description),
                            "command" => Ok(GeneratedField::Command),
                            "kind" => Ok(GeneratedField::Kind),
                            "abort" => Ok(GeneratedField::Abort),
                            "sizeError" | "size_error" => Ok(GeneratedField::SizeError),
                            "commandArgumentError" | "command_argument_error" => Ok(GeneratedField::CommandArgumentError),
                            "typeArgumentError" | "type_argument_error" => Ok(GeneratedField::TypeArgumentError),
                            "packageUpgradeError" | "package_upgrade_error" => Ok(GeneratedField::PackageUpgradeError),
                            "indexError" | "index_error" => Ok(GeneratedField::IndexError),
                            "objectId" | "object_id" => Ok(GeneratedField::ObjectId),
                            "coinDenyListError" | "coin_deny_list_error" => Ok(GeneratedField::CoinDenyListError),
                            "congestedObjects" | "congested_objects" => Ok(GeneratedField::CongestedObjects),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExecutionError;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ExecutionError")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ExecutionError, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut description__ = None;
                let mut command__ = None;
                let mut kind__ = None;
                let mut error_details__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = map_.next_value()?;
                        }
                        GeneratedField::Command => {
                            if command__.is_some() {
                                return Err(serde::de::Error::duplicate_field("command"));
                            }
                            command__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<execution_error::ExecutionErrorKind>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Abort => {
                            if error_details__.is_some() {
                                return Err(serde::de::Error::duplicate_field("abort"));
                            }
                            error_details__ = map_.next_value::<::std::option::Option<_>>()?.map(execution_error::ErrorDetails::Abort)
;
                        }
                        GeneratedField::SizeError => {
                            if error_details__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sizeError"));
                            }
                            error_details__ = map_.next_value::<::std::option::Option<_>>()?.map(execution_error::ErrorDetails::SizeError)
;
                        }
                        GeneratedField::CommandArgumentError => {
                            if error_details__.is_some() {
                                return Err(serde::de::Error::duplicate_field("commandArgumentError"));
                            }
                            error_details__ = map_.next_value::<::std::option::Option<_>>()?.map(execution_error::ErrorDetails::CommandArgumentError)
;
                        }
                        GeneratedField::TypeArgumentError => {
                            if error_details__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeArgumentError"));
                            }
                            error_details__ = map_.next_value::<::std::option::Option<_>>()?.map(execution_error::ErrorDetails::TypeArgumentError)
;
                        }
                        GeneratedField::PackageUpgradeError => {
                            if error_details__.is_some() {
                                return Err(serde::de::Error::duplicate_field("packageUpgradeError"));
                            }
                            error_details__ = map_.next_value::<::std::option::Option<_>>()?.map(execution_error::ErrorDetails::PackageUpgradeError)
;
                        }
                        GeneratedField::IndexError => {
                            if error_details__.is_some() {
                                return Err(serde::de::Error::duplicate_field("indexError"));
                            }
                            error_details__ = map_.next_value::<::std::option::Option<_>>()?.map(execution_error::ErrorDetails::IndexError)
;
                        }
                        GeneratedField::ObjectId => {
                            if error_details__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objectId"));
                            }
                            error_details__ = map_.next_value::<::std::option::Option<_>>()?.map(execution_error::ErrorDetails::ObjectId);
                        }
                        GeneratedField::CoinDenyListError => {
                            if error_details__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coinDenyListError"));
                            }
                            error_details__ = map_.next_value::<::std::option::Option<_>>()?.map(execution_error::ErrorDetails::CoinDenyListError)
;
                        }
                        GeneratedField::CongestedObjects => {
                            if error_details__.is_some() {
                                return Err(serde::de::Error::duplicate_field("congestedObjects"));
                            }
                            error_details__ = map_.next_value::<::std::option::Option<_>>()?.map(execution_error::ErrorDetails::CongestedObjects)
;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ExecutionError {
                    description: description__,
                    command: command__,
                    kind: kind__,
                    error_details: error_details__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ExecutionError", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for execution_error::ExecutionErrorKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "EXECUTION_ERROR_KIND_UNKNOWN",
            Self::InsufficientGas => "INSUFFICIENT_GAS",
            Self::InvalidGasObject => "INVALID_GAS_OBJECT",
            Self::InvariantViolation => "INVARIANT_VIOLATION",
            Self::FeatureNotYetSupported => "FEATURE_NOT_YET_SUPPORTED",
            Self::ObjectTooBig => "OBJECT_TOO_BIG",
            Self::PackageTooBig => "PACKAGE_TOO_BIG",
            Self::CircularObjectOwnership => "CIRCULAR_OBJECT_OWNERSHIP",
            Self::InsufficientCoinBalance => "INSUFFICIENT_COIN_BALANCE",
            Self::CoinBalanceOverflow => "COIN_BALANCE_OVERFLOW",
            Self::PublishErrorNonZeroAddress => "PUBLISH_ERROR_NON_ZERO_ADDRESS",
            Self::SuiMoveVerificationError => "SUI_MOVE_VERIFICATION_ERROR",
            Self::MovePrimitiveRuntimeError => "MOVE_PRIMITIVE_RUNTIME_ERROR",
            Self::MoveAbort => "MOVE_ABORT",
            Self::VmVerificationOrDeserializationError => "VM_VERIFICATION_OR_DESERIALIZATION_ERROR",
            Self::VmInvariantViolation => "VM_INVARIANT_VIOLATION",
            Self::FunctionNotFound => "FUNCTION_NOT_FOUND",
            Self::ArityMismatch => "ARITY_MISMATCH",
            Self::TypeArityMismatch => "TYPE_ARITY_MISMATCH",
            Self::NonEntryFunctionInvoked => "NON_ENTRY_FUNCTION_INVOKED",
            Self::CommandArgumentError => "COMMAND_ARGUMENT_ERROR",
            Self::TypeArgumentError => "TYPE_ARGUMENT_ERROR",
            Self::UnusedValueWithoutDrop => "UNUSED_VALUE_WITHOUT_DROP",
            Self::InvalidPublicFunctionReturnType => "INVALID_PUBLIC_FUNCTION_RETURN_TYPE",
            Self::InvalidTransferObject => "INVALID_TRANSFER_OBJECT",
            Self::EffectsTooLarge => "EFFECTS_TOO_LARGE",
            Self::PublishUpgradeMissingDependency => "PUBLISH_UPGRADE_MISSING_DEPENDENCY",
            Self::PublishUpgradeDependencyDowngrade => "PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE",
            Self::PackageUpgradeError => "PACKAGE_UPGRADE_ERROR",
            Self::WrittenObjectsTooLarge => "WRITTEN_OBJECTS_TOO_LARGE",
            Self::CertificateDenied => "CERTIFICATE_DENIED",
            Self::SuiMoveVerificationTimedout => "SUI_MOVE_VERIFICATION_TIMEDOUT",
            Self::ConsensusObjectOperationNotAllowed => "CONSENSUS_OBJECT_OPERATION_NOT_ALLOWED",
            Self::InputObjectDeleted => "INPUT_OBJECT_DELETED",
            Self::ExecutionCanceledDueToConsensusObjectCongestion => "EXECUTION_CANCELED_DUE_TO_CONSENSUS_OBJECT_CONGESTION",
            Self::AddressDeniedForCoin => "ADDRESS_DENIED_FOR_COIN",
            Self::CoinTypeGlobalPause => "COIN_TYPE_GLOBAL_PAUSE",
            Self::ExecutionCanceledDueToRandomnessUnavailable => "EXECUTION_CANCELED_DUE_TO_RANDOMNESS_UNAVAILABLE",
            Self::MoveVectorElemTooBig => "MOVE_VECTOR_ELEM_TOO_BIG",
            Self::MoveRawValueTooBig => "MOVE_RAW_VALUE_TOO_BIG",
            Self::InvalidLinkage => "INVALID_LINKAGE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for execution_error::ExecutionErrorKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EXECUTION_ERROR_KIND_UNKNOWN",
            "INSUFFICIENT_GAS",
            "INVALID_GAS_OBJECT",
            "INVARIANT_VIOLATION",
            "FEATURE_NOT_YET_SUPPORTED",
            "OBJECT_TOO_BIG",
            "PACKAGE_TOO_BIG",
            "CIRCULAR_OBJECT_OWNERSHIP",
            "INSUFFICIENT_COIN_BALANCE",
            "COIN_BALANCE_OVERFLOW",
            "PUBLISH_ERROR_NON_ZERO_ADDRESS",
            "SUI_MOVE_VERIFICATION_ERROR",
            "MOVE_PRIMITIVE_RUNTIME_ERROR",
            "MOVE_ABORT",
            "VM_VERIFICATION_OR_DESERIALIZATION_ERROR",
            "VM_INVARIANT_VIOLATION",
            "FUNCTION_NOT_FOUND",
            "ARITY_MISMATCH",
            "TYPE_ARITY_MISMATCH",
            "NON_ENTRY_FUNCTION_INVOKED",
            "COMMAND_ARGUMENT_ERROR",
            "TYPE_ARGUMENT_ERROR",
            "UNUSED_VALUE_WITHOUT_DROP",
            "INVALID_PUBLIC_FUNCTION_RETURN_TYPE",
            "INVALID_TRANSFER_OBJECT",
            "EFFECTS_TOO_LARGE",
            "PUBLISH_UPGRADE_MISSING_DEPENDENCY",
            "PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE",
            "PACKAGE_UPGRADE_ERROR",
            "WRITTEN_OBJECTS_TOO_LARGE",
            "CERTIFICATE_DENIED",
            "SUI_MOVE_VERIFICATION_TIMEDOUT",
            "CONSENSUS_OBJECT_OPERATION_NOT_ALLOWED",
            "INPUT_OBJECT_DELETED",
            "EXECUTION_CANCELED_DUE_TO_CONSENSUS_OBJECT_CONGESTION",
            "ADDRESS_DENIED_FOR_COIN",
            "COIN_TYPE_GLOBAL_PAUSE",
            "EXECUTION_CANCELED_DUE_TO_RANDOMNESS_UNAVAILABLE",
            "MOVE_VECTOR_ELEM_TOO_BIG",
            "MOVE_RAW_VALUE_TOO_BIG",
            "INVALID_LINKAGE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = execution_error::ExecutionErrorKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "EXECUTION_ERROR_KIND_UNKNOWN" => Ok(execution_error::ExecutionErrorKind::Unknown),
                    "INSUFFICIENT_GAS" => Ok(execution_error::ExecutionErrorKind::InsufficientGas),
                    "INVALID_GAS_OBJECT" => Ok(execution_error::ExecutionErrorKind::InvalidGasObject),
                    "INVARIANT_VIOLATION" => Ok(execution_error::ExecutionErrorKind::InvariantViolation),
                    "FEATURE_NOT_YET_SUPPORTED" => Ok(execution_error::ExecutionErrorKind::FeatureNotYetSupported),
                    "OBJECT_TOO_BIG" => Ok(execution_error::ExecutionErrorKind::ObjectTooBig),
                    "PACKAGE_TOO_BIG" => Ok(execution_error::ExecutionErrorKind::PackageTooBig),
                    "CIRCULAR_OBJECT_OWNERSHIP" => Ok(execution_error::ExecutionErrorKind::CircularObjectOwnership),
                    "INSUFFICIENT_COIN_BALANCE" => Ok(execution_error::ExecutionErrorKind::InsufficientCoinBalance),
                    "COIN_BALANCE_OVERFLOW" => Ok(execution_error::ExecutionErrorKind::CoinBalanceOverflow),
                    "PUBLISH_ERROR_NON_ZERO_ADDRESS" => Ok(execution_error::ExecutionErrorKind::PublishErrorNonZeroAddress),
                    "SUI_MOVE_VERIFICATION_ERROR" => Ok(execution_error::ExecutionErrorKind::SuiMoveVerificationError),
                    "MOVE_PRIMITIVE_RUNTIME_ERROR" => Ok(execution_error::ExecutionErrorKind::MovePrimitiveRuntimeError),
                    "MOVE_ABORT" => Ok(execution_error::ExecutionErrorKind::MoveAbort),
                    "VM_VERIFICATION_OR_DESERIALIZATION_ERROR" => Ok(execution_error::ExecutionErrorKind::VmVerificationOrDeserializationError),
                    "VM_INVARIANT_VIOLATION" => Ok(execution_error::ExecutionErrorKind::VmInvariantViolation),
                    "FUNCTION_NOT_FOUND" => Ok(execution_error::ExecutionErrorKind::FunctionNotFound),
                    "ARITY_MISMATCH" => Ok(execution_error::ExecutionErrorKind::ArityMismatch),
                    "TYPE_ARITY_MISMATCH" => Ok(execution_error::ExecutionErrorKind::TypeArityMismatch),
                    "NON_ENTRY_FUNCTION_INVOKED" => Ok(execution_error::ExecutionErrorKind::NonEntryFunctionInvoked),
                    "COMMAND_ARGUMENT_ERROR" => Ok(execution_error::ExecutionErrorKind::CommandArgumentError),
                    "TYPE_ARGUMENT_ERROR" => Ok(execution_error::ExecutionErrorKind::TypeArgumentError),
                    "UNUSED_VALUE_WITHOUT_DROP" => Ok(execution_error::ExecutionErrorKind::UnusedValueWithoutDrop),
                    "INVALID_PUBLIC_FUNCTION_RETURN_TYPE" => Ok(execution_error::ExecutionErrorKind::InvalidPublicFunctionReturnType),
                    "INVALID_TRANSFER_OBJECT" => Ok(execution_error::ExecutionErrorKind::InvalidTransferObject),
                    "EFFECTS_TOO_LARGE" => Ok(execution_error::ExecutionErrorKind::EffectsTooLarge),
                    "PUBLISH_UPGRADE_MISSING_DEPENDENCY" => Ok(execution_error::ExecutionErrorKind::PublishUpgradeMissingDependency),
                    "PUBLISH_UPGRADE_DEPENDENCY_DOWNGRADE" => Ok(execution_error::ExecutionErrorKind::PublishUpgradeDependencyDowngrade),
                    "PACKAGE_UPGRADE_ERROR" => Ok(execution_error::ExecutionErrorKind::PackageUpgradeError),
                    "WRITTEN_OBJECTS_TOO_LARGE" => Ok(execution_error::ExecutionErrorKind::WrittenObjectsTooLarge),
                    "CERTIFICATE_DENIED" => Ok(execution_error::ExecutionErrorKind::CertificateDenied),
                    "SUI_MOVE_VERIFICATION_TIMEDOUT" => Ok(execution_error::ExecutionErrorKind::SuiMoveVerificationTimedout),
                    "CONSENSUS_OBJECT_OPERATION_NOT_ALLOWED" => Ok(execution_error::ExecutionErrorKind::ConsensusObjectOperationNotAllowed),
                    "INPUT_OBJECT_DELETED" => Ok(execution_error::ExecutionErrorKind::InputObjectDeleted),
                    "EXECUTION_CANCELED_DUE_TO_CONSENSUS_OBJECT_CONGESTION" => Ok(execution_error::ExecutionErrorKind::ExecutionCanceledDueToConsensusObjectCongestion),
                    "ADDRESS_DENIED_FOR_COIN" => Ok(execution_error::ExecutionErrorKind::AddressDeniedForCoin),
                    "COIN_TYPE_GLOBAL_PAUSE" => Ok(execution_error::ExecutionErrorKind::CoinTypeGlobalPause),
                    "EXECUTION_CANCELED_DUE_TO_RANDOMNESS_UNAVAILABLE" => Ok(execution_error::ExecutionErrorKind::ExecutionCanceledDueToRandomnessUnavailable),
                    "MOVE_VECTOR_ELEM_TOO_BIG" => Ok(execution_error::ExecutionErrorKind::MoveVectorElemTooBig),
                    "MOVE_RAW_VALUE_TOO_BIG" => Ok(execution_error::ExecutionErrorKind::MoveRawValueTooBig),
                    "INVALID_LINKAGE" => Ok(execution_error::ExecutionErrorKind::InvalidLinkage),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ExecutionStatus {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.success.is_some() {
            len += 1;
        }
        if self.error.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ExecutionStatus", len)?;
        if let Some(v) = self.success.as_ref() {
            struct_ser.serialize_field("success", v)?;
        }
        if let Some(v) = self.error.as_ref() {
            struct_ser.serialize_field("error", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExecutionStatus {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "success",
            "error",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Success,
            Error,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "success" => Ok(GeneratedField::Success),
                            "error" => Ok(GeneratedField::Error),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExecutionStatus;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ExecutionStatus")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ExecutionStatus, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut success__ = None;
                let mut error__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Success => {
                            if success__.is_some() {
                                return Err(serde::de::Error::duplicate_field("success"));
                            }
                            success__ = map_.next_value()?;
                        }
                        GeneratedField::Error => {
                            if error__.is_some() {
                                return Err(serde::de::Error::duplicate_field("error"));
                            }
                            error__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ExecutionStatus {
                    success: success__,
                    error: error__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ExecutionStatus", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ExecutionTimeObservation {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind.is_some() {
            len += 1;
        }
        if self.move_entry_point.is_some() {
            len += 1;
        }
        if !self.validator_observations.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ExecutionTimeObservation", len)?;
        if let Some(v) = self.kind.as_ref() {
            let v = execution_time_observation::ExecutionTimeObservationKind::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if let Some(v) = self.move_entry_point.as_ref() {
            struct_ser.serialize_field("moveEntryPoint", v)?;
        }
        if !self.validator_observations.is_empty() {
            struct_ser.serialize_field("validatorObservations", &self.validator_observations)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExecutionTimeObservation {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kind",
            "move_entry_point",
            "moveEntryPoint",
            "validator_observations",
            "validatorObservations",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Kind,
            MoveEntryPoint,
            ValidatorObservations,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kind" => Ok(GeneratedField::Kind),
                            "moveEntryPoint" | "move_entry_point" => Ok(GeneratedField::MoveEntryPoint),
                            "validatorObservations" | "validator_observations" => Ok(GeneratedField::ValidatorObservations),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExecutionTimeObservation;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ExecutionTimeObservation")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ExecutionTimeObservation, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                let mut move_entry_point__ = None;
                let mut validator_observations__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<execution_time_observation::ExecutionTimeObservationKind>>()?.map(|x| x as i32);
                        }
                        GeneratedField::MoveEntryPoint => {
                            if move_entry_point__.is_some() {
                                return Err(serde::de::Error::duplicate_field("moveEntryPoint"));
                            }
                            move_entry_point__ = map_.next_value()?;
                        }
                        GeneratedField::ValidatorObservations => {
                            if validator_observations__.is_some() {
                                return Err(serde::de::Error::duplicate_field("validatorObservations"));
                            }
                            validator_observations__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ExecutionTimeObservation {
                    kind: kind__,
                    move_entry_point: move_entry_point__,
                    validator_observations: validator_observations__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ExecutionTimeObservation", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for execution_time_observation::ExecutionTimeObservationKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "EXECUTION_TIME_OBSERVATION_KIND_UNKNOWN",
            Self::MoveEntryPoint => "MOVE_ENTRY_POINT",
            Self::TransferObjects => "TRANSFER_OBJECTS",
            Self::SplitCoins => "SPLIT_COINS",
            Self::MergeCoins => "MERGE_COINS",
            Self::Publish => "PUBLISH",
            Self::MakeMoveVector => "MAKE_MOVE_VECTOR",
            Self::Upgrade => "UPGRADE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for execution_time_observation::ExecutionTimeObservationKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "EXECUTION_TIME_OBSERVATION_KIND_UNKNOWN",
            "MOVE_ENTRY_POINT",
            "TRANSFER_OBJECTS",
            "SPLIT_COINS",
            "MERGE_COINS",
            "PUBLISH",
            "MAKE_MOVE_VECTOR",
            "UPGRADE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = execution_time_observation::ExecutionTimeObservationKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "EXECUTION_TIME_OBSERVATION_KIND_UNKNOWN" => Ok(execution_time_observation::ExecutionTimeObservationKind::Unknown),
                    "MOVE_ENTRY_POINT" => Ok(execution_time_observation::ExecutionTimeObservationKind::MoveEntryPoint),
                    "TRANSFER_OBJECTS" => Ok(execution_time_observation::ExecutionTimeObservationKind::TransferObjects),
                    "SPLIT_COINS" => Ok(execution_time_observation::ExecutionTimeObservationKind::SplitCoins),
                    "MERGE_COINS" => Ok(execution_time_observation::ExecutionTimeObservationKind::MergeCoins),
                    "PUBLISH" => Ok(execution_time_observation::ExecutionTimeObservationKind::Publish),
                    "MAKE_MOVE_VECTOR" => Ok(execution_time_observation::ExecutionTimeObservationKind::MakeMoveVector),
                    "UPGRADE" => Ok(execution_time_observation::ExecutionTimeObservationKind::Upgrade),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ExecutionTimeObservations {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.version.is_some() {
            len += 1;
        }
        if !self.observations.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ExecutionTimeObservations", len)?;
        if let Some(v) = self.version.as_ref() {
            struct_ser.serialize_field("version", v)?;
        }
        if !self.observations.is_empty() {
            struct_ser.serialize_field("observations", &self.observations)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ExecutionTimeObservations {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "version",
            "observations",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Version,
            Observations,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "version" => Ok(GeneratedField::Version),
                            "observations" => Ok(GeneratedField::Observations),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ExecutionTimeObservations;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ExecutionTimeObservations")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ExecutionTimeObservations, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut version__ = None;
                let mut observations__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Observations => {
                            if observations__.is_some() {
                                return Err(serde::de::Error::duplicate_field("observations"));
                            }
                            observations__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ExecutionTimeObservations {
                    version: version__,
                    observations: observations__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ExecutionTimeObservations", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FieldDescriptor {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.position.is_some() {
            len += 1;
        }
        if self.r#type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.FieldDescriptor", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.position.as_ref() {
            struct_ser.serialize_field("position", v)?;
        }
        if let Some(v) = self.r#type.as_ref() {
            struct_ser.serialize_field("type", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FieldDescriptor {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "position",
            "type",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Position,
            Type,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "position" => Ok(GeneratedField::Position),
                            "type" => Ok(GeneratedField::Type),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FieldDescriptor;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.FieldDescriptor")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FieldDescriptor, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut position__ = None;
                let mut r#type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map_.next_value()?;
                        }
                        GeneratedField::Position => {
                            if position__.is_some() {
                                return Err(serde::de::Error::duplicate_field("position"));
                            }
                            position__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(FieldDescriptor {
                    name: name__,
                    position: position__,
                    r#type: r#type__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.FieldDescriptor", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for FunctionDescriptor {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.visibility.is_some() {
            len += 1;
        }
        if self.is_entry.is_some() {
            len += 1;
        }
        if !self.type_parameters.is_empty() {
            len += 1;
        }
        if !self.parameters.is_empty() {
            len += 1;
        }
        if !self.returns.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.FunctionDescriptor", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.visibility.as_ref() {
            let v = function_descriptor::Visibility::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("visibility", &v)?;
        }
        if let Some(v) = self.is_entry.as_ref() {
            struct_ser.serialize_field("isEntry", v)?;
        }
        if !self.type_parameters.is_empty() {
            struct_ser.serialize_field("typeParameters", &self.type_parameters)?;
        }
        if !self.parameters.is_empty() {
            struct_ser.serialize_field("parameters", &self.parameters)?;
        }
        if !self.returns.is_empty() {
            struct_ser.serialize_field("returns", &self.returns)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for FunctionDescriptor {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "visibility",
            "is_entry",
            "isEntry",
            "type_parameters",
            "typeParameters",
            "parameters",
            "returns",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Visibility,
            IsEntry,
            TypeParameters,
            Parameters,
            Returns,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "visibility" => Ok(GeneratedField::Visibility),
                            "isEntry" | "is_entry" => Ok(GeneratedField::IsEntry),
                            "typeParameters" | "type_parameters" => Ok(GeneratedField::TypeParameters),
                            "parameters" => Ok(GeneratedField::Parameters),
                            "returns" => Ok(GeneratedField::Returns),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = FunctionDescriptor;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.FunctionDescriptor")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<FunctionDescriptor, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut visibility__ = None;
                let mut is_entry__ = None;
                let mut type_parameters__ = None;
                let mut parameters__ = None;
                let mut returns__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map_.next_value()?;
                        }
                        GeneratedField::Visibility => {
                            if visibility__.is_some() {
                                return Err(serde::de::Error::duplicate_field("visibility"));
                            }
                            visibility__ = map_.next_value::<::std::option::Option<function_descriptor::Visibility>>()?.map(|x| x as i32);
                        }
                        GeneratedField::IsEntry => {
                            if is_entry__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isEntry"));
                            }
                            is_entry__ = map_.next_value()?;
                        }
                        GeneratedField::TypeParameters => {
                            if type_parameters__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeParameters"));
                            }
                            type_parameters__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Parameters => {
                            if parameters__.is_some() {
                                return Err(serde::de::Error::duplicate_field("parameters"));
                            }
                            parameters__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Returns => {
                            if returns__.is_some() {
                                return Err(serde::de::Error::duplicate_field("returns"));
                            }
                            returns__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(FunctionDescriptor {
                    name: name__,
                    visibility: visibility__,
                    is_entry: is_entry__,
                    type_parameters: type_parameters__.unwrap_or_default(),
                    parameters: parameters__.unwrap_or_default(),
                    returns: returns__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.FunctionDescriptor", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for function_descriptor::Visibility {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "VISIBILITY_UNKNOWN",
            Self::Private => "PRIVATE",
            Self::Public => "PUBLIC",
            Self::Friend => "FRIEND",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for function_descriptor::Visibility {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "VISIBILITY_UNKNOWN",
            "PRIVATE",
            "PUBLIC",
            "FRIEND",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = function_descriptor::Visibility;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "VISIBILITY_UNKNOWN" => Ok(function_descriptor::Visibility::Unknown),
                    "PRIVATE" => Ok(function_descriptor::Visibility::Private),
                    "PUBLIC" => Ok(function_descriptor::Visibility::Public),
                    "FRIEND" => Ok(function_descriptor::Visibility::Friend),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for GasCostSummary {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.computation_cost.is_some() {
            len += 1;
        }
        if self.storage_cost.is_some() {
            len += 1;
        }
        if self.storage_rebate.is_some() {
            len += 1;
        }
        if self.non_refundable_storage_fee.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GasCostSummary", len)?;
        if let Some(v) = self.computation_cost.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("computationCost", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.storage_cost.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("storageCost", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.storage_rebate.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("storageRebate", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.non_refundable_storage_fee.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("nonRefundableStorageFee", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GasCostSummary {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "computation_cost",
            "computationCost",
            "storage_cost",
            "storageCost",
            "storage_rebate",
            "storageRebate",
            "non_refundable_storage_fee",
            "nonRefundableStorageFee",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ComputationCost,
            StorageCost,
            StorageRebate,
            NonRefundableStorageFee,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "computationCost" | "computation_cost" => Ok(GeneratedField::ComputationCost),
                            "storageCost" | "storage_cost" => Ok(GeneratedField::StorageCost),
                            "storageRebate" | "storage_rebate" => Ok(GeneratedField::StorageRebate),
                            "nonRefundableStorageFee" | "non_refundable_storage_fee" => Ok(GeneratedField::NonRefundableStorageFee),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GasCostSummary;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GasCostSummary")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GasCostSummary, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut computation_cost__ = None;
                let mut storage_cost__ = None;
                let mut storage_rebate__ = None;
                let mut non_refundable_storage_fee__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ComputationCost => {
                            if computation_cost__.is_some() {
                                return Err(serde::de::Error::duplicate_field("computationCost"));
                            }
                            computation_cost__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StorageCost => {
                            if storage_cost__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storageCost"));
                            }
                            storage_cost__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StorageRebate => {
                            if storage_rebate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storageRebate"));
                            }
                            storage_rebate__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NonRefundableStorageFee => {
                            if non_refundable_storage_fee__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nonRefundableStorageFee"));
                            }
                            non_refundable_storage_fee__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GasCostSummary {
                    computation_cost: computation_cost__,
                    storage_cost: storage_cost__,
                    storage_rebate: storage_rebate__,
                    non_refundable_storage_fee: non_refundable_storage_fee__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GasCostSummary", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GasPayment {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.objects.is_empty() {
            len += 1;
        }
        if self.owner.is_some() {
            len += 1;
        }
        if self.price.is_some() {
            len += 1;
        }
        if self.budget.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GasPayment", len)?;
        if !self.objects.is_empty() {
            struct_ser.serialize_field("objects", &self.objects)?;
        }
        if let Some(v) = self.owner.as_ref() {
            struct_ser.serialize_field("owner", v)?;
        }
        if let Some(v) = self.price.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("price", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.budget.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("budget", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GasPayment {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "objects",
            "owner",
            "price",
            "budget",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Objects,
            Owner,
            Price,
            Budget,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "objects" => Ok(GeneratedField::Objects),
                            "owner" => Ok(GeneratedField::Owner),
                            "price" => Ok(GeneratedField::Price),
                            "budget" => Ok(GeneratedField::Budget),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GasPayment;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GasPayment")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GasPayment, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut objects__ = None;
                let mut owner__ = None;
                let mut price__ = None;
                let mut budget__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Objects => {
                            if objects__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objects"));
                            }
                            objects__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Owner => {
                            if owner__.is_some() {
                                return Err(serde::de::Error::duplicate_field("owner"));
                            }
                            owner__ = map_.next_value()?;
                        }
                        GeneratedField::Price => {
                            if price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("price"));
                            }
                            price__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Budget => {
                            if budget__.is_some() {
                                return Err(serde::de::Error::duplicate_field("budget"));
                            }
                            budget__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GasPayment {
                    objects: objects__.unwrap_or_default(),
                    owner: owner__,
                    price: price__,
                    budget: budget__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GasPayment", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GenesisTransaction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.objects.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GenesisTransaction", len)?;
        if !self.objects.is_empty() {
            struct_ser.serialize_field("objects", &self.objects)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GenesisTransaction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "objects",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Objects,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "objects" => Ok(GeneratedField::Objects),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GenesisTransaction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GenesisTransaction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GenesisTransaction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut objects__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Objects => {
                            if objects__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objects"));
                            }
                            objects__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GenesisTransaction {
                    objects: objects__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GenesisTransaction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetBalanceRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.owner.is_some() {
            len += 1;
        }
        if self.coin_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetBalanceRequest", len)?;
        if let Some(v) = self.owner.as_ref() {
            struct_ser.serialize_field("owner", v)?;
        }
        if let Some(v) = self.coin_type.as_ref() {
            struct_ser.serialize_field("coinType", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetBalanceRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "owner",
            "coin_type",
            "coinType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Owner,
            CoinType,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "owner" => Ok(GeneratedField::Owner),
                            "coinType" | "coin_type" => Ok(GeneratedField::CoinType),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetBalanceRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetBalanceRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetBalanceRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut owner__ = None;
                let mut coin_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Owner => {
                            if owner__.is_some() {
                                return Err(serde::de::Error::duplicate_field("owner"));
                            }
                            owner__ = map_.next_value()?;
                        }
                        GeneratedField::CoinType => {
                            if coin_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coinType"));
                            }
                            coin_type__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GetBalanceRequest {
                    owner: owner__,
                    coin_type: coin_type__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetBalanceRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetBalanceResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.balance.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetBalanceResponse", len)?;
        if let Some(v) = self.balance.as_ref() {
            struct_ser.serialize_field("balance", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetBalanceResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "balance",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Balance,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "balance" => Ok(GeneratedField::Balance),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetBalanceResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetBalanceResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetBalanceResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut balance__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Balance => {
                            if balance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("balance"));
                            }
                            balance__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GetBalanceResponse {
                    balance: balance__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetBalanceResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetCheckpointRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.read_mask.is_some() {
            len += 1;
        }
        if self.checkpoint_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetCheckpointRequest", len)?;
        if let Some(v) = self.read_mask.as_ref() {
            struct_ser.serialize_field("readMask", &crate::_serde::FieldMaskSerializer(v))?;
        }
        if let Some(v) = self.checkpoint_id.as_ref() {
            match v {
                get_checkpoint_request::CheckpointId::SequenceNumber(v) => {
                    #[allow(clippy::needless_borrow)]
                    #[allow(clippy::needless_borrows_for_generic_args)]
                    struct_ser.serialize_field("sequenceNumber", ToString::to_string(&v).as_str())?;
                }
                get_checkpoint_request::CheckpointId::Digest(v) => {
                    struct_ser.serialize_field("digest", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetCheckpointRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "read_mask",
            "readMask",
            "sequence_number",
            "sequenceNumber",
            "digest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ReadMask,
            SequenceNumber,
            Digest,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "readMask" | "read_mask" => Ok(GeneratedField::ReadMask),
                            "sequenceNumber" | "sequence_number" => Ok(GeneratedField::SequenceNumber),
                            "digest" => Ok(GeneratedField::Digest),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetCheckpointRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetCheckpointRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetCheckpointRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut read_mask__ = None;
                let mut checkpoint_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ReadMask => {
                            if read_mask__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readMask"));
                            }
                            read_mask__ = map_.next_value::<::std::option::Option<crate::_serde::FieldMaskDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::SequenceNumber => {
                            if checkpoint_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sequenceNumber"));
                            }
                            checkpoint_id__ = map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| get_checkpoint_request::CheckpointId::SequenceNumber(x.0));
                        }
                        GeneratedField::Digest => {
                            if checkpoint_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("digest"));
                            }
                            checkpoint_id__ = map_.next_value::<::std::option::Option<_>>()?.map(get_checkpoint_request::CheckpointId::Digest);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GetCheckpointRequest {
                    read_mask: read_mask__,
                    checkpoint_id: checkpoint_id__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetCheckpointRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetCheckpointResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.checkpoint.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetCheckpointResponse", len)?;
        if let Some(v) = self.checkpoint.as_ref() {
            struct_ser.serialize_field("checkpoint", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetCheckpointResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "checkpoint",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Checkpoint,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "checkpoint" => Ok(GeneratedField::Checkpoint),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetCheckpointResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetCheckpointResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetCheckpointResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut checkpoint__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Checkpoint => {
                            if checkpoint__.is_some() {
                                return Err(serde::de::Error::duplicate_field("checkpoint"));
                            }
                            checkpoint__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GetCheckpointResponse {
                    checkpoint: checkpoint__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetCheckpointResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetCoinInfoRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.coin_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetCoinInfoRequest", len)?;
        if let Some(v) = self.coin_type.as_ref() {
            struct_ser.serialize_field("coinType", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetCoinInfoRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "coin_type",
            "coinType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CoinType,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "coinType" | "coin_type" => Ok(GeneratedField::CoinType),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetCoinInfoRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetCoinInfoRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetCoinInfoRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut coin_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CoinType => {
                            if coin_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coinType"));
                            }
                            coin_type__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GetCoinInfoRequest {
                    coin_type: coin_type__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetCoinInfoRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetCoinInfoResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.coin_type.is_some() {
            len += 1;
        }
        if self.metadata.is_some() {
            len += 1;
        }
        if self.treasury.is_some() {
            len += 1;
        }
        if self.regulated_metadata.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetCoinInfoResponse", len)?;
        if let Some(v) = self.coin_type.as_ref() {
            struct_ser.serialize_field("coinType", v)?;
        }
        if let Some(v) = self.metadata.as_ref() {
            struct_ser.serialize_field("metadata", v)?;
        }
        if let Some(v) = self.treasury.as_ref() {
            struct_ser.serialize_field("treasury", v)?;
        }
        if let Some(v) = self.regulated_metadata.as_ref() {
            struct_ser.serialize_field("regulatedMetadata", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetCoinInfoResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "coin_type",
            "coinType",
            "metadata",
            "treasury",
            "regulated_metadata",
            "regulatedMetadata",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            CoinType,
            Metadata,
            Treasury,
            RegulatedMetadata,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "coinType" | "coin_type" => Ok(GeneratedField::CoinType),
                            "metadata" => Ok(GeneratedField::Metadata),
                            "treasury" => Ok(GeneratedField::Treasury),
                            "regulatedMetadata" | "regulated_metadata" => Ok(GeneratedField::RegulatedMetadata),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetCoinInfoResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetCoinInfoResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetCoinInfoResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut coin_type__ = None;
                let mut metadata__ = None;
                let mut treasury__ = None;
                let mut regulated_metadata__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::CoinType => {
                            if coin_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coinType"));
                            }
                            coin_type__ = map_.next_value()?;
                        }
                        GeneratedField::Metadata => {
                            if metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadata"));
                            }
                            metadata__ = map_.next_value()?;
                        }
                        GeneratedField::Treasury => {
                            if treasury__.is_some() {
                                return Err(serde::de::Error::duplicate_field("treasury"));
                            }
                            treasury__ = map_.next_value()?;
                        }
                        GeneratedField::RegulatedMetadata => {
                            if regulated_metadata__.is_some() {
                                return Err(serde::de::Error::duplicate_field("regulatedMetadata"));
                            }
                            regulated_metadata__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GetCoinInfoResponse {
                    coin_type: coin_type__,
                    metadata: metadata__,
                    treasury: treasury__,
                    regulated_metadata: regulated_metadata__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetCoinInfoResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetDatatypeRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.package_id.is_some() {
            len += 1;
        }
        if self.module_name.is_some() {
            len += 1;
        }
        if self.name.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetDatatypeRequest", len)?;
        if let Some(v) = self.package_id.as_ref() {
            struct_ser.serialize_field("packageId", v)?;
        }
        if let Some(v) = self.module_name.as_ref() {
            struct_ser.serialize_field("moduleName", v)?;
        }
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetDatatypeRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "package_id",
            "packageId",
            "module_name",
            "moduleName",
            "name",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PackageId,
            ModuleName,
            Name,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "packageId" | "package_id" => Ok(GeneratedField::PackageId),
                            "moduleName" | "module_name" => Ok(GeneratedField::ModuleName),
                            "name" => Ok(GeneratedField::Name),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetDatatypeRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetDatatypeRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetDatatypeRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut package_id__ = None;
                let mut module_name__ = None;
                let mut name__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PackageId => {
                            if package_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("packageId"));
                            }
                            package_id__ = map_.next_value()?;
                        }
                        GeneratedField::ModuleName => {
                            if module_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("moduleName"));
                            }
                            module_name__ = map_.next_value()?;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GetDatatypeRequest {
                    package_id: package_id__,
                    module_name: module_name__,
                    name: name__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetDatatypeRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetDatatypeResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.datatype.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetDatatypeResponse", len)?;
        if let Some(v) = self.datatype.as_ref() {
            struct_ser.serialize_field("datatype", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetDatatypeResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "datatype",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Datatype,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "datatype" => Ok(GeneratedField::Datatype),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetDatatypeResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetDatatypeResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetDatatypeResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut datatype__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Datatype => {
                            if datatype__.is_some() {
                                return Err(serde::de::Error::duplicate_field("datatype"));
                            }
                            datatype__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GetDatatypeResponse {
                    datatype: datatype__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetDatatypeResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetEpochRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.epoch.is_some() {
            len += 1;
        }
        if self.read_mask.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetEpochRequest", len)?;
        if let Some(v) = self.epoch.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("epoch", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.read_mask.as_ref() {
            struct_ser.serialize_field("readMask", &crate::_serde::FieldMaskSerializer(v))?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetEpochRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "epoch",
            "read_mask",
            "readMask",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Epoch,
            ReadMask,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "epoch" => Ok(GeneratedField::Epoch),
                            "readMask" | "read_mask" => Ok(GeneratedField::ReadMask),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetEpochRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetEpochRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetEpochRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut epoch__ = None;
                let mut read_mask__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Epoch => {
                            if epoch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("epoch"));
                            }
                            epoch__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ReadMask => {
                            if read_mask__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readMask"));
                            }
                            read_mask__ = map_.next_value::<::std::option::Option<crate::_serde::FieldMaskDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GetEpochRequest {
                    epoch: epoch__,
                    read_mask: read_mask__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetEpochRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetEpochResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.epoch.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetEpochResponse", len)?;
        if let Some(v) = self.epoch.as_ref() {
            struct_ser.serialize_field("epoch", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetEpochResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "epoch",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Epoch,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "epoch" => Ok(GeneratedField::Epoch),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetEpochResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetEpochResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetEpochResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut epoch__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Epoch => {
                            if epoch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("epoch"));
                            }
                            epoch__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GetEpochResponse {
                    epoch: epoch__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetEpochResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetFunctionRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.package_id.is_some() {
            len += 1;
        }
        if self.module_name.is_some() {
            len += 1;
        }
        if self.name.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetFunctionRequest", len)?;
        if let Some(v) = self.package_id.as_ref() {
            struct_ser.serialize_field("packageId", v)?;
        }
        if let Some(v) = self.module_name.as_ref() {
            struct_ser.serialize_field("moduleName", v)?;
        }
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetFunctionRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "package_id",
            "packageId",
            "module_name",
            "moduleName",
            "name",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PackageId,
            ModuleName,
            Name,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "packageId" | "package_id" => Ok(GeneratedField::PackageId),
                            "moduleName" | "module_name" => Ok(GeneratedField::ModuleName),
                            "name" => Ok(GeneratedField::Name),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetFunctionRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetFunctionRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetFunctionRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut package_id__ = None;
                let mut module_name__ = None;
                let mut name__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PackageId => {
                            if package_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("packageId"));
                            }
                            package_id__ = map_.next_value()?;
                        }
                        GeneratedField::ModuleName => {
                            if module_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("moduleName"));
                            }
                            module_name__ = map_.next_value()?;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GetFunctionRequest {
                    package_id: package_id__,
                    module_name: module_name__,
                    name: name__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetFunctionRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetFunctionResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.function.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetFunctionResponse", len)?;
        if let Some(v) = self.function.as_ref() {
            struct_ser.serialize_field("function", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetFunctionResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "function",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Function,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "function" => Ok(GeneratedField::Function),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetFunctionResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetFunctionResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetFunctionResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut function__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Function => {
                            if function__.is_some() {
                                return Err(serde::de::Error::duplicate_field("function"));
                            }
                            function__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GetFunctionResponse {
                    function: function__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetFunctionResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetObjectRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.object_id.is_some() {
            len += 1;
        }
        if self.version.is_some() {
            len += 1;
        }
        if self.read_mask.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetObjectRequest", len)?;
        if let Some(v) = self.object_id.as_ref() {
            struct_ser.serialize_field("objectId", v)?;
        }
        if let Some(v) = self.version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("version", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.read_mask.as_ref() {
            struct_ser.serialize_field("readMask", &crate::_serde::FieldMaskSerializer(v))?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetObjectRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "object_id",
            "objectId",
            "version",
            "read_mask",
            "readMask",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ObjectId,
            Version,
            ReadMask,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "objectId" | "object_id" => Ok(GeneratedField::ObjectId),
                            "version" => Ok(GeneratedField::Version),
                            "readMask" | "read_mask" => Ok(GeneratedField::ReadMask),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetObjectRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetObjectRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetObjectRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut object_id__ = None;
                let mut version__ = None;
                let mut read_mask__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ObjectId => {
                            if object_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objectId"));
                            }
                            object_id__ = map_.next_value()?;
                        }
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ReadMask => {
                            if read_mask__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readMask"));
                            }
                            read_mask__ = map_.next_value::<::std::option::Option<crate::_serde::FieldMaskDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GetObjectRequest {
                    object_id: object_id__,
                    version: version__,
                    read_mask: read_mask__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetObjectRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetObjectResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.object.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetObjectResponse", len)?;
        if let Some(v) = self.object.as_ref() {
            struct_ser.serialize_field("object", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetObjectResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "object",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Object,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "object" => Ok(GeneratedField::Object),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetObjectResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetObjectResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetObjectResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut object__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Object => {
                            if object__.is_some() {
                                return Err(serde::de::Error::duplicate_field("object"));
                            }
                            object__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GetObjectResponse {
                    object: object__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetObjectResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetObjectResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.result.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetObjectResult", len)?;
        if let Some(v) = self.result.as_ref() {
            match v {
                get_object_result::Result::Object(v) => {
                    struct_ser.serialize_field("object", v)?;
                }
                get_object_result::Result::Error(v) => {
                    struct_ser.serialize_field("error", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetObjectResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "object",
            "error",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Object,
            Error,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "object" => Ok(GeneratedField::Object),
                            "error" => Ok(GeneratedField::Error),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetObjectResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetObjectResult")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetObjectResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut result__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Object => {
                            if result__.is_some() {
                                return Err(serde::de::Error::duplicate_field("object"));
                            }
                            result__ = map_.next_value::<::std::option::Option<_>>()?.map(get_object_result::Result::Object)
;
                        }
                        GeneratedField::Error => {
                            if result__.is_some() {
                                return Err(serde::de::Error::duplicate_field("error"));
                            }
                            result__ = map_.next_value::<::std::option::Option<_>>()?.map(get_object_result::Result::Error)
;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GetObjectResult {
                    result: result__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetObjectResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetPackageRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.package_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetPackageRequest", len)?;
        if let Some(v) = self.package_id.as_ref() {
            struct_ser.serialize_field("packageId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetPackageRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "package_id",
            "packageId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PackageId,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "packageId" | "package_id" => Ok(GeneratedField::PackageId),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetPackageRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetPackageRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetPackageRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut package_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PackageId => {
                            if package_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("packageId"));
                            }
                            package_id__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GetPackageRequest {
                    package_id: package_id__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetPackageRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetPackageResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.package.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetPackageResponse", len)?;
        if let Some(v) = self.package.as_ref() {
            struct_ser.serialize_field("package", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetPackageResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "package",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Package,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "package" => Ok(GeneratedField::Package),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetPackageResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetPackageResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetPackageResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut package__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Package => {
                            if package__.is_some() {
                                return Err(serde::de::Error::duplicate_field("package"));
                            }
                            package__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GetPackageResponse {
                    package: package__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetPackageResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetServiceInfoRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let len = 0;
        let struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetServiceInfoRequest", len)?;
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetServiceInfoRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                            Ok(GeneratedField::__SkipField__)
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetServiceInfoRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetServiceInfoRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetServiceInfoRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                while map_.next_key::<GeneratedField>()?.is_some() {
                    let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                }
                Ok(GetServiceInfoRequest {
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetServiceInfoRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetServiceInfoResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.chain_id.is_some() {
            len += 1;
        }
        if self.chain.is_some() {
            len += 1;
        }
        if self.epoch.is_some() {
            len += 1;
        }
        if self.checkpoint_height.is_some() {
            len += 1;
        }
        if self.timestamp.is_some() {
            len += 1;
        }
        if self.lowest_available_checkpoint.is_some() {
            len += 1;
        }
        if self.lowest_available_checkpoint_objects.is_some() {
            len += 1;
        }
        if self.server.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetServiceInfoResponse", len)?;
        if let Some(v) = self.chain_id.as_ref() {
            struct_ser.serialize_field("chainId", v)?;
        }
        if let Some(v) = self.chain.as_ref() {
            struct_ser.serialize_field("chain", v)?;
        }
        if let Some(v) = self.epoch.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("epoch", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.checkpoint_height.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("checkpointHeight", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.timestamp.as_ref() {
            struct_ser.serialize_field("timestamp", &crate::_serde::TimestampSerializer(v))?;
        }
        if let Some(v) = self.lowest_available_checkpoint.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("lowestAvailableCheckpoint", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.lowest_available_checkpoint_objects.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("lowestAvailableCheckpointObjects", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.server.as_ref() {
            struct_ser.serialize_field("server", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetServiceInfoResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "chain_id",
            "chainId",
            "chain",
            "epoch",
            "checkpoint_height",
            "checkpointHeight",
            "timestamp",
            "lowest_available_checkpoint",
            "lowestAvailableCheckpoint",
            "lowest_available_checkpoint_objects",
            "lowestAvailableCheckpointObjects",
            "server",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ChainId,
            Chain,
            Epoch,
            CheckpointHeight,
            Timestamp,
            LowestAvailableCheckpoint,
            LowestAvailableCheckpointObjects,
            Server,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "chainId" | "chain_id" => Ok(GeneratedField::ChainId),
                            "chain" => Ok(GeneratedField::Chain),
                            "epoch" => Ok(GeneratedField::Epoch),
                            "checkpointHeight" | "checkpoint_height" => Ok(GeneratedField::CheckpointHeight),
                            "timestamp" => Ok(GeneratedField::Timestamp),
                            "lowestAvailableCheckpoint" | "lowest_available_checkpoint" => Ok(GeneratedField::LowestAvailableCheckpoint),
                            "lowestAvailableCheckpointObjects" | "lowest_available_checkpoint_objects" => Ok(GeneratedField::LowestAvailableCheckpointObjects),
                            "server" => Ok(GeneratedField::Server),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetServiceInfoResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetServiceInfoResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetServiceInfoResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut chain_id__ = None;
                let mut chain__ = None;
                let mut epoch__ = None;
                let mut checkpoint_height__ = None;
                let mut timestamp__ = None;
                let mut lowest_available_checkpoint__ = None;
                let mut lowest_available_checkpoint_objects__ = None;
                let mut server__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ChainId => {
                            if chain_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("chainId"));
                            }
                            chain_id__ = map_.next_value()?;
                        }
                        GeneratedField::Chain => {
                            if chain__.is_some() {
                                return Err(serde::de::Error::duplicate_field("chain"));
                            }
                            chain__ = map_.next_value()?;
                        }
                        GeneratedField::Epoch => {
                            if epoch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("epoch"));
                            }
                            epoch__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CheckpointHeight => {
                            if checkpoint_height__.is_some() {
                                return Err(serde::de::Error::duplicate_field("checkpointHeight"));
                            }
                            checkpoint_height__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Timestamp => {
                            if timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("timestamp"));
                            }
                            timestamp__ = map_.next_value::<::std::option::Option<crate::_serde::TimestampDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::LowestAvailableCheckpoint => {
                            if lowest_available_checkpoint__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lowestAvailableCheckpoint"));
                            }
                            lowest_available_checkpoint__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LowestAvailableCheckpointObjects => {
                            if lowest_available_checkpoint_objects__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lowestAvailableCheckpointObjects"));
                            }
                            lowest_available_checkpoint_objects__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Server => {
                            if server__.is_some() {
                                return Err(serde::de::Error::duplicate_field("server"));
                            }
                            server__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GetServiceInfoResponse {
                    chain_id: chain_id__,
                    chain: chain__,
                    epoch: epoch__,
                    checkpoint_height: checkpoint_height__,
                    timestamp: timestamp__,
                    lowest_available_checkpoint: lowest_available_checkpoint__,
                    lowest_available_checkpoint_objects: lowest_available_checkpoint_objects__,
                    server: server__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetServiceInfoResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetTransactionRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.digest.is_some() {
            len += 1;
        }
        if self.read_mask.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetTransactionRequest", len)?;
        if let Some(v) = self.digest.as_ref() {
            struct_ser.serialize_field("digest", v)?;
        }
        if let Some(v) = self.read_mask.as_ref() {
            struct_ser.serialize_field("readMask", &crate::_serde::FieldMaskSerializer(v))?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetTransactionRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "digest",
            "read_mask",
            "readMask",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Digest,
            ReadMask,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "digest" => Ok(GeneratedField::Digest),
                            "readMask" | "read_mask" => Ok(GeneratedField::ReadMask),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetTransactionRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetTransactionRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetTransactionRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut digest__ = None;
                let mut read_mask__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Digest => {
                            if digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("digest"));
                            }
                            digest__ = map_.next_value()?;
                        }
                        GeneratedField::ReadMask => {
                            if read_mask__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readMask"));
                            }
                            read_mask__ = map_.next_value::<::std::option::Option<crate::_serde::FieldMaskDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GetTransactionRequest {
                    digest: digest__,
                    read_mask: read_mask__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetTransactionRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetTransactionResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.transaction.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetTransactionResponse", len)?;
        if let Some(v) = self.transaction.as_ref() {
            struct_ser.serialize_field("transaction", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetTransactionResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "transaction",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Transaction,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "transaction" => Ok(GeneratedField::Transaction),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetTransactionResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetTransactionResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetTransactionResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut transaction__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Transaction => {
                            if transaction__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transaction"));
                            }
                            transaction__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GetTransactionResponse {
                    transaction: transaction__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetTransactionResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for GetTransactionResult {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.result.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.GetTransactionResult", len)?;
        if let Some(v) = self.result.as_ref() {
            match v {
                get_transaction_result::Result::Transaction(v) => {
                    struct_ser.serialize_field("transaction", v)?;
                }
                get_transaction_result::Result::Error(v) => {
                    struct_ser.serialize_field("error", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for GetTransactionResult {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "transaction",
            "error",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Transaction,
            Error,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "transaction" => Ok(GeneratedField::Transaction),
                            "error" => Ok(GeneratedField::Error),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = GetTransactionResult;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.GetTransactionResult")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<GetTransactionResult, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut result__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Transaction => {
                            if result__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transaction"));
                            }
                            result__ = map_.next_value::<::std::option::Option<_>>()?.map(get_transaction_result::Result::Transaction)
;
                        }
                        GeneratedField::Error => {
                            if result__.is_some() {
                                return Err(serde::de::Error::duplicate_field("error"));
                            }
                            result__ = map_.next_value::<::std::option::Option<_>>()?.map(get_transaction_result::Result::Error)
;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(GetTransactionResult {
                    result: result__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.GetTransactionResult", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for IndexError {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.index.is_some() {
            len += 1;
        }
        if self.subresult.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.IndexError", len)?;
        if let Some(v) = self.index.as_ref() {
            struct_ser.serialize_field("index", v)?;
        }
        if let Some(v) = self.subresult.as_ref() {
            struct_ser.serialize_field("subresult", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for IndexError {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "index",
            "subresult",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Index,
            Subresult,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "index" => Ok(GeneratedField::Index),
                            "subresult" => Ok(GeneratedField::Subresult),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = IndexError;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.IndexError")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<IndexError, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut index__ = None;
                let mut subresult__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Index => {
                            if index__.is_some() {
                                return Err(serde::de::Error::duplicate_field("index"));
                            }
                            index__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Subresult => {
                            if subresult__.is_some() {
                                return Err(serde::de::Error::duplicate_field("subresult"));
                            }
                            subresult__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(IndexError {
                    index: index__,
                    subresult: subresult__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.IndexError", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Input {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind.is_some() {
            len += 1;
        }
        if self.pure.is_some() {
            len += 1;
        }
        if self.object_id.is_some() {
            len += 1;
        }
        if self.version.is_some() {
            len += 1;
        }
        if self.digest.is_some() {
            len += 1;
        }
        if self.mutable.is_some() {
            len += 1;
        }
        if self.literal.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.Input", len)?;
        if let Some(v) = self.kind.as_ref() {
            let v = input::InputKind::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if let Some(v) = self.pure.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("pure", crate::_serde::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.object_id.as_ref() {
            struct_ser.serialize_field("objectId", v)?;
        }
        if let Some(v) = self.version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("version", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.digest.as_ref() {
            struct_ser.serialize_field("digest", v)?;
        }
        if let Some(v) = self.mutable.as_ref() {
            struct_ser.serialize_field("mutable", v)?;
        }
        if let Some(v) = self.literal.as_ref() {
            struct_ser.serialize_field("literal", &crate::_serde::ValueSerializer(v))?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Input {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kind",
            "pure",
            "object_id",
            "objectId",
            "version",
            "digest",
            "mutable",
            "literal",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Kind,
            Pure,
            ObjectId,
            Version,
            Digest,
            Mutable,
            Literal,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kind" => Ok(GeneratedField::Kind),
                            "pure" => Ok(GeneratedField::Pure),
                            "objectId" | "object_id" => Ok(GeneratedField::ObjectId),
                            "version" => Ok(GeneratedField::Version),
                            "digest" => Ok(GeneratedField::Digest),
                            "mutable" => Ok(GeneratedField::Mutable),
                            "literal" => Ok(GeneratedField::Literal),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Input;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.Input")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Input, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                let mut pure__ = None;
                let mut object_id__ = None;
                let mut version__ = None;
                let mut digest__ = None;
                let mut mutable__ = None;
                let mut literal__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<input::InputKind>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Pure => {
                            if pure__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pure"));
                            }
                            pure__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ObjectId => {
                            if object_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objectId"));
                            }
                            object_id__ = map_.next_value()?;
                        }
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Digest => {
                            if digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("digest"));
                            }
                            digest__ = map_.next_value()?;
                        }
                        GeneratedField::Mutable => {
                            if mutable__.is_some() {
                                return Err(serde::de::Error::duplicate_field("mutable"));
                            }
                            mutable__ = map_.next_value()?;
                        }
                        GeneratedField::Literal => {
                            if literal__.is_some() {
                                return Err(serde::de::Error::duplicate_field("literal"));
                            }
                            literal__ = map_.next_value::<::std::option::Option<crate::_serde::ValueDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Input {
                    kind: kind__,
                    pure: pure__,
                    object_id: object_id__,
                    version: version__,
                    digest: digest__,
                    mutable: mutable__,
                    literal: literal__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.Input", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for input::InputKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "INPUT_KIND_UNKNOWN",
            Self::Pure => "PURE",
            Self::ImmutableOrOwned => "IMMUTABLE_OR_OWNED",
            Self::Shared => "SHARED",
            Self::Receiving => "RECEIVING",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for input::InputKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "INPUT_KIND_UNKNOWN",
            "PURE",
            "IMMUTABLE_OR_OWNED",
            "SHARED",
            "RECEIVING",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = input::InputKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "INPUT_KIND_UNKNOWN" => Ok(input::InputKind::Unknown),
                    "PURE" => Ok(input::InputKind::Pure),
                    "IMMUTABLE_OR_OWNED" => Ok(input::InputKind::ImmutableOrOwned),
                    "SHARED" => Ok(input::InputKind::Shared),
                    "RECEIVING" => Ok(input::InputKind::Receiving),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Jwk {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kty.is_some() {
            len += 1;
        }
        if self.e.is_some() {
            len += 1;
        }
        if self.n.is_some() {
            len += 1;
        }
        if self.alg.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.Jwk", len)?;
        if let Some(v) = self.kty.as_ref() {
            struct_ser.serialize_field("kty", v)?;
        }
        if let Some(v) = self.e.as_ref() {
            struct_ser.serialize_field("e", v)?;
        }
        if let Some(v) = self.n.as_ref() {
            struct_ser.serialize_field("n", v)?;
        }
        if let Some(v) = self.alg.as_ref() {
            struct_ser.serialize_field("alg", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Jwk {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kty",
            "e",
            "n",
            "alg",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Kty,
            E,
            N,
            Alg,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kty" => Ok(GeneratedField::Kty),
                            "e" => Ok(GeneratedField::E),
                            "n" => Ok(GeneratedField::N),
                            "alg" => Ok(GeneratedField::Alg),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Jwk;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.Jwk")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Jwk, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kty__ = None;
                let mut e__ = None;
                let mut n__ = None;
                let mut alg__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Kty => {
                            if kty__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kty"));
                            }
                            kty__ = map_.next_value()?;
                        }
                        GeneratedField::E => {
                            if e__.is_some() {
                                return Err(serde::de::Error::duplicate_field("e"));
                            }
                            e__ = map_.next_value()?;
                        }
                        GeneratedField::N => {
                            if n__.is_some() {
                                return Err(serde::de::Error::duplicate_field("n"));
                            }
                            n__ = map_.next_value()?;
                        }
                        GeneratedField::Alg => {
                            if alg__.is_some() {
                                return Err(serde::de::Error::duplicate_field("alg"));
                            }
                            alg__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Jwk {
                    kty: kty__,
                    e: e__,
                    n: n__,
                    alg: alg__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.Jwk", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for JwkId {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.iss.is_some() {
            len += 1;
        }
        if self.kid.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.JwkId", len)?;
        if let Some(v) = self.iss.as_ref() {
            struct_ser.serialize_field("iss", v)?;
        }
        if let Some(v) = self.kid.as_ref() {
            struct_ser.serialize_field("kid", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for JwkId {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "iss",
            "kid",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Iss,
            Kid,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "iss" => Ok(GeneratedField::Iss),
                            "kid" => Ok(GeneratedField::Kid),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = JwkId;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.JwkId")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<JwkId, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut iss__ = None;
                let mut kid__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Iss => {
                            if iss__.is_some() {
                                return Err(serde::de::Error::duplicate_field("iss"));
                            }
                            iss__ = map_.next_value()?;
                        }
                        GeneratedField::Kid => {
                            if kid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kid"));
                            }
                            kid__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(JwkId {
                    iss: iss__,
                    kid: kid__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.JwkId", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Linkage {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.original_id.is_some() {
            len += 1;
        }
        if self.upgraded_id.is_some() {
            len += 1;
        }
        if self.upgraded_version.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.Linkage", len)?;
        if let Some(v) = self.original_id.as_ref() {
            struct_ser.serialize_field("originalId", v)?;
        }
        if let Some(v) = self.upgraded_id.as_ref() {
            struct_ser.serialize_field("upgradedId", v)?;
        }
        if let Some(v) = self.upgraded_version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("upgradedVersion", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Linkage {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "original_id",
            "originalId",
            "upgraded_id",
            "upgradedId",
            "upgraded_version",
            "upgradedVersion",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            OriginalId,
            UpgradedId,
            UpgradedVersion,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "originalId" | "original_id" => Ok(GeneratedField::OriginalId),
                            "upgradedId" | "upgraded_id" => Ok(GeneratedField::UpgradedId),
                            "upgradedVersion" | "upgraded_version" => Ok(GeneratedField::UpgradedVersion),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Linkage;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.Linkage")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Linkage, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut original_id__ = None;
                let mut upgraded_id__ = None;
                let mut upgraded_version__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::OriginalId => {
                            if original_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("originalId"));
                            }
                            original_id__ = map_.next_value()?;
                        }
                        GeneratedField::UpgradedId => {
                            if upgraded_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("upgradedId"));
                            }
                            upgraded_id__ = map_.next_value()?;
                        }
                        GeneratedField::UpgradedVersion => {
                            if upgraded_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("upgradedVersion"));
                            }
                            upgraded_version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Linkage {
                    original_id: original_id__,
                    upgraded_id: upgraded_id__,
                    upgraded_version: upgraded_version__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.Linkage", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ListBalancesRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.owner.is_some() {
            len += 1;
        }
        if self.page_size.is_some() {
            len += 1;
        }
        if self.page_token.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ListBalancesRequest", len)?;
        if let Some(v) = self.owner.as_ref() {
            struct_ser.serialize_field("owner", v)?;
        }
        if let Some(v) = self.page_size.as_ref() {
            struct_ser.serialize_field("pageSize", v)?;
        }
        if let Some(v) = self.page_token.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("pageToken", crate::_serde::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ListBalancesRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "owner",
            "page_size",
            "pageSize",
            "page_token",
            "pageToken",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Owner,
            PageSize,
            PageToken,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "owner" => Ok(GeneratedField::Owner),
                            "pageSize" | "page_size" => Ok(GeneratedField::PageSize),
                            "pageToken" | "page_token" => Ok(GeneratedField::PageToken),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ListBalancesRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ListBalancesRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ListBalancesRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut owner__ = None;
                let mut page_size__ = None;
                let mut page_token__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Owner => {
                            if owner__.is_some() {
                                return Err(serde::de::Error::duplicate_field("owner"));
                            }
                            owner__ = map_.next_value()?;
                        }
                        GeneratedField::PageSize => {
                            if page_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pageSize"));
                            }
                            page_size__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PageToken => {
                            if page_token__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pageToken"));
                            }
                            page_token__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ListBalancesRequest {
                    owner: owner__,
                    page_size: page_size__,
                    page_token: page_token__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ListBalancesRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ListBalancesResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.balances.is_empty() {
            len += 1;
        }
        if self.next_page_token.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ListBalancesResponse", len)?;
        if !self.balances.is_empty() {
            struct_ser.serialize_field("balances", &self.balances)?;
        }
        if let Some(v) = self.next_page_token.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("nextPageToken", crate::_serde::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ListBalancesResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "balances",
            "next_page_token",
            "nextPageToken",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Balances,
            NextPageToken,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "balances" => Ok(GeneratedField::Balances),
                            "nextPageToken" | "next_page_token" => Ok(GeneratedField::NextPageToken),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ListBalancesResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ListBalancesResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ListBalancesResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut balances__ = None;
                let mut next_page_token__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Balances => {
                            if balances__.is_some() {
                                return Err(serde::de::Error::duplicate_field("balances"));
                            }
                            balances__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NextPageToken => {
                            if next_page_token__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nextPageToken"));
                            }
                            next_page_token__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ListBalancesResponse {
                    balances: balances__.unwrap_or_default(),
                    next_page_token: next_page_token__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ListBalancesResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ListDynamicFieldsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.parent.is_some() {
            len += 1;
        }
        if self.page_size.is_some() {
            len += 1;
        }
        if self.page_token.is_some() {
            len += 1;
        }
        if self.read_mask.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ListDynamicFieldsRequest", len)?;
        if let Some(v) = self.parent.as_ref() {
            struct_ser.serialize_field("parent", v)?;
        }
        if let Some(v) = self.page_size.as_ref() {
            struct_ser.serialize_field("pageSize", v)?;
        }
        if let Some(v) = self.page_token.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("pageToken", crate::_serde::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.read_mask.as_ref() {
            struct_ser.serialize_field("readMask", &crate::_serde::FieldMaskSerializer(v))?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ListDynamicFieldsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "parent",
            "page_size",
            "pageSize",
            "page_token",
            "pageToken",
            "read_mask",
            "readMask",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Parent,
            PageSize,
            PageToken,
            ReadMask,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "parent" => Ok(GeneratedField::Parent),
                            "pageSize" | "page_size" => Ok(GeneratedField::PageSize),
                            "pageToken" | "page_token" => Ok(GeneratedField::PageToken),
                            "readMask" | "read_mask" => Ok(GeneratedField::ReadMask),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ListDynamicFieldsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ListDynamicFieldsRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ListDynamicFieldsRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut parent__ = None;
                let mut page_size__ = None;
                let mut page_token__ = None;
                let mut read_mask__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Parent => {
                            if parent__.is_some() {
                                return Err(serde::de::Error::duplicate_field("parent"));
                            }
                            parent__ = map_.next_value()?;
                        }
                        GeneratedField::PageSize => {
                            if page_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pageSize"));
                            }
                            page_size__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PageToken => {
                            if page_token__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pageToken"));
                            }
                            page_token__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ReadMask => {
                            if read_mask__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readMask"));
                            }
                            read_mask__ = map_.next_value::<::std::option::Option<crate::_serde::FieldMaskDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ListDynamicFieldsRequest {
                    parent: parent__,
                    page_size: page_size__,
                    page_token: page_token__,
                    read_mask: read_mask__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ListDynamicFieldsRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ListDynamicFieldsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.dynamic_fields.is_empty() {
            len += 1;
        }
        if self.next_page_token.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ListDynamicFieldsResponse", len)?;
        if !self.dynamic_fields.is_empty() {
            struct_ser.serialize_field("dynamicFields", &self.dynamic_fields)?;
        }
        if let Some(v) = self.next_page_token.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("nextPageToken", crate::_serde::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ListDynamicFieldsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "dynamic_fields",
            "dynamicFields",
            "next_page_token",
            "nextPageToken",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            DynamicFields,
            NextPageToken,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "dynamicFields" | "dynamic_fields" => Ok(GeneratedField::DynamicFields),
                            "nextPageToken" | "next_page_token" => Ok(GeneratedField::NextPageToken),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ListDynamicFieldsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ListDynamicFieldsResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ListDynamicFieldsResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut dynamic_fields__ = None;
                let mut next_page_token__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::DynamicFields => {
                            if dynamic_fields__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dynamicFields"));
                            }
                            dynamic_fields__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NextPageToken => {
                            if next_page_token__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nextPageToken"));
                            }
                            next_page_token__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ListDynamicFieldsResponse {
                    dynamic_fields: dynamic_fields__.unwrap_or_default(),
                    next_page_token: next_page_token__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ListDynamicFieldsResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ListOwnedObjectsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.owner.is_some() {
            len += 1;
        }
        if self.page_size.is_some() {
            len += 1;
        }
        if self.page_token.is_some() {
            len += 1;
        }
        if self.read_mask.is_some() {
            len += 1;
        }
        if self.object_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ListOwnedObjectsRequest", len)?;
        if let Some(v) = self.owner.as_ref() {
            struct_ser.serialize_field("owner", v)?;
        }
        if let Some(v) = self.page_size.as_ref() {
            struct_ser.serialize_field("pageSize", v)?;
        }
        if let Some(v) = self.page_token.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("pageToken", crate::_serde::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.read_mask.as_ref() {
            struct_ser.serialize_field("readMask", &crate::_serde::FieldMaskSerializer(v))?;
        }
        if let Some(v) = self.object_type.as_ref() {
            struct_ser.serialize_field("objectType", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ListOwnedObjectsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "owner",
            "page_size",
            "pageSize",
            "page_token",
            "pageToken",
            "read_mask",
            "readMask",
            "object_type",
            "objectType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Owner,
            PageSize,
            PageToken,
            ReadMask,
            ObjectType,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "owner" => Ok(GeneratedField::Owner),
                            "pageSize" | "page_size" => Ok(GeneratedField::PageSize),
                            "pageToken" | "page_token" => Ok(GeneratedField::PageToken),
                            "readMask" | "read_mask" => Ok(GeneratedField::ReadMask),
                            "objectType" | "object_type" => Ok(GeneratedField::ObjectType),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ListOwnedObjectsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ListOwnedObjectsRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ListOwnedObjectsRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut owner__ = None;
                let mut page_size__ = None;
                let mut page_token__ = None;
                let mut read_mask__ = None;
                let mut object_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Owner => {
                            if owner__.is_some() {
                                return Err(serde::de::Error::duplicate_field("owner"));
                            }
                            owner__ = map_.next_value()?;
                        }
                        GeneratedField::PageSize => {
                            if page_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pageSize"));
                            }
                            page_size__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PageToken => {
                            if page_token__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pageToken"));
                            }
                            page_token__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ReadMask => {
                            if read_mask__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readMask"));
                            }
                            read_mask__ = map_.next_value::<::std::option::Option<crate::_serde::FieldMaskDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::ObjectType => {
                            if object_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objectType"));
                            }
                            object_type__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ListOwnedObjectsRequest {
                    owner: owner__,
                    page_size: page_size__,
                    page_token: page_token__,
                    read_mask: read_mask__,
                    object_type: object_type__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ListOwnedObjectsRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ListOwnedObjectsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.objects.is_empty() {
            len += 1;
        }
        if self.next_page_token.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ListOwnedObjectsResponse", len)?;
        if !self.objects.is_empty() {
            struct_ser.serialize_field("objects", &self.objects)?;
        }
        if let Some(v) = self.next_page_token.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("nextPageToken", crate::_serde::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ListOwnedObjectsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "objects",
            "next_page_token",
            "nextPageToken",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Objects,
            NextPageToken,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "objects" => Ok(GeneratedField::Objects),
                            "nextPageToken" | "next_page_token" => Ok(GeneratedField::NextPageToken),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ListOwnedObjectsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ListOwnedObjectsResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ListOwnedObjectsResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut objects__ = None;
                let mut next_page_token__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Objects => {
                            if objects__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objects"));
                            }
                            objects__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NextPageToken => {
                            if next_page_token__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nextPageToken"));
                            }
                            next_page_token__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ListOwnedObjectsResponse {
                    objects: objects__.unwrap_or_default(),
                    next_page_token: next_page_token__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ListOwnedObjectsResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ListPackageVersionsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.package_id.is_some() {
            len += 1;
        }
        if self.page_size.is_some() {
            len += 1;
        }
        if self.page_token.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ListPackageVersionsRequest", len)?;
        if let Some(v) = self.package_id.as_ref() {
            struct_ser.serialize_field("packageId", v)?;
        }
        if let Some(v) = self.page_size.as_ref() {
            struct_ser.serialize_field("pageSize", v)?;
        }
        if let Some(v) = self.page_token.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("pageToken", crate::_serde::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ListPackageVersionsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "package_id",
            "packageId",
            "page_size",
            "pageSize",
            "page_token",
            "pageToken",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PackageId,
            PageSize,
            PageToken,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "packageId" | "package_id" => Ok(GeneratedField::PackageId),
                            "pageSize" | "page_size" => Ok(GeneratedField::PageSize),
                            "pageToken" | "page_token" => Ok(GeneratedField::PageToken),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ListPackageVersionsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ListPackageVersionsRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ListPackageVersionsRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut package_id__ = None;
                let mut page_size__ = None;
                let mut page_token__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PackageId => {
                            if package_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("packageId"));
                            }
                            package_id__ = map_.next_value()?;
                        }
                        GeneratedField::PageSize => {
                            if page_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pageSize"));
                            }
                            page_size__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PageToken => {
                            if page_token__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pageToken"));
                            }
                            page_token__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ListPackageVersionsRequest {
                    package_id: package_id__,
                    page_size: page_size__,
                    page_token: page_token__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ListPackageVersionsRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ListPackageVersionsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.versions.is_empty() {
            len += 1;
        }
        if self.next_page_token.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ListPackageVersionsResponse", len)?;
        if !self.versions.is_empty() {
            struct_ser.serialize_field("versions", &self.versions)?;
        }
        if let Some(v) = self.next_page_token.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("nextPageToken", crate::_serde::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ListPackageVersionsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "versions",
            "next_page_token",
            "nextPageToken",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Versions,
            NextPageToken,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "versions" => Ok(GeneratedField::Versions),
                            "nextPageToken" | "next_page_token" => Ok(GeneratedField::NextPageToken),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ListPackageVersionsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ListPackageVersionsResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ListPackageVersionsResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut versions__ = None;
                let mut next_page_token__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Versions => {
                            if versions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("versions"));
                            }
                            versions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::NextPageToken => {
                            if next_page_token__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nextPageToken"));
                            }
                            next_page_token__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ListPackageVersionsResponse {
                    versions: versions__.unwrap_or_default(),
                    next_page_token: next_page_token__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ListPackageVersionsResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LookupNameRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.LookupNameRequest", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LookupNameRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LookupNameRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.LookupNameRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LookupNameRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(LookupNameRequest {
                    name: name__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.LookupNameRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for LookupNameResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.record.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.LookupNameResponse", len)?;
        if let Some(v) = self.record.as_ref() {
            struct_ser.serialize_field("record", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for LookupNameResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "record",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Record,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "record" => Ok(GeneratedField::Record),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = LookupNameResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.LookupNameResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<LookupNameResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut record__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Record => {
                            if record__.is_some() {
                                return Err(serde::de::Error::duplicate_field("record"));
                            }
                            record__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(LookupNameResponse {
                    record: record__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.LookupNameResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MakeMoveVector {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.element_type.is_some() {
            len += 1;
        }
        if !self.elements.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.MakeMoveVector", len)?;
        if let Some(v) = self.element_type.as_ref() {
            struct_ser.serialize_field("elementType", v)?;
        }
        if !self.elements.is_empty() {
            struct_ser.serialize_field("elements", &self.elements)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MakeMoveVector {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "element_type",
            "elementType",
            "elements",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ElementType,
            Elements,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "elementType" | "element_type" => Ok(GeneratedField::ElementType),
                            "elements" => Ok(GeneratedField::Elements),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MakeMoveVector;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.MakeMoveVector")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MakeMoveVector, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut element_type__ = None;
                let mut elements__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ElementType => {
                            if element_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("elementType"));
                            }
                            element_type__ = map_.next_value()?;
                        }
                        GeneratedField::Elements => {
                            if elements__.is_some() {
                                return Err(serde::de::Error::duplicate_field("elements"));
                            }
                            elements__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(MakeMoveVector {
                    element_type: element_type__,
                    elements: elements__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.MakeMoveVector", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MergeCoins {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.coin.is_some() {
            len += 1;
        }
        if !self.coins_to_merge.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.MergeCoins", len)?;
        if let Some(v) = self.coin.as_ref() {
            struct_ser.serialize_field("coin", v)?;
        }
        if !self.coins_to_merge.is_empty() {
            struct_ser.serialize_field("coinsToMerge", &self.coins_to_merge)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MergeCoins {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "coin",
            "coins_to_merge",
            "coinsToMerge",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Coin,
            CoinsToMerge,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "coin" => Ok(GeneratedField::Coin),
                            "coinsToMerge" | "coins_to_merge" => Ok(GeneratedField::CoinsToMerge),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MergeCoins;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.MergeCoins")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MergeCoins, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut coin__ = None;
                let mut coins_to_merge__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Coin => {
                            if coin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coin"));
                            }
                            coin__ = map_.next_value()?;
                        }
                        GeneratedField::CoinsToMerge => {
                            if coins_to_merge__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coinsToMerge"));
                            }
                            coins_to_merge__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(MergeCoins {
                    coin: coin__,
                    coins_to_merge: coins_to_merge__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.MergeCoins", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Module {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.contents.is_some() {
            len += 1;
        }
        if !self.datatypes.is_empty() {
            len += 1;
        }
        if !self.functions.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.Module", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.contents.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("contents", crate::_serde::base64::encode(&v).as_str())?;
        }
        if !self.datatypes.is_empty() {
            struct_ser.serialize_field("datatypes", &self.datatypes)?;
        }
        if !self.functions.is_empty() {
            struct_ser.serialize_field("functions", &self.functions)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Module {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "contents",
            "datatypes",
            "functions",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Contents,
            Datatypes,
            Functions,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "contents" => Ok(GeneratedField::Contents),
                            "datatypes" => Ok(GeneratedField::Datatypes),
                            "functions" => Ok(GeneratedField::Functions),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Module;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.Module")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Module, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut contents__ = None;
                let mut datatypes__ = None;
                let mut functions__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map_.next_value()?;
                        }
                        GeneratedField::Contents => {
                            if contents__.is_some() {
                                return Err(serde::de::Error::duplicate_field("contents"));
                            }
                            contents__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Datatypes => {
                            if datatypes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("datatypes"));
                            }
                            datatypes__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Functions => {
                            if functions__.is_some() {
                                return Err(serde::de::Error::duplicate_field("functions"));
                            }
                            functions__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Module {
                    name: name__,
                    contents: contents__,
                    datatypes: datatypes__.unwrap_or_default(),
                    functions: functions__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.Module", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MoveAbort {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.abort_code.is_some() {
            len += 1;
        }
        if self.location.is_some() {
            len += 1;
        }
        if self.clever_error.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.MoveAbort", len)?;
        if let Some(v) = self.abort_code.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("abortCode", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.location.as_ref() {
            struct_ser.serialize_field("location", v)?;
        }
        if let Some(v) = self.clever_error.as_ref() {
            struct_ser.serialize_field("cleverError", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MoveAbort {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "abort_code",
            "abortCode",
            "location",
            "clever_error",
            "cleverError",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AbortCode,
            Location,
            CleverError,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "abortCode" | "abort_code" => Ok(GeneratedField::AbortCode),
                            "location" => Ok(GeneratedField::Location),
                            "cleverError" | "clever_error" => Ok(GeneratedField::CleverError),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MoveAbort;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.MoveAbort")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MoveAbort, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut abort_code__ = None;
                let mut location__ = None;
                let mut clever_error__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AbortCode => {
                            if abort_code__.is_some() {
                                return Err(serde::de::Error::duplicate_field("abortCode"));
                            }
                            abort_code__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Location => {
                            if location__.is_some() {
                                return Err(serde::de::Error::duplicate_field("location"));
                            }
                            location__ = map_.next_value()?;
                        }
                        GeneratedField::CleverError => {
                            if clever_error__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cleverError"));
                            }
                            clever_error__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(MoveAbort {
                    abort_code: abort_code__,
                    location: location__,
                    clever_error: clever_error__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.MoveAbort", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MoveCall {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.package.is_some() {
            len += 1;
        }
        if self.module.is_some() {
            len += 1;
        }
        if self.function.is_some() {
            len += 1;
        }
        if !self.type_arguments.is_empty() {
            len += 1;
        }
        if !self.arguments.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.MoveCall", len)?;
        if let Some(v) = self.package.as_ref() {
            struct_ser.serialize_field("package", v)?;
        }
        if let Some(v) = self.module.as_ref() {
            struct_ser.serialize_field("module", v)?;
        }
        if let Some(v) = self.function.as_ref() {
            struct_ser.serialize_field("function", v)?;
        }
        if !self.type_arguments.is_empty() {
            struct_ser.serialize_field("typeArguments", &self.type_arguments)?;
        }
        if !self.arguments.is_empty() {
            struct_ser.serialize_field("arguments", &self.arguments)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MoveCall {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "package",
            "module",
            "function",
            "type_arguments",
            "typeArguments",
            "arguments",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Package,
            Module,
            Function,
            TypeArguments,
            Arguments,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "package" => Ok(GeneratedField::Package),
                            "module" => Ok(GeneratedField::Module),
                            "function" => Ok(GeneratedField::Function),
                            "typeArguments" | "type_arguments" => Ok(GeneratedField::TypeArguments),
                            "arguments" => Ok(GeneratedField::Arguments),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MoveCall;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.MoveCall")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MoveCall, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut package__ = None;
                let mut module__ = None;
                let mut function__ = None;
                let mut type_arguments__ = None;
                let mut arguments__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Package => {
                            if package__.is_some() {
                                return Err(serde::de::Error::duplicate_field("package"));
                            }
                            package__ = map_.next_value()?;
                        }
                        GeneratedField::Module => {
                            if module__.is_some() {
                                return Err(serde::de::Error::duplicate_field("module"));
                            }
                            module__ = map_.next_value()?;
                        }
                        GeneratedField::Function => {
                            if function__.is_some() {
                                return Err(serde::de::Error::duplicate_field("function"));
                            }
                            function__ = map_.next_value()?;
                        }
                        GeneratedField::TypeArguments => {
                            if type_arguments__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeArguments"));
                            }
                            type_arguments__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Arguments => {
                            if arguments__.is_some() {
                                return Err(serde::de::Error::duplicate_field("arguments"));
                            }
                            arguments__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(MoveCall {
                    package: package__,
                    module: module__,
                    function: function__,
                    type_arguments: type_arguments__.unwrap_or_default(),
                    arguments: arguments__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.MoveCall", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MoveLocation {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.package.is_some() {
            len += 1;
        }
        if self.module.is_some() {
            len += 1;
        }
        if self.function.is_some() {
            len += 1;
        }
        if self.instruction.is_some() {
            len += 1;
        }
        if self.function_name.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.MoveLocation", len)?;
        if let Some(v) = self.package.as_ref() {
            struct_ser.serialize_field("package", v)?;
        }
        if let Some(v) = self.module.as_ref() {
            struct_ser.serialize_field("module", v)?;
        }
        if let Some(v) = self.function.as_ref() {
            struct_ser.serialize_field("function", v)?;
        }
        if let Some(v) = self.instruction.as_ref() {
            struct_ser.serialize_field("instruction", v)?;
        }
        if let Some(v) = self.function_name.as_ref() {
            struct_ser.serialize_field("functionName", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MoveLocation {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "package",
            "module",
            "function",
            "instruction",
            "function_name",
            "functionName",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Package,
            Module,
            Function,
            Instruction,
            FunctionName,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "package" => Ok(GeneratedField::Package),
                            "module" => Ok(GeneratedField::Module),
                            "function" => Ok(GeneratedField::Function),
                            "instruction" => Ok(GeneratedField::Instruction),
                            "functionName" | "function_name" => Ok(GeneratedField::FunctionName),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MoveLocation;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.MoveLocation")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MoveLocation, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut package__ = None;
                let mut module__ = None;
                let mut function__ = None;
                let mut instruction__ = None;
                let mut function_name__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Package => {
                            if package__.is_some() {
                                return Err(serde::de::Error::duplicate_field("package"));
                            }
                            package__ = map_.next_value()?;
                        }
                        GeneratedField::Module => {
                            if module__.is_some() {
                                return Err(serde::de::Error::duplicate_field("module"));
                            }
                            module__ = map_.next_value()?;
                        }
                        GeneratedField::Function => {
                            if function__.is_some() {
                                return Err(serde::de::Error::duplicate_field("function"));
                            }
                            function__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Instruction => {
                            if instruction__.is_some() {
                                return Err(serde::de::Error::duplicate_field("instruction"));
                            }
                            instruction__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FunctionName => {
                            if function_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("functionName"));
                            }
                            function_name__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(MoveLocation {
                    package: package__,
                    module: module__,
                    function: function__,
                    instruction: instruction__,
                    function_name: function_name__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.MoveLocation", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MoveTable {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.size.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.MoveTable", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("id", v)?;
        }
        if let Some(v) = self.size.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("size", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MoveTable {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "size",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Size,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "size" => Ok(GeneratedField::Size),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MoveTable;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.MoveTable")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MoveTable, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut size__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = map_.next_value()?;
                        }
                        GeneratedField::Size => {
                            if size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("size"));
                            }
                            size__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(MoveTable {
                    id: id__,
                    size: size__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.MoveTable", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MultisigAggregatedSignature {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.signatures.is_empty() {
            len += 1;
        }
        if self.bitmap.is_some() {
            len += 1;
        }
        if !self.legacy_bitmap.is_empty() {
            len += 1;
        }
        if self.committee.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.MultisigAggregatedSignature", len)?;
        if !self.signatures.is_empty() {
            struct_ser.serialize_field("signatures", &self.signatures)?;
        }
        if let Some(v) = self.bitmap.as_ref() {
            struct_ser.serialize_field("bitmap", v)?;
        }
        if !self.legacy_bitmap.is_empty() {
            struct_ser.serialize_field("legacyBitmap", &self.legacy_bitmap)?;
        }
        if let Some(v) = self.committee.as_ref() {
            struct_ser.serialize_field("committee", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MultisigAggregatedSignature {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "signatures",
            "bitmap",
            "legacy_bitmap",
            "legacyBitmap",
            "committee",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Signatures,
            Bitmap,
            LegacyBitmap,
            Committee,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "signatures" => Ok(GeneratedField::Signatures),
                            "bitmap" => Ok(GeneratedField::Bitmap),
                            "legacyBitmap" | "legacy_bitmap" => Ok(GeneratedField::LegacyBitmap),
                            "committee" => Ok(GeneratedField::Committee),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MultisigAggregatedSignature;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.MultisigAggregatedSignature")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MultisigAggregatedSignature, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut signatures__ = None;
                let mut bitmap__ = None;
                let mut legacy_bitmap__ = None;
                let mut committee__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Signatures => {
                            if signatures__.is_some() {
                                return Err(serde::de::Error::duplicate_field("signatures"));
                            }
                            signatures__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Bitmap => {
                            if bitmap__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bitmap"));
                            }
                            bitmap__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::LegacyBitmap => {
                            if legacy_bitmap__.is_some() {
                                return Err(serde::de::Error::duplicate_field("legacyBitmap"));
                            }
                            legacy_bitmap__ = 
                                Some(map_.next_value::<Vec<crate::_serde::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::Committee => {
                            if committee__.is_some() {
                                return Err(serde::de::Error::duplicate_field("committee"));
                            }
                            committee__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(MultisigAggregatedSignature {
                    signatures: signatures__.unwrap_or_default(),
                    bitmap: bitmap__,
                    legacy_bitmap: legacy_bitmap__.unwrap_or_default(),
                    committee: committee__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.MultisigAggregatedSignature", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MultisigCommittee {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.members.is_empty() {
            len += 1;
        }
        if self.threshold.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.MultisigCommittee", len)?;
        if !self.members.is_empty() {
            struct_ser.serialize_field("members", &self.members)?;
        }
        if let Some(v) = self.threshold.as_ref() {
            struct_ser.serialize_field("threshold", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MultisigCommittee {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "members",
            "threshold",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Members,
            Threshold,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "members" => Ok(GeneratedField::Members),
                            "threshold" => Ok(GeneratedField::Threshold),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MultisigCommittee;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.MultisigCommittee")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MultisigCommittee, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut members__ = None;
                let mut threshold__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Members => {
                            if members__.is_some() {
                                return Err(serde::de::Error::duplicate_field("members"));
                            }
                            members__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Threshold => {
                            if threshold__.is_some() {
                                return Err(serde::de::Error::duplicate_field("threshold"));
                            }
                            threshold__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(MultisigCommittee {
                    members: members__.unwrap_or_default(),
                    threshold: threshold__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.MultisigCommittee", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MultisigMember {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.public_key.is_some() {
            len += 1;
        }
        if self.weight.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.MultisigMember", len)?;
        if let Some(v) = self.public_key.as_ref() {
            struct_ser.serialize_field("publicKey", v)?;
        }
        if let Some(v) = self.weight.as_ref() {
            struct_ser.serialize_field("weight", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MultisigMember {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "public_key",
            "publicKey",
            "weight",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PublicKey,
            Weight,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "publicKey" | "public_key" => Ok(GeneratedField::PublicKey),
                            "weight" => Ok(GeneratedField::Weight),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MultisigMember;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.MultisigMember")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MultisigMember, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut public_key__ = None;
                let mut weight__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PublicKey => {
                            if public_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("publicKey"));
                            }
                            public_key__ = map_.next_value()?;
                        }
                        GeneratedField::Weight => {
                            if weight__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weight"));
                            }
                            weight__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(MultisigMember {
                    public_key: public_key__,
                    weight: weight__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.MultisigMember", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MultisigMemberPublicKey {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.scheme.is_some() {
            len += 1;
        }
        if self.public_key.is_some() {
            len += 1;
        }
        if self.zklogin.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.MultisigMemberPublicKey", len)?;
        if let Some(v) = self.scheme.as_ref() {
            let v = SignatureScheme::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("scheme", &v)?;
        }
        if let Some(v) = self.public_key.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("publicKey", crate::_serde::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.zklogin.as_ref() {
            struct_ser.serialize_field("zklogin", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MultisigMemberPublicKey {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "scheme",
            "public_key",
            "publicKey",
            "zklogin",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Scheme,
            PublicKey,
            Zklogin,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "scheme" => Ok(GeneratedField::Scheme),
                            "publicKey" | "public_key" => Ok(GeneratedField::PublicKey),
                            "zklogin" => Ok(GeneratedField::Zklogin),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MultisigMemberPublicKey;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.MultisigMemberPublicKey")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MultisigMemberPublicKey, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scheme__ = None;
                let mut public_key__ = None;
                let mut zklogin__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Scheme => {
                            if scheme__.is_some() {
                                return Err(serde::de::Error::duplicate_field("scheme"));
                            }
                            scheme__ = map_.next_value::<::std::option::Option<SignatureScheme>>()?.map(|x| x as i32);
                        }
                        GeneratedField::PublicKey => {
                            if public_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("publicKey"));
                            }
                            public_key__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Zklogin => {
                            if zklogin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("zklogin"));
                            }
                            zklogin__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(MultisigMemberPublicKey {
                    scheme: scheme__,
                    public_key: public_key__,
                    zklogin: zklogin__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.MultisigMemberPublicKey", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for MultisigMemberSignature {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.scheme.is_some() {
            len += 1;
        }
        if self.signature.is_some() {
            len += 1;
        }
        if self.zklogin.is_some() {
            len += 1;
        }
        if self.passkey.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.MultisigMemberSignature", len)?;
        if let Some(v) = self.scheme.as_ref() {
            let v = SignatureScheme::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("scheme", &v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("signature", crate::_serde::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.zklogin.as_ref() {
            struct_ser.serialize_field("zklogin", v)?;
        }
        if let Some(v) = self.passkey.as_ref() {
            struct_ser.serialize_field("passkey", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for MultisigMemberSignature {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "scheme",
            "signature",
            "zklogin",
            "passkey",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Scheme,
            Signature,
            Zklogin,
            Passkey,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "scheme" => Ok(GeneratedField::Scheme),
                            "signature" => Ok(GeneratedField::Signature),
                            "zklogin" => Ok(GeneratedField::Zklogin),
                            "passkey" => Ok(GeneratedField::Passkey),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = MultisigMemberSignature;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.MultisigMemberSignature")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<MultisigMemberSignature, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scheme__ = None;
                let mut signature__ = None;
                let mut zklogin__ = None;
                let mut passkey__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Scheme => {
                            if scheme__.is_some() {
                                return Err(serde::de::Error::duplicate_field("scheme"));
                            }
                            scheme__ = map_.next_value::<::std::option::Option<SignatureScheme>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Signature => {
                            if signature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("signature"));
                            }
                            signature__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Zklogin => {
                            if zklogin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("zklogin"));
                            }
                            zklogin__ = map_.next_value()?;
                        }
                        GeneratedField::Passkey => {
                            if passkey__.is_some() {
                                return Err(serde::de::Error::duplicate_field("passkey"));
                            }
                            passkey__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(MultisigMemberSignature {
                    scheme: scheme__,
                    signature: signature__,
                    zklogin: zklogin__,
                    passkey: passkey__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.MultisigMemberSignature", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for NameRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.name.is_some() {
            len += 1;
        }
        if self.registration_nft_id.is_some() {
            len += 1;
        }
        if self.expiration_timestamp.is_some() {
            len += 1;
        }
        if self.target_address.is_some() {
            len += 1;
        }
        if !self.data.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.NameRecord", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("id", v)?;
        }
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.registration_nft_id.as_ref() {
            struct_ser.serialize_field("registrationNftId", v)?;
        }
        if let Some(v) = self.expiration_timestamp.as_ref() {
            struct_ser.serialize_field("expirationTimestamp", &crate::_serde::TimestampSerializer(v))?;
        }
        if let Some(v) = self.target_address.as_ref() {
            struct_ser.serialize_field("targetAddress", v)?;
        }
        if !self.data.is_empty() {
            struct_ser.serialize_field("data", &self.data)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for NameRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "name",
            "registration_nft_id",
            "registrationNftId",
            "expiration_timestamp",
            "expirationTimestamp",
            "target_address",
            "targetAddress",
            "data",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            Name,
            RegistrationNftId,
            ExpirationTimestamp,
            TargetAddress,
            Data,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "name" => Ok(GeneratedField::Name),
                            "registrationNftId" | "registration_nft_id" => Ok(GeneratedField::RegistrationNftId),
                            "expirationTimestamp" | "expiration_timestamp" => Ok(GeneratedField::ExpirationTimestamp),
                            "targetAddress" | "target_address" => Ok(GeneratedField::TargetAddress),
                            "data" => Ok(GeneratedField::Data),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = NameRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.NameRecord")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<NameRecord, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut name__ = None;
                let mut registration_nft_id__ = None;
                let mut expiration_timestamp__ = None;
                let mut target_address__ = None;
                let mut data__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = map_.next_value()?;
                        }
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map_.next_value()?;
                        }
                        GeneratedField::RegistrationNftId => {
                            if registration_nft_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("registrationNftId"));
                            }
                            registration_nft_id__ = map_.next_value()?;
                        }
                        GeneratedField::ExpirationTimestamp => {
                            if expiration_timestamp__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expirationTimestamp"));
                            }
                            expiration_timestamp__ = map_.next_value::<::std::option::Option<crate::_serde::TimestampDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::TargetAddress => {
                            if target_address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("targetAddress"));
                            }
                            target_address__ = map_.next_value()?;
                        }
                        GeneratedField::Data => {
                            if data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("data"));
                            }
                            data__ = Some(
                                map_.next_value::<std::collections::BTreeMap<_, _>>()?
                            );
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(NameRecord {
                    id: id__,
                    name: name__,
                    registration_nft_id: registration_nft_id__,
                    expiration_timestamp: expiration_timestamp__,
                    target_address: target_address__,
                    data: data__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.NameRecord", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Object {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.bcs.is_some() {
            len += 1;
        }
        if self.object_id.is_some() {
            len += 1;
        }
        if self.version.is_some() {
            len += 1;
        }
        if self.digest.is_some() {
            len += 1;
        }
        if self.owner.is_some() {
            len += 1;
        }
        if self.object_type.is_some() {
            len += 1;
        }
        if self.has_public_transfer.is_some() {
            len += 1;
        }
        if self.contents.is_some() {
            len += 1;
        }
        if self.package.is_some() {
            len += 1;
        }
        if self.previous_transaction.is_some() {
            len += 1;
        }
        if self.storage_rebate.is_some() {
            len += 1;
        }
        if self.json.is_some() {
            len += 1;
        }
        if self.balance.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.Object", len)?;
        if let Some(v) = self.bcs.as_ref() {
            struct_ser.serialize_field("bcs", v)?;
        }
        if let Some(v) = self.object_id.as_ref() {
            struct_ser.serialize_field("objectId", v)?;
        }
        if let Some(v) = self.version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("version", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.digest.as_ref() {
            struct_ser.serialize_field("digest", v)?;
        }
        if let Some(v) = self.owner.as_ref() {
            struct_ser.serialize_field("owner", v)?;
        }
        if let Some(v) = self.object_type.as_ref() {
            struct_ser.serialize_field("objectType", v)?;
        }
        if let Some(v) = self.has_public_transfer.as_ref() {
            struct_ser.serialize_field("hasPublicTransfer", v)?;
        }
        if let Some(v) = self.contents.as_ref() {
            struct_ser.serialize_field("contents", v)?;
        }
        if let Some(v) = self.package.as_ref() {
            struct_ser.serialize_field("package", v)?;
        }
        if let Some(v) = self.previous_transaction.as_ref() {
            struct_ser.serialize_field("previousTransaction", v)?;
        }
        if let Some(v) = self.storage_rebate.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("storageRebate", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.json.as_ref() {
            struct_ser.serialize_field("json", &crate::_serde::ValueSerializer(v))?;
        }
        if let Some(v) = self.balance.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("balance", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Object {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "bcs",
            "object_id",
            "objectId",
            "version",
            "digest",
            "owner",
            "object_type",
            "objectType",
            "has_public_transfer",
            "hasPublicTransfer",
            "contents",
            "package",
            "previous_transaction",
            "previousTransaction",
            "storage_rebate",
            "storageRebate",
            "json",
            "balance",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Bcs,
            ObjectId,
            Version,
            Digest,
            Owner,
            ObjectType,
            HasPublicTransfer,
            Contents,
            Package,
            PreviousTransaction,
            StorageRebate,
            Json,
            Balance,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "bcs" => Ok(GeneratedField::Bcs),
                            "objectId" | "object_id" => Ok(GeneratedField::ObjectId),
                            "version" => Ok(GeneratedField::Version),
                            "digest" => Ok(GeneratedField::Digest),
                            "owner" => Ok(GeneratedField::Owner),
                            "objectType" | "object_type" => Ok(GeneratedField::ObjectType),
                            "hasPublicTransfer" | "has_public_transfer" => Ok(GeneratedField::HasPublicTransfer),
                            "contents" => Ok(GeneratedField::Contents),
                            "package" => Ok(GeneratedField::Package),
                            "previousTransaction" | "previous_transaction" => Ok(GeneratedField::PreviousTransaction),
                            "storageRebate" | "storage_rebate" => Ok(GeneratedField::StorageRebate),
                            "json" => Ok(GeneratedField::Json),
                            "balance" => Ok(GeneratedField::Balance),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Object;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.Object")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Object, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut bcs__ = None;
                let mut object_id__ = None;
                let mut version__ = None;
                let mut digest__ = None;
                let mut owner__ = None;
                let mut object_type__ = None;
                let mut has_public_transfer__ = None;
                let mut contents__ = None;
                let mut package__ = None;
                let mut previous_transaction__ = None;
                let mut storage_rebate__ = None;
                let mut json__ = None;
                let mut balance__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Bcs => {
                            if bcs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bcs"));
                            }
                            bcs__ = map_.next_value()?;
                        }
                        GeneratedField::ObjectId => {
                            if object_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objectId"));
                            }
                            object_id__ = map_.next_value()?;
                        }
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Digest => {
                            if digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("digest"));
                            }
                            digest__ = map_.next_value()?;
                        }
                        GeneratedField::Owner => {
                            if owner__.is_some() {
                                return Err(serde::de::Error::duplicate_field("owner"));
                            }
                            owner__ = map_.next_value()?;
                        }
                        GeneratedField::ObjectType => {
                            if object_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objectType"));
                            }
                            object_type__ = map_.next_value()?;
                        }
                        GeneratedField::HasPublicTransfer => {
                            if has_public_transfer__.is_some() {
                                return Err(serde::de::Error::duplicate_field("hasPublicTransfer"));
                            }
                            has_public_transfer__ = map_.next_value()?;
                        }
                        GeneratedField::Contents => {
                            if contents__.is_some() {
                                return Err(serde::de::Error::duplicate_field("contents"));
                            }
                            contents__ = map_.next_value()?;
                        }
                        GeneratedField::Package => {
                            if package__.is_some() {
                                return Err(serde::de::Error::duplicate_field("package"));
                            }
                            package__ = map_.next_value()?;
                        }
                        GeneratedField::PreviousTransaction => {
                            if previous_transaction__.is_some() {
                                return Err(serde::de::Error::duplicate_field("previousTransaction"));
                            }
                            previous_transaction__ = map_.next_value()?;
                        }
                        GeneratedField::StorageRebate => {
                            if storage_rebate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storageRebate"));
                            }
                            storage_rebate__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Json => {
                            if json__.is_some() {
                                return Err(serde::de::Error::duplicate_field("json"));
                            }
                            json__ = map_.next_value::<::std::option::Option<crate::_serde::ValueDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::Balance => {
                            if balance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("balance"));
                            }
                            balance__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Object {
                    bcs: bcs__,
                    object_id: object_id__,
                    version: version__,
                    digest: digest__,
                    owner: owner__,
                    object_type: object_type__,
                    has_public_transfer: has_public_transfer__,
                    contents: contents__,
                    package: package__,
                    previous_transaction: previous_transaction__,
                    storage_rebate: storage_rebate__,
                    json: json__,
                    balance: balance__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.Object", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ObjectReference {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.object_id.is_some() {
            len += 1;
        }
        if self.version.is_some() {
            len += 1;
        }
        if self.digest.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ObjectReference", len)?;
        if let Some(v) = self.object_id.as_ref() {
            struct_ser.serialize_field("objectId", v)?;
        }
        if let Some(v) = self.version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("version", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.digest.as_ref() {
            struct_ser.serialize_field("digest", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ObjectReference {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "object_id",
            "objectId",
            "version",
            "digest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ObjectId,
            Version,
            Digest,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "objectId" | "object_id" => Ok(GeneratedField::ObjectId),
                            "version" => Ok(GeneratedField::Version),
                            "digest" => Ok(GeneratedField::Digest),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ObjectReference;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ObjectReference")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ObjectReference, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut object_id__ = None;
                let mut version__ = None;
                let mut digest__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ObjectId => {
                            if object_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objectId"));
                            }
                            object_id__ = map_.next_value()?;
                        }
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Digest => {
                            if digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("digest"));
                            }
                            digest__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ObjectReference {
                    object_id: object_id__,
                    version: version__,
                    digest: digest__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ObjectReference", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for OpenSignature {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.reference.is_some() {
            len += 1;
        }
        if self.body.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.OpenSignature", len)?;
        if let Some(v) = self.reference.as_ref() {
            let v = open_signature::Reference::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("reference", &v)?;
        }
        if let Some(v) = self.body.as_ref() {
            struct_ser.serialize_field("body", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for OpenSignature {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "reference",
            "body",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Reference,
            Body,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "reference" => Ok(GeneratedField::Reference),
                            "body" => Ok(GeneratedField::Body),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = OpenSignature;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.OpenSignature")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<OpenSignature, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut reference__ = None;
                let mut body__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Reference => {
                            if reference__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reference"));
                            }
                            reference__ = map_.next_value::<::std::option::Option<open_signature::Reference>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Body => {
                            if body__.is_some() {
                                return Err(serde::de::Error::duplicate_field("body"));
                            }
                            body__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(OpenSignature {
                    reference: reference__,
                    body: body__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.OpenSignature", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for open_signature::Reference {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "REFERENCE_UNKNOWN",
            Self::Immutable => "IMMUTABLE",
            Self::Mutable => "MUTABLE",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for open_signature::Reference {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "REFERENCE_UNKNOWN",
            "IMMUTABLE",
            "MUTABLE",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = open_signature::Reference;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "REFERENCE_UNKNOWN" => Ok(open_signature::Reference::Unknown),
                    "IMMUTABLE" => Ok(open_signature::Reference::Immutable),
                    "MUTABLE" => Ok(open_signature::Reference::Mutable),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for OpenSignatureBody {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.r#type.is_some() {
            len += 1;
        }
        if self.type_name.is_some() {
            len += 1;
        }
        if !self.type_parameter_instantiation.is_empty() {
            len += 1;
        }
        if self.type_parameter.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.OpenSignatureBody", len)?;
        if let Some(v) = self.r#type.as_ref() {
            let v = open_signature_body::Type::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("type", &v)?;
        }
        if let Some(v) = self.type_name.as_ref() {
            struct_ser.serialize_field("typeName", v)?;
        }
        if !self.type_parameter_instantiation.is_empty() {
            struct_ser.serialize_field("typeParameterInstantiation", &self.type_parameter_instantiation)?;
        }
        if let Some(v) = self.type_parameter.as_ref() {
            struct_ser.serialize_field("typeParameter", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for OpenSignatureBody {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type",
            "type_name",
            "typeName",
            "type_parameter_instantiation",
            "typeParameterInstantiation",
            "type_parameter",
            "typeParameter",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Type,
            TypeName,
            TypeParameterInstantiation,
            TypeParameter,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "type" => Ok(GeneratedField::Type),
                            "typeName" | "type_name" => Ok(GeneratedField::TypeName),
                            "typeParameterInstantiation" | "type_parameter_instantiation" => Ok(GeneratedField::TypeParameterInstantiation),
                            "typeParameter" | "type_parameter" => Ok(GeneratedField::TypeParameter),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = OpenSignatureBody;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.OpenSignatureBody")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<OpenSignatureBody, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut r#type__ = None;
                let mut type_name__ = None;
                let mut type_parameter_instantiation__ = None;
                let mut type_parameter__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Type => {
                            if r#type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("type"));
                            }
                            r#type__ = map_.next_value::<::std::option::Option<open_signature_body::Type>>()?.map(|x| x as i32);
                        }
                        GeneratedField::TypeName => {
                            if type_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeName"));
                            }
                            type_name__ = map_.next_value()?;
                        }
                        GeneratedField::TypeParameterInstantiation => {
                            if type_parameter_instantiation__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeParameterInstantiation"));
                            }
                            type_parameter_instantiation__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TypeParameter => {
                            if type_parameter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeParameter"));
                            }
                            type_parameter__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(OpenSignatureBody {
                    r#type: r#type__,
                    type_name: type_name__,
                    type_parameter_instantiation: type_parameter_instantiation__.unwrap_or_default(),
                    type_parameter: type_parameter__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.OpenSignatureBody", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for open_signature_body::Type {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "TYPE_UNKNOWN",
            Self::Address => "ADDRESS",
            Self::Bool => "BOOL",
            Self::U8 => "U8",
            Self::U16 => "U16",
            Self::U32 => "U32",
            Self::U64 => "U64",
            Self::U128 => "U128",
            Self::U256 => "U256",
            Self::Vector => "VECTOR",
            Self::Datatype => "DATATYPE",
            Self::Parameter => "TYPE_PARAMETER",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for open_signature_body::Type {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TYPE_UNKNOWN",
            "ADDRESS",
            "BOOL",
            "U8",
            "U16",
            "U32",
            "U64",
            "U128",
            "U256",
            "VECTOR",
            "DATATYPE",
            "TYPE_PARAMETER",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = open_signature_body::Type;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "TYPE_UNKNOWN" => Ok(open_signature_body::Type::Unknown),
                    "ADDRESS" => Ok(open_signature_body::Type::Address),
                    "BOOL" => Ok(open_signature_body::Type::Bool),
                    "U8" => Ok(open_signature_body::Type::U8),
                    "U16" => Ok(open_signature_body::Type::U16),
                    "U32" => Ok(open_signature_body::Type::U32),
                    "U64" => Ok(open_signature_body::Type::U64),
                    "U128" => Ok(open_signature_body::Type::U128),
                    "U256" => Ok(open_signature_body::Type::U256),
                    "VECTOR" => Ok(open_signature_body::Type::Vector),
                    "DATATYPE" => Ok(open_signature_body::Type::Datatype),
                    "TYPE_PARAMETER" => Ok(open_signature_body::Type::Parameter),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Owner {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind.is_some() {
            len += 1;
        }
        if self.address.is_some() {
            len += 1;
        }
        if self.version.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.Owner", len)?;
        if let Some(v) = self.kind.as_ref() {
            let v = owner::OwnerKind::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if let Some(v) = self.address.as_ref() {
            struct_ser.serialize_field("address", v)?;
        }
        if let Some(v) = self.version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("version", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Owner {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kind",
            "address",
            "version",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Kind,
            Address,
            Version,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kind" => Ok(GeneratedField::Kind),
                            "address" => Ok(GeneratedField::Address),
                            "version" => Ok(GeneratedField::Version),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Owner;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.Owner")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Owner, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                let mut address__ = None;
                let mut version__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<owner::OwnerKind>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Address => {
                            if address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("address"));
                            }
                            address__ = map_.next_value()?;
                        }
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Owner {
                    kind: kind__,
                    address: address__,
                    version: version__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.Owner", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for owner::OwnerKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "OWNER_KIND_UNKNOWN",
            Self::Address => "ADDRESS",
            Self::Object => "OBJECT",
            Self::Shared => "SHARED",
            Self::Immutable => "IMMUTABLE",
            Self::ConsensusAddress => "CONSENSUS_ADDRESS",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for owner::OwnerKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "OWNER_KIND_UNKNOWN",
            "ADDRESS",
            "OBJECT",
            "SHARED",
            "IMMUTABLE",
            "CONSENSUS_ADDRESS",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = owner::OwnerKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "OWNER_KIND_UNKNOWN" => Ok(owner::OwnerKind::Unknown),
                    "ADDRESS" => Ok(owner::OwnerKind::Address),
                    "OBJECT" => Ok(owner::OwnerKind::Object),
                    "SHARED" => Ok(owner::OwnerKind::Shared),
                    "IMMUTABLE" => Ok(owner::OwnerKind::Immutable),
                    "CONSENSUS_ADDRESS" => Ok(owner::OwnerKind::ConsensusAddress),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Package {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.storage_id.is_some() {
            len += 1;
        }
        if self.original_id.is_some() {
            len += 1;
        }
        if self.version.is_some() {
            len += 1;
        }
        if !self.modules.is_empty() {
            len += 1;
        }
        if !self.type_origins.is_empty() {
            len += 1;
        }
        if !self.linkage.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.Package", len)?;
        if let Some(v) = self.storage_id.as_ref() {
            struct_ser.serialize_field("storageId", v)?;
        }
        if let Some(v) = self.original_id.as_ref() {
            struct_ser.serialize_field("originalId", v)?;
        }
        if let Some(v) = self.version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("version", ToString::to_string(&v).as_str())?;
        }
        if !self.modules.is_empty() {
            struct_ser.serialize_field("modules", &self.modules)?;
        }
        if !self.type_origins.is_empty() {
            struct_ser.serialize_field("typeOrigins", &self.type_origins)?;
        }
        if !self.linkage.is_empty() {
            struct_ser.serialize_field("linkage", &self.linkage)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Package {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "storage_id",
            "storageId",
            "original_id",
            "originalId",
            "version",
            "modules",
            "type_origins",
            "typeOrigins",
            "linkage",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            StorageId,
            OriginalId,
            Version,
            Modules,
            TypeOrigins,
            Linkage,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "storageId" | "storage_id" => Ok(GeneratedField::StorageId),
                            "originalId" | "original_id" => Ok(GeneratedField::OriginalId),
                            "version" => Ok(GeneratedField::Version),
                            "modules" => Ok(GeneratedField::Modules),
                            "typeOrigins" | "type_origins" => Ok(GeneratedField::TypeOrigins),
                            "linkage" => Ok(GeneratedField::Linkage),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Package;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.Package")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Package, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut storage_id__ = None;
                let mut original_id__ = None;
                let mut version__ = None;
                let mut modules__ = None;
                let mut type_origins__ = None;
                let mut linkage__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::StorageId => {
                            if storage_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storageId"));
                            }
                            storage_id__ = map_.next_value()?;
                        }
                        GeneratedField::OriginalId => {
                            if original_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("originalId"));
                            }
                            original_id__ = map_.next_value()?;
                        }
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Modules => {
                            if modules__.is_some() {
                                return Err(serde::de::Error::duplicate_field("modules"));
                            }
                            modules__ = Some(map_.next_value()?);
                        }
                        GeneratedField::TypeOrigins => {
                            if type_origins__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeOrigins"));
                            }
                            type_origins__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Linkage => {
                            if linkage__.is_some() {
                                return Err(serde::de::Error::duplicate_field("linkage"));
                            }
                            linkage__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Package {
                    storage_id: storage_id__,
                    original_id: original_id__,
                    version: version__,
                    modules: modules__.unwrap_or_default(),
                    type_origins: type_origins__.unwrap_or_default(),
                    linkage: linkage__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.Package", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PackageUpgradeError {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind.is_some() {
            len += 1;
        }
        if self.package_id.is_some() {
            len += 1;
        }
        if self.digest.is_some() {
            len += 1;
        }
        if self.policy.is_some() {
            len += 1;
        }
        if self.ticket_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.PackageUpgradeError", len)?;
        if let Some(v) = self.kind.as_ref() {
            let v = package_upgrade_error::PackageUpgradeErrorKind::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if let Some(v) = self.package_id.as_ref() {
            struct_ser.serialize_field("packageId", v)?;
        }
        if let Some(v) = self.digest.as_ref() {
            struct_ser.serialize_field("digest", v)?;
        }
        if let Some(v) = self.policy.as_ref() {
            struct_ser.serialize_field("policy", v)?;
        }
        if let Some(v) = self.ticket_id.as_ref() {
            struct_ser.serialize_field("ticketId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PackageUpgradeError {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kind",
            "package_id",
            "packageId",
            "digest",
            "policy",
            "ticket_id",
            "ticketId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Kind,
            PackageId,
            Digest,
            Policy,
            TicketId,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kind" => Ok(GeneratedField::Kind),
                            "packageId" | "package_id" => Ok(GeneratedField::PackageId),
                            "digest" => Ok(GeneratedField::Digest),
                            "policy" => Ok(GeneratedField::Policy),
                            "ticketId" | "ticket_id" => Ok(GeneratedField::TicketId),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PackageUpgradeError;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.PackageUpgradeError")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PackageUpgradeError, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                let mut package_id__ = None;
                let mut digest__ = None;
                let mut policy__ = None;
                let mut ticket_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<package_upgrade_error::PackageUpgradeErrorKind>>()?.map(|x| x as i32);
                        }
                        GeneratedField::PackageId => {
                            if package_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("packageId"));
                            }
                            package_id__ = map_.next_value()?;
                        }
                        GeneratedField::Digest => {
                            if digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("digest"));
                            }
                            digest__ = map_.next_value()?;
                        }
                        GeneratedField::Policy => {
                            if policy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("policy"));
                            }
                            policy__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::TicketId => {
                            if ticket_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ticketId"));
                            }
                            ticket_id__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PackageUpgradeError {
                    kind: kind__,
                    package_id: package_id__,
                    digest: digest__,
                    policy: policy__,
                    ticket_id: ticket_id__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.PackageUpgradeError", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for package_upgrade_error::PackageUpgradeErrorKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "PACKAGE_UPGRADE_ERROR_KIND_UNKNOWN",
            Self::UnableToFetchPackage => "UNABLE_TO_FETCH_PACKAGE",
            Self::NotAPackage => "NOT_A_PACKAGE",
            Self::IncompatibleUpgrade => "INCOMPATIBLE_UPGRADE",
            Self::DigestDoesNotMatch => "DIGEST_DOES_NOT_MATCH",
            Self::UnknownUpgradePolicy => "UNKNOWN_UPGRADE_POLICY",
            Self::PackageIdDoesNotMatch => "PACKAGE_ID_DOES_NOT_MATCH",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for package_upgrade_error::PackageUpgradeErrorKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "PACKAGE_UPGRADE_ERROR_KIND_UNKNOWN",
            "UNABLE_TO_FETCH_PACKAGE",
            "NOT_A_PACKAGE",
            "INCOMPATIBLE_UPGRADE",
            "DIGEST_DOES_NOT_MATCH",
            "UNKNOWN_UPGRADE_POLICY",
            "PACKAGE_ID_DOES_NOT_MATCH",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = package_upgrade_error::PackageUpgradeErrorKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "PACKAGE_UPGRADE_ERROR_KIND_UNKNOWN" => Ok(package_upgrade_error::PackageUpgradeErrorKind::Unknown),
                    "UNABLE_TO_FETCH_PACKAGE" => Ok(package_upgrade_error::PackageUpgradeErrorKind::UnableToFetchPackage),
                    "NOT_A_PACKAGE" => Ok(package_upgrade_error::PackageUpgradeErrorKind::NotAPackage),
                    "INCOMPATIBLE_UPGRADE" => Ok(package_upgrade_error::PackageUpgradeErrorKind::IncompatibleUpgrade),
                    "DIGEST_DOES_NOT_MATCH" => Ok(package_upgrade_error::PackageUpgradeErrorKind::DigestDoesNotMatch),
                    "UNKNOWN_UPGRADE_POLICY" => Ok(package_upgrade_error::PackageUpgradeErrorKind::UnknownUpgradePolicy),
                    "PACKAGE_ID_DOES_NOT_MATCH" => Ok(package_upgrade_error::PackageUpgradeErrorKind::PackageIdDoesNotMatch),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for PackageVersion {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.package_id.is_some() {
            len += 1;
        }
        if self.version.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.PackageVersion", len)?;
        if let Some(v) = self.package_id.as_ref() {
            struct_ser.serialize_field("packageId", v)?;
        }
        if let Some(v) = self.version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("version", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PackageVersion {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "package_id",
            "packageId",
            "version",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PackageId,
            Version,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "packageId" | "package_id" => Ok(GeneratedField::PackageId),
                            "version" => Ok(GeneratedField::Version),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PackageVersion;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.PackageVersion")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PackageVersion, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut package_id__ = None;
                let mut version__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PackageId => {
                            if package_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("packageId"));
                            }
                            package_id__ = map_.next_value()?;
                        }
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PackageVersion {
                    package_id: package_id__,
                    version: version__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.PackageVersion", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for PasskeyAuthenticator {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.authenticator_data.is_some() {
            len += 1;
        }
        if self.client_data_json.is_some() {
            len += 1;
        }
        if self.signature.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.PasskeyAuthenticator", len)?;
        if let Some(v) = self.authenticator_data.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("authenticatorData", crate::_serde::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.client_data_json.as_ref() {
            struct_ser.serialize_field("clientDataJson", v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            struct_ser.serialize_field("signature", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for PasskeyAuthenticator {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "authenticator_data",
            "authenticatorData",
            "client_data_json",
            "clientDataJson",
            "signature",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            AuthenticatorData,
            ClientDataJson,
            Signature,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "authenticatorData" | "authenticator_data" => Ok(GeneratedField::AuthenticatorData),
                            "clientDataJson" | "client_data_json" => Ok(GeneratedField::ClientDataJson),
                            "signature" => Ok(GeneratedField::Signature),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = PasskeyAuthenticator;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.PasskeyAuthenticator")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<PasskeyAuthenticator, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut authenticator_data__ = None;
                let mut client_data_json__ = None;
                let mut signature__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::AuthenticatorData => {
                            if authenticator_data__.is_some() {
                                return Err(serde::de::Error::duplicate_field("authenticatorData"));
                            }
                            authenticator_data__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ClientDataJson => {
                            if client_data_json__.is_some() {
                                return Err(serde::de::Error::duplicate_field("clientDataJson"));
                            }
                            client_data_json__ = map_.next_value()?;
                        }
                        GeneratedField::Signature => {
                            if signature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("signature"));
                            }
                            signature__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(PasskeyAuthenticator {
                    authenticator_data: authenticator_data__,
                    client_data_json: client_data_json__,
                    signature: signature__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.PasskeyAuthenticator", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ProgrammableTransaction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.inputs.is_empty() {
            len += 1;
        }
        if !self.commands.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ProgrammableTransaction", len)?;
        if !self.inputs.is_empty() {
            struct_ser.serialize_field("inputs", &self.inputs)?;
        }
        if !self.commands.is_empty() {
            struct_ser.serialize_field("commands", &self.commands)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProgrammableTransaction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "inputs",
            "commands",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Inputs,
            Commands,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "inputs" => Ok(GeneratedField::Inputs),
                            "commands" => Ok(GeneratedField::Commands),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProgrammableTransaction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ProgrammableTransaction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ProgrammableTransaction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut inputs__ = None;
                let mut commands__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Inputs => {
                            if inputs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inputs"));
                            }
                            inputs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Commands => {
                            if commands__.is_some() {
                                return Err(serde::de::Error::duplicate_field("commands"));
                            }
                            commands__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ProgrammableTransaction {
                    inputs: inputs__.unwrap_or_default(),
                    commands: commands__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ProgrammableTransaction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ProtocolConfig {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.protocol_version.is_some() {
            len += 1;
        }
        if !self.feature_flags.is_empty() {
            len += 1;
        }
        if !self.attributes.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ProtocolConfig", len)?;
        if let Some(v) = self.protocol_version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("protocolVersion", ToString::to_string(&v).as_str())?;
        }
        if !self.feature_flags.is_empty() {
            struct_ser.serialize_field("featureFlags", &self.feature_flags)?;
        }
        if !self.attributes.is_empty() {
            struct_ser.serialize_field("attributes", &self.attributes)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ProtocolConfig {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "protocol_version",
            "protocolVersion",
            "feature_flags",
            "featureFlags",
            "attributes",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ProtocolVersion,
            FeatureFlags,
            Attributes,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "protocolVersion" | "protocol_version" => Ok(GeneratedField::ProtocolVersion),
                            "featureFlags" | "feature_flags" => Ok(GeneratedField::FeatureFlags),
                            "attributes" => Ok(GeneratedField::Attributes),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ProtocolConfig;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ProtocolConfig")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ProtocolConfig, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut protocol_version__ = None;
                let mut feature_flags__ = None;
                let mut attributes__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ProtocolVersion => {
                            if protocol_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("protocolVersion"));
                            }
                            protocol_version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::FeatureFlags => {
                            if feature_flags__.is_some() {
                                return Err(serde::de::Error::duplicate_field("featureFlags"));
                            }
                            feature_flags__ = Some(
                                map_.next_value::<std::collections::BTreeMap<_, _>>()?
                            );
                        }
                        GeneratedField::Attributes => {
                            if attributes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("attributes"));
                            }
                            attributes__ = Some(
                                map_.next_value::<std::collections::BTreeMap<_, _>>()?
                            );
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ProtocolConfig {
                    protocol_version: protocol_version__,
                    feature_flags: feature_flags__.unwrap_or_default(),
                    attributes: attributes__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ProtocolConfig", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Publish {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.modules.is_empty() {
            len += 1;
        }
        if !self.dependencies.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.Publish", len)?;
        if !self.modules.is_empty() {
            struct_ser.serialize_field("modules", &self.modules.iter().map(crate::_serde::base64::encode).collect::<Vec<_>>())?;
        }
        if !self.dependencies.is_empty() {
            struct_ser.serialize_field("dependencies", &self.dependencies)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Publish {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "modules",
            "dependencies",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Modules,
            Dependencies,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "modules" => Ok(GeneratedField::Modules),
                            "dependencies" => Ok(GeneratedField::Dependencies),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Publish;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.Publish")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Publish, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut modules__ = None;
                let mut dependencies__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Modules => {
                            if modules__.is_some() {
                                return Err(serde::de::Error::duplicate_field("modules"));
                            }
                            modules__ = 
                                Some(map_.next_value::<Vec<crate::_serde::BytesDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::Dependencies => {
                            if dependencies__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dependencies"));
                            }
                            dependencies__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Publish {
                    modules: modules__.unwrap_or_default(),
                    dependencies: dependencies__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.Publish", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RandomnessStateUpdate {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.epoch.is_some() {
            len += 1;
        }
        if self.randomness_round.is_some() {
            len += 1;
        }
        if self.random_bytes.is_some() {
            len += 1;
        }
        if self.randomness_object_initial_shared_version.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.RandomnessStateUpdate", len)?;
        if let Some(v) = self.epoch.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("epoch", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.randomness_round.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("randomnessRound", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.random_bytes.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("randomBytes", crate::_serde::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.randomness_object_initial_shared_version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("randomnessObjectInitialSharedVersion", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RandomnessStateUpdate {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "epoch",
            "randomness_round",
            "randomnessRound",
            "random_bytes",
            "randomBytes",
            "randomness_object_initial_shared_version",
            "randomnessObjectInitialSharedVersion",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Epoch,
            RandomnessRound,
            RandomBytes,
            RandomnessObjectInitialSharedVersion,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "epoch" => Ok(GeneratedField::Epoch),
                            "randomnessRound" | "randomness_round" => Ok(GeneratedField::RandomnessRound),
                            "randomBytes" | "random_bytes" => Ok(GeneratedField::RandomBytes),
                            "randomnessObjectInitialSharedVersion" | "randomness_object_initial_shared_version" => Ok(GeneratedField::RandomnessObjectInitialSharedVersion),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RandomnessStateUpdate;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.RandomnessStateUpdate")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RandomnessStateUpdate, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut epoch__ = None;
                let mut randomness_round__ = None;
                let mut random_bytes__ = None;
                let mut randomness_object_initial_shared_version__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Epoch => {
                            if epoch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("epoch"));
                            }
                            epoch__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RandomnessRound => {
                            if randomness_round__.is_some() {
                                return Err(serde::de::Error::duplicate_field("randomnessRound"));
                            }
                            randomness_round__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RandomBytes => {
                            if random_bytes__.is_some() {
                                return Err(serde::de::Error::duplicate_field("randomBytes"));
                            }
                            random_bytes__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RandomnessObjectInitialSharedVersion => {
                            if randomness_object_initial_shared_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("randomnessObjectInitialSharedVersion"));
                            }
                            randomness_object_initial_shared_version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(RandomnessStateUpdate {
                    epoch: epoch__,
                    randomness_round: randomness_round__,
                    random_bytes: random_bytes__,
                    randomness_object_initial_shared_version: randomness_object_initial_shared_version__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.RandomnessStateUpdate", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for RegulatedCoinMetadata {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.coin_metadata_object.is_some() {
            len += 1;
        }
        if self.deny_cap_object.is_some() {
            len += 1;
        }
        if self.allow_global_pause.is_some() {
            len += 1;
        }
        if self.variant.is_some() {
            len += 1;
        }
        if self.coin_regulated_state.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.RegulatedCoinMetadata", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("id", v)?;
        }
        if let Some(v) = self.coin_metadata_object.as_ref() {
            struct_ser.serialize_field("coinMetadataObject", v)?;
        }
        if let Some(v) = self.deny_cap_object.as_ref() {
            struct_ser.serialize_field("denyCapObject", v)?;
        }
        if let Some(v) = self.allow_global_pause.as_ref() {
            struct_ser.serialize_field("allowGlobalPause", v)?;
        }
        if let Some(v) = self.variant.as_ref() {
            struct_ser.serialize_field("variant", v)?;
        }
        if let Some(v) = self.coin_regulated_state.as_ref() {
            let v = regulated_coin_metadata::CoinRegulatedState::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("coinRegulatedState", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for RegulatedCoinMetadata {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "coin_metadata_object",
            "coinMetadataObject",
            "deny_cap_object",
            "denyCapObject",
            "allow_global_pause",
            "allowGlobalPause",
            "variant",
            "coin_regulated_state",
            "coinRegulatedState",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            CoinMetadataObject,
            DenyCapObject,
            AllowGlobalPause,
            Variant,
            CoinRegulatedState,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "coinMetadataObject" | "coin_metadata_object" => Ok(GeneratedField::CoinMetadataObject),
                            "denyCapObject" | "deny_cap_object" => Ok(GeneratedField::DenyCapObject),
                            "allowGlobalPause" | "allow_global_pause" => Ok(GeneratedField::AllowGlobalPause),
                            "variant" => Ok(GeneratedField::Variant),
                            "coinRegulatedState" | "coin_regulated_state" => Ok(GeneratedField::CoinRegulatedState),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = RegulatedCoinMetadata;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.RegulatedCoinMetadata")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<RegulatedCoinMetadata, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut coin_metadata_object__ = None;
                let mut deny_cap_object__ = None;
                let mut allow_global_pause__ = None;
                let mut variant__ = None;
                let mut coin_regulated_state__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = map_.next_value()?;
                        }
                        GeneratedField::CoinMetadataObject => {
                            if coin_metadata_object__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coinMetadataObject"));
                            }
                            coin_metadata_object__ = map_.next_value()?;
                        }
                        GeneratedField::DenyCapObject => {
                            if deny_cap_object__.is_some() {
                                return Err(serde::de::Error::duplicate_field("denyCapObject"));
                            }
                            deny_cap_object__ = map_.next_value()?;
                        }
                        GeneratedField::AllowGlobalPause => {
                            if allow_global_pause__.is_some() {
                                return Err(serde::de::Error::duplicate_field("allowGlobalPause"));
                            }
                            allow_global_pause__ = map_.next_value()?;
                        }
                        GeneratedField::Variant => {
                            if variant__.is_some() {
                                return Err(serde::de::Error::duplicate_field("variant"));
                            }
                            variant__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CoinRegulatedState => {
                            if coin_regulated_state__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coinRegulatedState"));
                            }
                            coin_regulated_state__ = map_.next_value::<::std::option::Option<regulated_coin_metadata::CoinRegulatedState>>()?.map(|x| x as i32);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(RegulatedCoinMetadata {
                    id: id__,
                    coin_metadata_object: coin_metadata_object__,
                    deny_cap_object: deny_cap_object__,
                    allow_global_pause: allow_global_pause__,
                    variant: variant__,
                    coin_regulated_state: coin_regulated_state__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.RegulatedCoinMetadata", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for regulated_coin_metadata::CoinRegulatedState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "COIN_REGULATED_STATE_UNKNOWN",
            Self::Regulated => "REGULATED",
            Self::Unregulated => "UNREGULATED",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for regulated_coin_metadata::CoinRegulatedState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "COIN_REGULATED_STATE_UNKNOWN",
            "REGULATED",
            "UNREGULATED",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = regulated_coin_metadata::CoinRegulatedState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "COIN_REGULATED_STATE_UNKNOWN" => Ok(regulated_coin_metadata::CoinRegulatedState::Unknown),
                    "REGULATED" => Ok(regulated_coin_metadata::CoinRegulatedState::Regulated),
                    "UNREGULATED" => Ok(regulated_coin_metadata::CoinRegulatedState::Unregulated),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for ReverseLookupNameRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.address.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ReverseLookupNameRequest", len)?;
        if let Some(v) = self.address.as_ref() {
            struct_ser.serialize_field("address", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ReverseLookupNameRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "address",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Address,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "address" => Ok(GeneratedField::Address),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReverseLookupNameRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ReverseLookupNameRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ReverseLookupNameRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut address__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Address => {
                            if address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("address"));
                            }
                            address__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ReverseLookupNameRequest {
                    address: address__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ReverseLookupNameRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ReverseLookupNameResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.record.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ReverseLookupNameResponse", len)?;
        if let Some(v) = self.record.as_ref() {
            struct_ser.serialize_field("record", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ReverseLookupNameResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "record",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Record,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "record" => Ok(GeneratedField::Record),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ReverseLookupNameResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ReverseLookupNameResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ReverseLookupNameResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut record__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Record => {
                            if record__.is_some() {
                                return Err(serde::de::Error::duplicate_field("record"));
                            }
                            record__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ReverseLookupNameResponse {
                    record: record__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ReverseLookupNameResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SignatureScheme {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Ed25519 => "ED25519",
            Self::Secp256k1 => "SECP256K1",
            Self::Secp256r1 => "SECP256R1",
            Self::Multisig => "MULTISIG",
            Self::Bls12381 => "BLS12381",
            Self::Zklogin => "ZKLOGIN",
            Self::Passkey => "PASSKEY",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for SignatureScheme {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ED25519",
            "SECP256K1",
            "SECP256R1",
            "MULTISIG",
            "BLS12381",
            "ZKLOGIN",
            "PASSKEY",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SignatureScheme;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ED25519" => Ok(SignatureScheme::Ed25519),
                    "SECP256K1" => Ok(SignatureScheme::Secp256k1),
                    "SECP256R1" => Ok(SignatureScheme::Secp256r1),
                    "MULTISIG" => Ok(SignatureScheme::Multisig),
                    "BLS12381" => Ok(SignatureScheme::Bls12381),
                    "ZKLOGIN" => Ok(SignatureScheme::Zklogin),
                    "PASSKEY" => Ok(SignatureScheme::Passkey),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SimpleSignature {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.scheme.is_some() {
            len += 1;
        }
        if self.signature.is_some() {
            len += 1;
        }
        if self.public_key.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.SimpleSignature", len)?;
        if let Some(v) = self.scheme.as_ref() {
            let v = SignatureScheme::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("scheme", &v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("signature", crate::_serde::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.public_key.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("publicKey", crate::_serde::base64::encode(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SimpleSignature {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "scheme",
            "signature",
            "public_key",
            "publicKey",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Scheme,
            Signature,
            PublicKey,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "scheme" => Ok(GeneratedField::Scheme),
                            "signature" => Ok(GeneratedField::Signature),
                            "publicKey" | "public_key" => Ok(GeneratedField::PublicKey),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SimpleSignature;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.SimpleSignature")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SimpleSignature, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut scheme__ = None;
                let mut signature__ = None;
                let mut public_key__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Scheme => {
                            if scheme__.is_some() {
                                return Err(serde::de::Error::duplicate_field("scheme"));
                            }
                            scheme__ = map_.next_value::<::std::option::Option<SignatureScheme>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Signature => {
                            if signature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("signature"));
                            }
                            signature__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PublicKey => {
                            if public_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("publicKey"));
                            }
                            public_key__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(SimpleSignature {
                    scheme: scheme__,
                    signature: signature__,
                    public_key: public_key__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.SimpleSignature", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SimulateTransactionRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.transaction.is_some() {
            len += 1;
        }
        if self.read_mask.is_some() {
            len += 1;
        }
        if self.checks.is_some() {
            len += 1;
        }
        if self.do_gas_selection.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.SimulateTransactionRequest", len)?;
        if let Some(v) = self.transaction.as_ref() {
            struct_ser.serialize_field("transaction", v)?;
        }
        if let Some(v) = self.read_mask.as_ref() {
            struct_ser.serialize_field("readMask", &crate::_serde::FieldMaskSerializer(v))?;
        }
        if let Some(v) = self.checks.as_ref() {
            let v = simulate_transaction_request::TransactionChecks::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("checks", &v)?;
        }
        if let Some(v) = self.do_gas_selection.as_ref() {
            struct_ser.serialize_field("doGasSelection", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SimulateTransactionRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "transaction",
            "read_mask",
            "readMask",
            "checks",
            "do_gas_selection",
            "doGasSelection",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Transaction,
            ReadMask,
            Checks,
            DoGasSelection,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "transaction" => Ok(GeneratedField::Transaction),
                            "readMask" | "read_mask" => Ok(GeneratedField::ReadMask),
                            "checks" => Ok(GeneratedField::Checks),
                            "doGasSelection" | "do_gas_selection" => Ok(GeneratedField::DoGasSelection),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SimulateTransactionRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.SimulateTransactionRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SimulateTransactionRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut transaction__ = None;
                let mut read_mask__ = None;
                let mut checks__ = None;
                let mut do_gas_selection__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Transaction => {
                            if transaction__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transaction"));
                            }
                            transaction__ = map_.next_value()?;
                        }
                        GeneratedField::ReadMask => {
                            if read_mask__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readMask"));
                            }
                            read_mask__ = map_.next_value::<::std::option::Option<crate::_serde::FieldMaskDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::Checks => {
                            if checks__.is_some() {
                                return Err(serde::de::Error::duplicate_field("checks"));
                            }
                            checks__ = map_.next_value::<::std::option::Option<simulate_transaction_request::TransactionChecks>>()?.map(|x| x as i32);
                        }
                        GeneratedField::DoGasSelection => {
                            if do_gas_selection__.is_some() {
                                return Err(serde::de::Error::duplicate_field("doGasSelection"));
                            }
                            do_gas_selection__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(SimulateTransactionRequest {
                    transaction: transaction__,
                    read_mask: read_mask__,
                    checks: checks__,
                    do_gas_selection: do_gas_selection__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.SimulateTransactionRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for simulate_transaction_request::TransactionChecks {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Enabled => "ENABLED",
            Self::Disabled => "DISABLED",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for simulate_transaction_request::TransactionChecks {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "ENABLED",
            "DISABLED",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = simulate_transaction_request::TransactionChecks;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "ENABLED" => Ok(simulate_transaction_request::TransactionChecks::Enabled),
                    "DISABLED" => Ok(simulate_transaction_request::TransactionChecks::Disabled),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for SimulateTransactionResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.transaction.is_some() {
            len += 1;
        }
        if !self.outputs.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.SimulateTransactionResponse", len)?;
        if let Some(v) = self.transaction.as_ref() {
            struct_ser.serialize_field("transaction", v)?;
        }
        if !self.outputs.is_empty() {
            struct_ser.serialize_field("outputs", &self.outputs)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SimulateTransactionResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "transaction",
            "outputs",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Transaction,
            Outputs,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "transaction" => Ok(GeneratedField::Transaction),
                            "outputs" => Ok(GeneratedField::Outputs),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SimulateTransactionResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.SimulateTransactionResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SimulateTransactionResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut transaction__ = None;
                let mut outputs__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Transaction => {
                            if transaction__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transaction"));
                            }
                            transaction__ = map_.next_value()?;
                        }
                        GeneratedField::Outputs => {
                            if outputs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("outputs"));
                            }
                            outputs__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(SimulateTransactionResponse {
                    transaction: transaction__,
                    outputs: outputs__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.SimulateTransactionResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SizeError {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.size.is_some() {
            len += 1;
        }
        if self.max_size.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.SizeError", len)?;
        if let Some(v) = self.size.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("size", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.max_size.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("maxSize", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SizeError {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "size",
            "max_size",
            "maxSize",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Size,
            MaxSize,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "size" => Ok(GeneratedField::Size),
                            "maxSize" | "max_size" => Ok(GeneratedField::MaxSize),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SizeError;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.SizeError")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SizeError, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut size__ = None;
                let mut max_size__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Size => {
                            if size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("size"));
                            }
                            size__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MaxSize => {
                            if max_size__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxSize"));
                            }
                            max_size__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(SizeError {
                    size: size__,
                    max_size: max_size__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.SizeError", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SplitCoins {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.coin.is_some() {
            len += 1;
        }
        if !self.amounts.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.SplitCoins", len)?;
        if let Some(v) = self.coin.as_ref() {
            struct_ser.serialize_field("coin", v)?;
        }
        if !self.amounts.is_empty() {
            struct_ser.serialize_field("amounts", &self.amounts)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SplitCoins {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "coin",
            "amounts",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Coin,
            Amounts,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "coin" => Ok(GeneratedField::Coin),
                            "amounts" => Ok(GeneratedField::Amounts),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SplitCoins;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.SplitCoins")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SplitCoins, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut coin__ = None;
                let mut amounts__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Coin => {
                            if coin__.is_some() {
                                return Err(serde::de::Error::duplicate_field("coin"));
                            }
                            coin__ = map_.next_value()?;
                        }
                        GeneratedField::Amounts => {
                            if amounts__.is_some() {
                                return Err(serde::de::Error::duplicate_field("amounts"));
                            }
                            amounts__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(SplitCoins {
                    coin: coin__,
                    amounts: amounts__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.SplitCoins", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for StakeSubsidy {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.balance.is_some() {
            len += 1;
        }
        if self.distribution_counter.is_some() {
            len += 1;
        }
        if self.current_distribution_amount.is_some() {
            len += 1;
        }
        if self.stake_subsidy_period_length.is_some() {
            len += 1;
        }
        if self.stake_subsidy_decrease_rate.is_some() {
            len += 1;
        }
        if self.extra_fields.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.StakeSubsidy", len)?;
        if let Some(v) = self.balance.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("balance", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.distribution_counter.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("distributionCounter", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.current_distribution_amount.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("currentDistributionAmount", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.stake_subsidy_period_length.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("stakeSubsidyPeriodLength", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.stake_subsidy_decrease_rate.as_ref() {
            struct_ser.serialize_field("stakeSubsidyDecreaseRate", v)?;
        }
        if let Some(v) = self.extra_fields.as_ref() {
            struct_ser.serialize_field("extraFields", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for StakeSubsidy {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "balance",
            "distribution_counter",
            "distributionCounter",
            "current_distribution_amount",
            "currentDistributionAmount",
            "stake_subsidy_period_length",
            "stakeSubsidyPeriodLength",
            "stake_subsidy_decrease_rate",
            "stakeSubsidyDecreaseRate",
            "extra_fields",
            "extraFields",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Balance,
            DistributionCounter,
            CurrentDistributionAmount,
            StakeSubsidyPeriodLength,
            StakeSubsidyDecreaseRate,
            ExtraFields,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "balance" => Ok(GeneratedField::Balance),
                            "distributionCounter" | "distribution_counter" => Ok(GeneratedField::DistributionCounter),
                            "currentDistributionAmount" | "current_distribution_amount" => Ok(GeneratedField::CurrentDistributionAmount),
                            "stakeSubsidyPeriodLength" | "stake_subsidy_period_length" => Ok(GeneratedField::StakeSubsidyPeriodLength),
                            "stakeSubsidyDecreaseRate" | "stake_subsidy_decrease_rate" => Ok(GeneratedField::StakeSubsidyDecreaseRate),
                            "extraFields" | "extra_fields" => Ok(GeneratedField::ExtraFields),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = StakeSubsidy;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.StakeSubsidy")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<StakeSubsidy, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut balance__ = None;
                let mut distribution_counter__ = None;
                let mut current_distribution_amount__ = None;
                let mut stake_subsidy_period_length__ = None;
                let mut stake_subsidy_decrease_rate__ = None;
                let mut extra_fields__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Balance => {
                            if balance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("balance"));
                            }
                            balance__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DistributionCounter => {
                            if distribution_counter__.is_some() {
                                return Err(serde::de::Error::duplicate_field("distributionCounter"));
                            }
                            distribution_counter__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::CurrentDistributionAmount => {
                            if current_distribution_amount__.is_some() {
                                return Err(serde::de::Error::duplicate_field("currentDistributionAmount"));
                            }
                            current_distribution_amount__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StakeSubsidyPeriodLength => {
                            if stake_subsidy_period_length__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stakeSubsidyPeriodLength"));
                            }
                            stake_subsidy_period_length__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StakeSubsidyDecreaseRate => {
                            if stake_subsidy_decrease_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stakeSubsidyDecreaseRate"));
                            }
                            stake_subsidy_decrease_rate__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ExtraFields => {
                            if extra_fields__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extraFields"));
                            }
                            extra_fields__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(StakeSubsidy {
                    balance: balance__,
                    distribution_counter: distribution_counter__,
                    current_distribution_amount: current_distribution_amount__,
                    stake_subsidy_period_length: stake_subsidy_period_length__,
                    stake_subsidy_decrease_rate: stake_subsidy_decrease_rate__,
                    extra_fields: extra_fields__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.StakeSubsidy", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for StakingPool {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.id.is_some() {
            len += 1;
        }
        if self.activation_epoch.is_some() {
            len += 1;
        }
        if self.deactivation_epoch.is_some() {
            len += 1;
        }
        if self.sui_balance.is_some() {
            len += 1;
        }
        if self.rewards_pool.is_some() {
            len += 1;
        }
        if self.pool_token_balance.is_some() {
            len += 1;
        }
        if self.exchange_rates.is_some() {
            len += 1;
        }
        if self.pending_stake.is_some() {
            len += 1;
        }
        if self.pending_total_sui_withdraw.is_some() {
            len += 1;
        }
        if self.pending_pool_token_withdraw.is_some() {
            len += 1;
        }
        if self.extra_fields.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.StakingPool", len)?;
        if let Some(v) = self.id.as_ref() {
            struct_ser.serialize_field("id", v)?;
        }
        if let Some(v) = self.activation_epoch.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("activationEpoch", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.deactivation_epoch.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("deactivationEpoch", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.sui_balance.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("suiBalance", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.rewards_pool.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("rewardsPool", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.pool_token_balance.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("poolTokenBalance", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.exchange_rates.as_ref() {
            struct_ser.serialize_field("exchangeRates", v)?;
        }
        if let Some(v) = self.pending_stake.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("pendingStake", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.pending_total_sui_withdraw.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("pendingTotalSuiWithdraw", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.pending_pool_token_withdraw.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("pendingPoolTokenWithdraw", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.extra_fields.as_ref() {
            struct_ser.serialize_field("extraFields", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for StakingPool {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "id",
            "activation_epoch",
            "activationEpoch",
            "deactivation_epoch",
            "deactivationEpoch",
            "sui_balance",
            "suiBalance",
            "rewards_pool",
            "rewardsPool",
            "pool_token_balance",
            "poolTokenBalance",
            "exchange_rates",
            "exchangeRates",
            "pending_stake",
            "pendingStake",
            "pending_total_sui_withdraw",
            "pendingTotalSuiWithdraw",
            "pending_pool_token_withdraw",
            "pendingPoolTokenWithdraw",
            "extra_fields",
            "extraFields",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Id,
            ActivationEpoch,
            DeactivationEpoch,
            SuiBalance,
            RewardsPool,
            PoolTokenBalance,
            ExchangeRates,
            PendingStake,
            PendingTotalSuiWithdraw,
            PendingPoolTokenWithdraw,
            ExtraFields,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "id" => Ok(GeneratedField::Id),
                            "activationEpoch" | "activation_epoch" => Ok(GeneratedField::ActivationEpoch),
                            "deactivationEpoch" | "deactivation_epoch" => Ok(GeneratedField::DeactivationEpoch),
                            "suiBalance" | "sui_balance" => Ok(GeneratedField::SuiBalance),
                            "rewardsPool" | "rewards_pool" => Ok(GeneratedField::RewardsPool),
                            "poolTokenBalance" | "pool_token_balance" => Ok(GeneratedField::PoolTokenBalance),
                            "exchangeRates" | "exchange_rates" => Ok(GeneratedField::ExchangeRates),
                            "pendingStake" | "pending_stake" => Ok(GeneratedField::PendingStake),
                            "pendingTotalSuiWithdraw" | "pending_total_sui_withdraw" => Ok(GeneratedField::PendingTotalSuiWithdraw),
                            "pendingPoolTokenWithdraw" | "pending_pool_token_withdraw" => Ok(GeneratedField::PendingPoolTokenWithdraw),
                            "extraFields" | "extra_fields" => Ok(GeneratedField::ExtraFields),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = StakingPool;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.StakingPool")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<StakingPool, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut id__ = None;
                let mut activation_epoch__ = None;
                let mut deactivation_epoch__ = None;
                let mut sui_balance__ = None;
                let mut rewards_pool__ = None;
                let mut pool_token_balance__ = None;
                let mut exchange_rates__ = None;
                let mut pending_stake__ = None;
                let mut pending_total_sui_withdraw__ = None;
                let mut pending_pool_token_withdraw__ = None;
                let mut extra_fields__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Id => {
                            if id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("id"));
                            }
                            id__ = map_.next_value()?;
                        }
                        GeneratedField::ActivationEpoch => {
                            if activation_epoch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("activationEpoch"));
                            }
                            activation_epoch__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::DeactivationEpoch => {
                            if deactivation_epoch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("deactivationEpoch"));
                            }
                            deactivation_epoch__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SuiBalance => {
                            if sui_balance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("suiBalance"));
                            }
                            sui_balance__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::RewardsPool => {
                            if rewards_pool__.is_some() {
                                return Err(serde::de::Error::duplicate_field("rewardsPool"));
                            }
                            rewards_pool__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PoolTokenBalance => {
                            if pool_token_balance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("poolTokenBalance"));
                            }
                            pool_token_balance__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ExchangeRates => {
                            if exchange_rates__.is_some() {
                                return Err(serde::de::Error::duplicate_field("exchangeRates"));
                            }
                            exchange_rates__ = map_.next_value()?;
                        }
                        GeneratedField::PendingStake => {
                            if pending_stake__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pendingStake"));
                            }
                            pending_stake__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PendingTotalSuiWithdraw => {
                            if pending_total_sui_withdraw__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pendingTotalSuiWithdraw"));
                            }
                            pending_total_sui_withdraw__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::PendingPoolTokenWithdraw => {
                            if pending_pool_token_withdraw__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pendingPoolTokenWithdraw"));
                            }
                            pending_pool_token_withdraw__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ExtraFields => {
                            if extra_fields__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extraFields"));
                            }
                            extra_fields__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(StakingPool {
                    id: id__,
                    activation_epoch: activation_epoch__,
                    deactivation_epoch: deactivation_epoch__,
                    sui_balance: sui_balance__,
                    rewards_pool: rewards_pool__,
                    pool_token_balance: pool_token_balance__,
                    exchange_rates: exchange_rates__,
                    pending_stake: pending_stake__,
                    pending_total_sui_withdraw: pending_total_sui_withdraw__,
                    pending_pool_token_withdraw: pending_pool_token_withdraw__,
                    extra_fields: extra_fields__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.StakingPool", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for StorageFund {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.total_object_storage_rebates.is_some() {
            len += 1;
        }
        if self.non_refundable_balance.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.StorageFund", len)?;
        if let Some(v) = self.total_object_storage_rebates.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("totalObjectStorageRebates", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.non_refundable_balance.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("nonRefundableBalance", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for StorageFund {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "total_object_storage_rebates",
            "totalObjectStorageRebates",
            "non_refundable_balance",
            "nonRefundableBalance",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TotalObjectStorageRebates,
            NonRefundableBalance,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "totalObjectStorageRebates" | "total_object_storage_rebates" => Ok(GeneratedField::TotalObjectStorageRebates),
                            "nonRefundableBalance" | "non_refundable_balance" => Ok(GeneratedField::NonRefundableBalance),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = StorageFund;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.StorageFund")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<StorageFund, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut total_object_storage_rebates__ = None;
                let mut non_refundable_balance__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TotalObjectStorageRebates => {
                            if total_object_storage_rebates__.is_some() {
                                return Err(serde::de::Error::duplicate_field("totalObjectStorageRebates"));
                            }
                            total_object_storage_rebates__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NonRefundableBalance => {
                            if non_refundable_balance__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nonRefundableBalance"));
                            }
                            non_refundable_balance__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(StorageFund {
                    total_object_storage_rebates: total_object_storage_rebates__,
                    non_refundable_balance: non_refundable_balance__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.StorageFund", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SubscribeCheckpointsRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.read_mask.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.SubscribeCheckpointsRequest", len)?;
        if let Some(v) = self.read_mask.as_ref() {
            struct_ser.serialize_field("readMask", &crate::_serde::FieldMaskSerializer(v))?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SubscribeCheckpointsRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "read_mask",
            "readMask",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ReadMask,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "readMask" | "read_mask" => Ok(GeneratedField::ReadMask),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SubscribeCheckpointsRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.SubscribeCheckpointsRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SubscribeCheckpointsRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut read_mask__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ReadMask => {
                            if read_mask__.is_some() {
                                return Err(serde::de::Error::duplicate_field("readMask"));
                            }
                            read_mask__ = map_.next_value::<::std::option::Option<crate::_serde::FieldMaskDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(SubscribeCheckpointsRequest {
                    read_mask: read_mask__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.SubscribeCheckpointsRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SubscribeCheckpointsResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.cursor.is_some() {
            len += 1;
        }
        if self.checkpoint.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.SubscribeCheckpointsResponse", len)?;
        if let Some(v) = self.cursor.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("cursor", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.checkpoint.as_ref() {
            struct_ser.serialize_field("checkpoint", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SubscribeCheckpointsResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "cursor",
            "checkpoint",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Cursor,
            Checkpoint,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "cursor" => Ok(GeneratedField::Cursor),
                            "checkpoint" => Ok(GeneratedField::Checkpoint),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SubscribeCheckpointsResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.SubscribeCheckpointsResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SubscribeCheckpointsResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut cursor__ = None;
                let mut checkpoint__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Cursor => {
                            if cursor__.is_some() {
                                return Err(serde::de::Error::duplicate_field("cursor"));
                            }
                            cursor__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Checkpoint => {
                            if checkpoint__.is_some() {
                                return Err(serde::de::Error::duplicate_field("checkpoint"));
                            }
                            checkpoint__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(SubscribeCheckpointsResponse {
                    cursor: cursor__,
                    checkpoint: checkpoint__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.SubscribeCheckpointsResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SystemPackage {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.version.is_some() {
            len += 1;
        }
        if !self.modules.is_empty() {
            len += 1;
        }
        if !self.dependencies.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.SystemPackage", len)?;
        if let Some(v) = self.version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("version", ToString::to_string(&v).as_str())?;
        }
        if !self.modules.is_empty() {
            struct_ser.serialize_field("modules", &self.modules.iter().map(crate::_serde::base64::encode).collect::<Vec<_>>())?;
        }
        if !self.dependencies.is_empty() {
            struct_ser.serialize_field("dependencies", &self.dependencies)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SystemPackage {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "version",
            "modules",
            "dependencies",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Version,
            Modules,
            Dependencies,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "version" => Ok(GeneratedField::Version),
                            "modules" => Ok(GeneratedField::Modules),
                            "dependencies" => Ok(GeneratedField::Dependencies),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SystemPackage;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.SystemPackage")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SystemPackage, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut version__ = None;
                let mut modules__ = None;
                let mut dependencies__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Modules => {
                            if modules__.is_some() {
                                return Err(serde::de::Error::duplicate_field("modules"));
                            }
                            modules__ = 
                                Some(map_.next_value::<Vec<crate::_serde::BytesDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::Dependencies => {
                            if dependencies__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dependencies"));
                            }
                            dependencies__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(SystemPackage {
                    version: version__,
                    modules: modules__.unwrap_or_default(),
                    dependencies: dependencies__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.SystemPackage", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SystemParameters {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.epoch_duration_ms.is_some() {
            len += 1;
        }
        if self.stake_subsidy_start_epoch.is_some() {
            len += 1;
        }
        if self.min_validator_count.is_some() {
            len += 1;
        }
        if self.max_validator_count.is_some() {
            len += 1;
        }
        if self.min_validator_joining_stake.is_some() {
            len += 1;
        }
        if self.validator_low_stake_threshold.is_some() {
            len += 1;
        }
        if self.validator_very_low_stake_threshold.is_some() {
            len += 1;
        }
        if self.validator_low_stake_grace_period.is_some() {
            len += 1;
        }
        if self.extra_fields.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.SystemParameters", len)?;
        if let Some(v) = self.epoch_duration_ms.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("epochDurationMs", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.stake_subsidy_start_epoch.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("stakeSubsidyStartEpoch", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.min_validator_count.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("minValidatorCount", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.max_validator_count.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("maxValidatorCount", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.min_validator_joining_stake.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("minValidatorJoiningStake", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.validator_low_stake_threshold.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("validatorLowStakeThreshold", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.validator_very_low_stake_threshold.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("validatorVeryLowStakeThreshold", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.validator_low_stake_grace_period.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("validatorLowStakeGracePeriod", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.extra_fields.as_ref() {
            struct_ser.serialize_field("extraFields", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SystemParameters {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "epoch_duration_ms",
            "epochDurationMs",
            "stake_subsidy_start_epoch",
            "stakeSubsidyStartEpoch",
            "min_validator_count",
            "minValidatorCount",
            "max_validator_count",
            "maxValidatorCount",
            "min_validator_joining_stake",
            "minValidatorJoiningStake",
            "validator_low_stake_threshold",
            "validatorLowStakeThreshold",
            "validator_very_low_stake_threshold",
            "validatorVeryLowStakeThreshold",
            "validator_low_stake_grace_period",
            "validatorLowStakeGracePeriod",
            "extra_fields",
            "extraFields",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            EpochDurationMs,
            StakeSubsidyStartEpoch,
            MinValidatorCount,
            MaxValidatorCount,
            MinValidatorJoiningStake,
            ValidatorLowStakeThreshold,
            ValidatorVeryLowStakeThreshold,
            ValidatorLowStakeGracePeriod,
            ExtraFields,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "epochDurationMs" | "epoch_duration_ms" => Ok(GeneratedField::EpochDurationMs),
                            "stakeSubsidyStartEpoch" | "stake_subsidy_start_epoch" => Ok(GeneratedField::StakeSubsidyStartEpoch),
                            "minValidatorCount" | "min_validator_count" => Ok(GeneratedField::MinValidatorCount),
                            "maxValidatorCount" | "max_validator_count" => Ok(GeneratedField::MaxValidatorCount),
                            "minValidatorJoiningStake" | "min_validator_joining_stake" => Ok(GeneratedField::MinValidatorJoiningStake),
                            "validatorLowStakeThreshold" | "validator_low_stake_threshold" => Ok(GeneratedField::ValidatorLowStakeThreshold),
                            "validatorVeryLowStakeThreshold" | "validator_very_low_stake_threshold" => Ok(GeneratedField::ValidatorVeryLowStakeThreshold),
                            "validatorLowStakeGracePeriod" | "validator_low_stake_grace_period" => Ok(GeneratedField::ValidatorLowStakeGracePeriod),
                            "extraFields" | "extra_fields" => Ok(GeneratedField::ExtraFields),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SystemParameters;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.SystemParameters")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SystemParameters, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut epoch_duration_ms__ = None;
                let mut stake_subsidy_start_epoch__ = None;
                let mut min_validator_count__ = None;
                let mut max_validator_count__ = None;
                let mut min_validator_joining_stake__ = None;
                let mut validator_low_stake_threshold__ = None;
                let mut validator_very_low_stake_threshold__ = None;
                let mut validator_low_stake_grace_period__ = None;
                let mut extra_fields__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::EpochDurationMs => {
                            if epoch_duration_ms__.is_some() {
                                return Err(serde::de::Error::duplicate_field("epochDurationMs"));
                            }
                            epoch_duration_ms__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StakeSubsidyStartEpoch => {
                            if stake_subsidy_start_epoch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stakeSubsidyStartEpoch"));
                            }
                            stake_subsidy_start_epoch__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MinValidatorCount => {
                            if min_validator_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minValidatorCount"));
                            }
                            min_validator_count__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MaxValidatorCount => {
                            if max_validator_count__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxValidatorCount"));
                            }
                            max_validator_count__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::MinValidatorJoiningStake => {
                            if min_validator_joining_stake__.is_some() {
                                return Err(serde::de::Error::duplicate_field("minValidatorJoiningStake"));
                            }
                            min_validator_joining_stake__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ValidatorLowStakeThreshold => {
                            if validator_low_stake_threshold__.is_some() {
                                return Err(serde::de::Error::duplicate_field("validatorLowStakeThreshold"));
                            }
                            validator_low_stake_threshold__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ValidatorVeryLowStakeThreshold => {
                            if validator_very_low_stake_threshold__.is_some() {
                                return Err(serde::de::Error::duplicate_field("validatorVeryLowStakeThreshold"));
                            }
                            validator_very_low_stake_threshold__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ValidatorLowStakeGracePeriod => {
                            if validator_low_stake_grace_period__.is_some() {
                                return Err(serde::de::Error::duplicate_field("validatorLowStakeGracePeriod"));
                            }
                            validator_low_stake_grace_period__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ExtraFields => {
                            if extra_fields__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extraFields"));
                            }
                            extra_fields__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(SystemParameters {
                    epoch_duration_ms: epoch_duration_ms__,
                    stake_subsidy_start_epoch: stake_subsidy_start_epoch__,
                    min_validator_count: min_validator_count__,
                    max_validator_count: max_validator_count__,
                    min_validator_joining_stake: min_validator_joining_stake__,
                    validator_low_stake_threshold: validator_low_stake_threshold__,
                    validator_very_low_stake_threshold: validator_very_low_stake_threshold__,
                    validator_low_stake_grace_period: validator_low_stake_grace_period__,
                    extra_fields: extra_fields__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.SystemParameters", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for SystemState {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.version.is_some() {
            len += 1;
        }
        if self.epoch.is_some() {
            len += 1;
        }
        if self.protocol_version.is_some() {
            len += 1;
        }
        if self.validators.is_some() {
            len += 1;
        }
        if self.storage_fund.is_some() {
            len += 1;
        }
        if self.parameters.is_some() {
            len += 1;
        }
        if self.reference_gas_price.is_some() {
            len += 1;
        }
        if !self.validator_report_records.is_empty() {
            len += 1;
        }
        if self.stake_subsidy.is_some() {
            len += 1;
        }
        if self.safe_mode.is_some() {
            len += 1;
        }
        if self.safe_mode_storage_rewards.is_some() {
            len += 1;
        }
        if self.safe_mode_computation_rewards.is_some() {
            len += 1;
        }
        if self.safe_mode_storage_rebates.is_some() {
            len += 1;
        }
        if self.safe_mode_non_refundable_storage_fee.is_some() {
            len += 1;
        }
        if self.epoch_start_timestamp_ms.is_some() {
            len += 1;
        }
        if self.extra_fields.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.SystemState", len)?;
        if let Some(v) = self.version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("version", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.epoch.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("epoch", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.protocol_version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("protocolVersion", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.validators.as_ref() {
            struct_ser.serialize_field("validators", v)?;
        }
        if let Some(v) = self.storage_fund.as_ref() {
            struct_ser.serialize_field("storageFund", v)?;
        }
        if let Some(v) = self.parameters.as_ref() {
            struct_ser.serialize_field("parameters", v)?;
        }
        if let Some(v) = self.reference_gas_price.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("referenceGasPrice", ToString::to_string(&v).as_str())?;
        }
        if !self.validator_report_records.is_empty() {
            struct_ser.serialize_field("validatorReportRecords", &self.validator_report_records)?;
        }
        if let Some(v) = self.stake_subsidy.as_ref() {
            struct_ser.serialize_field("stakeSubsidy", v)?;
        }
        if let Some(v) = self.safe_mode.as_ref() {
            struct_ser.serialize_field("safeMode", v)?;
        }
        if let Some(v) = self.safe_mode_storage_rewards.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("safeModeStorageRewards", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.safe_mode_computation_rewards.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("safeModeComputationRewards", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.safe_mode_storage_rebates.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("safeModeStorageRebates", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.safe_mode_non_refundable_storage_fee.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("safeModeNonRefundableStorageFee", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.epoch_start_timestamp_ms.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("epochStartTimestampMs", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.extra_fields.as_ref() {
            struct_ser.serialize_field("extraFields", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for SystemState {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "version",
            "epoch",
            "protocol_version",
            "protocolVersion",
            "validators",
            "storage_fund",
            "storageFund",
            "parameters",
            "reference_gas_price",
            "referenceGasPrice",
            "validator_report_records",
            "validatorReportRecords",
            "stake_subsidy",
            "stakeSubsidy",
            "safe_mode",
            "safeMode",
            "safe_mode_storage_rewards",
            "safeModeStorageRewards",
            "safe_mode_computation_rewards",
            "safeModeComputationRewards",
            "safe_mode_storage_rebates",
            "safeModeStorageRebates",
            "safe_mode_non_refundable_storage_fee",
            "safeModeNonRefundableStorageFee",
            "epoch_start_timestamp_ms",
            "epochStartTimestampMs",
            "extra_fields",
            "extraFields",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Version,
            Epoch,
            ProtocolVersion,
            Validators,
            StorageFund,
            Parameters,
            ReferenceGasPrice,
            ValidatorReportRecords,
            StakeSubsidy,
            SafeMode,
            SafeModeStorageRewards,
            SafeModeComputationRewards,
            SafeModeStorageRebates,
            SafeModeNonRefundableStorageFee,
            EpochStartTimestampMs,
            ExtraFields,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "version" => Ok(GeneratedField::Version),
                            "epoch" => Ok(GeneratedField::Epoch),
                            "protocolVersion" | "protocol_version" => Ok(GeneratedField::ProtocolVersion),
                            "validators" => Ok(GeneratedField::Validators),
                            "storageFund" | "storage_fund" => Ok(GeneratedField::StorageFund),
                            "parameters" => Ok(GeneratedField::Parameters),
                            "referenceGasPrice" | "reference_gas_price" => Ok(GeneratedField::ReferenceGasPrice),
                            "validatorReportRecords" | "validator_report_records" => Ok(GeneratedField::ValidatorReportRecords),
                            "stakeSubsidy" | "stake_subsidy" => Ok(GeneratedField::StakeSubsidy),
                            "safeMode" | "safe_mode" => Ok(GeneratedField::SafeMode),
                            "safeModeStorageRewards" | "safe_mode_storage_rewards" => Ok(GeneratedField::SafeModeStorageRewards),
                            "safeModeComputationRewards" | "safe_mode_computation_rewards" => Ok(GeneratedField::SafeModeComputationRewards),
                            "safeModeStorageRebates" | "safe_mode_storage_rebates" => Ok(GeneratedField::SafeModeStorageRebates),
                            "safeModeNonRefundableStorageFee" | "safe_mode_non_refundable_storage_fee" => Ok(GeneratedField::SafeModeNonRefundableStorageFee),
                            "epochStartTimestampMs" | "epoch_start_timestamp_ms" => Ok(GeneratedField::EpochStartTimestampMs),
                            "extraFields" | "extra_fields" => Ok(GeneratedField::ExtraFields),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = SystemState;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.SystemState")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<SystemState, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut version__ = None;
                let mut epoch__ = None;
                let mut protocol_version__ = None;
                let mut validators__ = None;
                let mut storage_fund__ = None;
                let mut parameters__ = None;
                let mut reference_gas_price__ = None;
                let mut validator_report_records__ = None;
                let mut stake_subsidy__ = None;
                let mut safe_mode__ = None;
                let mut safe_mode_storage_rewards__ = None;
                let mut safe_mode_computation_rewards__ = None;
                let mut safe_mode_storage_rebates__ = None;
                let mut safe_mode_non_refundable_storage_fee__ = None;
                let mut epoch_start_timestamp_ms__ = None;
                let mut extra_fields__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Epoch => {
                            if epoch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("epoch"));
                            }
                            epoch__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ProtocolVersion => {
                            if protocol_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("protocolVersion"));
                            }
                            protocol_version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Validators => {
                            if validators__.is_some() {
                                return Err(serde::de::Error::duplicate_field("validators"));
                            }
                            validators__ = map_.next_value()?;
                        }
                        GeneratedField::StorageFund => {
                            if storage_fund__.is_some() {
                                return Err(serde::de::Error::duplicate_field("storageFund"));
                            }
                            storage_fund__ = map_.next_value()?;
                        }
                        GeneratedField::Parameters => {
                            if parameters__.is_some() {
                                return Err(serde::de::Error::duplicate_field("parameters"));
                            }
                            parameters__ = map_.next_value()?;
                        }
                        GeneratedField::ReferenceGasPrice => {
                            if reference_gas_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("referenceGasPrice"));
                            }
                            reference_gas_price__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ValidatorReportRecords => {
                            if validator_report_records__.is_some() {
                                return Err(serde::de::Error::duplicate_field("validatorReportRecords"));
                            }
                            validator_report_records__ = Some(map_.next_value()?);
                        }
                        GeneratedField::StakeSubsidy => {
                            if stake_subsidy__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stakeSubsidy"));
                            }
                            stake_subsidy__ = map_.next_value()?;
                        }
                        GeneratedField::SafeMode => {
                            if safe_mode__.is_some() {
                                return Err(serde::de::Error::duplicate_field("safeMode"));
                            }
                            safe_mode__ = map_.next_value()?;
                        }
                        GeneratedField::SafeModeStorageRewards => {
                            if safe_mode_storage_rewards__.is_some() {
                                return Err(serde::de::Error::duplicate_field("safeModeStorageRewards"));
                            }
                            safe_mode_storage_rewards__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SafeModeComputationRewards => {
                            if safe_mode_computation_rewards__.is_some() {
                                return Err(serde::de::Error::duplicate_field("safeModeComputationRewards"));
                            }
                            safe_mode_computation_rewards__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SafeModeStorageRebates => {
                            if safe_mode_storage_rebates__.is_some() {
                                return Err(serde::de::Error::duplicate_field("safeModeStorageRebates"));
                            }
                            safe_mode_storage_rebates__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::SafeModeNonRefundableStorageFee => {
                            if safe_mode_non_refundable_storage_fee__.is_some() {
                                return Err(serde::de::Error::duplicate_field("safeModeNonRefundableStorageFee"));
                            }
                            safe_mode_non_refundable_storage_fee__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::EpochStartTimestampMs => {
                            if epoch_start_timestamp_ms__.is_some() {
                                return Err(serde::de::Error::duplicate_field("epochStartTimestampMs"));
                            }
                            epoch_start_timestamp_ms__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ExtraFields => {
                            if extra_fields__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extraFields"));
                            }
                            extra_fields__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(SystemState {
                    version: version__,
                    epoch: epoch__,
                    protocol_version: protocol_version__,
                    validators: validators__,
                    storage_fund: storage_fund__,
                    parameters: parameters__,
                    reference_gas_price: reference_gas_price__,
                    validator_report_records: validator_report_records__.unwrap_or_default(),
                    stake_subsidy: stake_subsidy__,
                    safe_mode: safe_mode__,
                    safe_mode_storage_rewards: safe_mode_storage_rewards__,
                    safe_mode_computation_rewards: safe_mode_computation_rewards__,
                    safe_mode_storage_rebates: safe_mode_storage_rebates__,
                    safe_mode_non_refundable_storage_fee: safe_mode_non_refundable_storage_fee__,
                    epoch_start_timestamp_ms: epoch_start_timestamp_ms__,
                    extra_fields: extra_fields__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.SystemState", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Transaction {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.bcs.is_some() {
            len += 1;
        }
        if self.digest.is_some() {
            len += 1;
        }
        if self.version.is_some() {
            len += 1;
        }
        if self.kind.is_some() {
            len += 1;
        }
        if self.sender.is_some() {
            len += 1;
        }
        if self.gas_payment.is_some() {
            len += 1;
        }
        if self.expiration.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.Transaction", len)?;
        if let Some(v) = self.bcs.as_ref() {
            struct_ser.serialize_field("bcs", v)?;
        }
        if let Some(v) = self.digest.as_ref() {
            struct_ser.serialize_field("digest", v)?;
        }
        if let Some(v) = self.version.as_ref() {
            struct_ser.serialize_field("version", v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            struct_ser.serialize_field("kind", v)?;
        }
        if let Some(v) = self.sender.as_ref() {
            struct_ser.serialize_field("sender", v)?;
        }
        if let Some(v) = self.gas_payment.as_ref() {
            struct_ser.serialize_field("gasPayment", v)?;
        }
        if let Some(v) = self.expiration.as_ref() {
            struct_ser.serialize_field("expiration", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Transaction {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "bcs",
            "digest",
            "version",
            "kind",
            "sender",
            "gas_payment",
            "gasPayment",
            "expiration",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Bcs,
            Digest,
            Version,
            Kind,
            Sender,
            GasPayment,
            Expiration,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "bcs" => Ok(GeneratedField::Bcs),
                            "digest" => Ok(GeneratedField::Digest),
                            "version" => Ok(GeneratedField::Version),
                            "kind" => Ok(GeneratedField::Kind),
                            "sender" => Ok(GeneratedField::Sender),
                            "gasPayment" | "gas_payment" => Ok(GeneratedField::GasPayment),
                            "expiration" => Ok(GeneratedField::Expiration),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Transaction;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.Transaction")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Transaction, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut bcs__ = None;
                let mut digest__ = None;
                let mut version__ = None;
                let mut kind__ = None;
                let mut sender__ = None;
                let mut gas_payment__ = None;
                let mut expiration__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Bcs => {
                            if bcs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bcs"));
                            }
                            bcs__ = map_.next_value()?;
                        }
                        GeneratedField::Digest => {
                            if digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("digest"));
                            }
                            digest__ = map_.next_value()?;
                        }
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = map_.next_value()?;
                        }
                        GeneratedField::Sender => {
                            if sender__.is_some() {
                                return Err(serde::de::Error::duplicate_field("sender"));
                            }
                            sender__ = map_.next_value()?;
                        }
                        GeneratedField::GasPayment => {
                            if gas_payment__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gasPayment"));
                            }
                            gas_payment__ = map_.next_value()?;
                        }
                        GeneratedField::Expiration => {
                            if expiration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("expiration"));
                            }
                            expiration__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Transaction {
                    bcs: bcs__,
                    digest: digest__,
                    version: version__,
                    kind: kind__,
                    sender: sender__,
                    gas_payment: gas_payment__,
                    expiration: expiration__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.Transaction", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TransactionEffects {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.bcs.is_some() {
            len += 1;
        }
        if self.digest.is_some() {
            len += 1;
        }
        if self.version.is_some() {
            len += 1;
        }
        if self.status.is_some() {
            len += 1;
        }
        if self.epoch.is_some() {
            len += 1;
        }
        if self.gas_used.is_some() {
            len += 1;
        }
        if self.transaction_digest.is_some() {
            len += 1;
        }
        if self.gas_object.is_some() {
            len += 1;
        }
        if self.events_digest.is_some() {
            len += 1;
        }
        if !self.dependencies.is_empty() {
            len += 1;
        }
        if self.lamport_version.is_some() {
            len += 1;
        }
        if !self.changed_objects.is_empty() {
            len += 1;
        }
        if !self.unchanged_consensus_objects.is_empty() {
            len += 1;
        }
        if self.auxiliary_data_digest.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.TransactionEffects", len)?;
        if let Some(v) = self.bcs.as_ref() {
            struct_ser.serialize_field("bcs", v)?;
        }
        if let Some(v) = self.digest.as_ref() {
            struct_ser.serialize_field("digest", v)?;
        }
        if let Some(v) = self.version.as_ref() {
            struct_ser.serialize_field("version", v)?;
        }
        if let Some(v) = self.status.as_ref() {
            struct_ser.serialize_field("status", v)?;
        }
        if let Some(v) = self.epoch.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("epoch", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.gas_used.as_ref() {
            struct_ser.serialize_field("gasUsed", v)?;
        }
        if let Some(v) = self.transaction_digest.as_ref() {
            struct_ser.serialize_field("transactionDigest", v)?;
        }
        if let Some(v) = self.gas_object.as_ref() {
            struct_ser.serialize_field("gasObject", v)?;
        }
        if let Some(v) = self.events_digest.as_ref() {
            struct_ser.serialize_field("eventsDigest", v)?;
        }
        if !self.dependencies.is_empty() {
            struct_ser.serialize_field("dependencies", &self.dependencies)?;
        }
        if let Some(v) = self.lamport_version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("lamportVersion", ToString::to_string(&v).as_str())?;
        }
        if !self.changed_objects.is_empty() {
            struct_ser.serialize_field("changedObjects", &self.changed_objects)?;
        }
        if !self.unchanged_consensus_objects.is_empty() {
            struct_ser.serialize_field("unchangedConsensusObjects", &self.unchanged_consensus_objects)?;
        }
        if let Some(v) = self.auxiliary_data_digest.as_ref() {
            struct_ser.serialize_field("auxiliaryDataDigest", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TransactionEffects {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "bcs",
            "digest",
            "version",
            "status",
            "epoch",
            "gas_used",
            "gasUsed",
            "transaction_digest",
            "transactionDigest",
            "gas_object",
            "gasObject",
            "events_digest",
            "eventsDigest",
            "dependencies",
            "lamport_version",
            "lamportVersion",
            "changed_objects",
            "changedObjects",
            "unchanged_consensus_objects",
            "unchangedConsensusObjects",
            "auxiliary_data_digest",
            "auxiliaryDataDigest",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Bcs,
            Digest,
            Version,
            Status,
            Epoch,
            GasUsed,
            TransactionDigest,
            GasObject,
            EventsDigest,
            Dependencies,
            LamportVersion,
            ChangedObjects,
            UnchangedConsensusObjects,
            AuxiliaryDataDigest,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "bcs" => Ok(GeneratedField::Bcs),
                            "digest" => Ok(GeneratedField::Digest),
                            "version" => Ok(GeneratedField::Version),
                            "status" => Ok(GeneratedField::Status),
                            "epoch" => Ok(GeneratedField::Epoch),
                            "gasUsed" | "gas_used" => Ok(GeneratedField::GasUsed),
                            "transactionDigest" | "transaction_digest" => Ok(GeneratedField::TransactionDigest),
                            "gasObject" | "gas_object" => Ok(GeneratedField::GasObject),
                            "eventsDigest" | "events_digest" => Ok(GeneratedField::EventsDigest),
                            "dependencies" => Ok(GeneratedField::Dependencies),
                            "lamportVersion" | "lamport_version" => Ok(GeneratedField::LamportVersion),
                            "changedObjects" | "changed_objects" => Ok(GeneratedField::ChangedObjects),
                            "unchangedConsensusObjects" | "unchanged_consensus_objects" => Ok(GeneratedField::UnchangedConsensusObjects),
                            "auxiliaryDataDigest" | "auxiliary_data_digest" => Ok(GeneratedField::AuxiliaryDataDigest),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TransactionEffects;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.TransactionEffects")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TransactionEffects, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut bcs__ = None;
                let mut digest__ = None;
                let mut version__ = None;
                let mut status__ = None;
                let mut epoch__ = None;
                let mut gas_used__ = None;
                let mut transaction_digest__ = None;
                let mut gas_object__ = None;
                let mut events_digest__ = None;
                let mut dependencies__ = None;
                let mut lamport_version__ = None;
                let mut changed_objects__ = None;
                let mut unchanged_consensus_objects__ = None;
                let mut auxiliary_data_digest__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Bcs => {
                            if bcs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bcs"));
                            }
                            bcs__ = map_.next_value()?;
                        }
                        GeneratedField::Digest => {
                            if digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("digest"));
                            }
                            digest__ = map_.next_value()?;
                        }
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Status => {
                            if status__.is_some() {
                                return Err(serde::de::Error::duplicate_field("status"));
                            }
                            status__ = map_.next_value()?;
                        }
                        GeneratedField::Epoch => {
                            if epoch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("epoch"));
                            }
                            epoch__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::GasUsed => {
                            if gas_used__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gasUsed"));
                            }
                            gas_used__ = map_.next_value()?;
                        }
                        GeneratedField::TransactionDigest => {
                            if transaction_digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("transactionDigest"));
                            }
                            transaction_digest__ = map_.next_value()?;
                        }
                        GeneratedField::GasObject => {
                            if gas_object__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gasObject"));
                            }
                            gas_object__ = map_.next_value()?;
                        }
                        GeneratedField::EventsDigest => {
                            if events_digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("eventsDigest"));
                            }
                            events_digest__ = map_.next_value()?;
                        }
                        GeneratedField::Dependencies => {
                            if dependencies__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dependencies"));
                            }
                            dependencies__ = Some(map_.next_value()?);
                        }
                        GeneratedField::LamportVersion => {
                            if lamport_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("lamportVersion"));
                            }
                            lamport_version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ChangedObjects => {
                            if changed_objects__.is_some() {
                                return Err(serde::de::Error::duplicate_field("changedObjects"));
                            }
                            changed_objects__ = Some(map_.next_value()?);
                        }
                        GeneratedField::UnchangedConsensusObjects => {
                            if unchanged_consensus_objects__.is_some() {
                                return Err(serde::de::Error::duplicate_field("unchangedConsensusObjects"));
                            }
                            unchanged_consensus_objects__ = Some(map_.next_value()?);
                        }
                        GeneratedField::AuxiliaryDataDigest => {
                            if auxiliary_data_digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("auxiliaryDataDigest"));
                            }
                            auxiliary_data_digest__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(TransactionEffects {
                    bcs: bcs__,
                    digest: digest__,
                    version: version__,
                    status: status__,
                    epoch: epoch__,
                    gas_used: gas_used__,
                    transaction_digest: transaction_digest__,
                    gas_object: gas_object__,
                    events_digest: events_digest__,
                    dependencies: dependencies__.unwrap_or_default(),
                    lamport_version: lamport_version__,
                    changed_objects: changed_objects__.unwrap_or_default(),
                    unchanged_consensus_objects: unchanged_consensus_objects__.unwrap_or_default(),
                    auxiliary_data_digest: auxiliary_data_digest__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.TransactionEffects", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TransactionEvents {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.bcs.is_some() {
            len += 1;
        }
        if self.digest.is_some() {
            len += 1;
        }
        if !self.events.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.TransactionEvents", len)?;
        if let Some(v) = self.bcs.as_ref() {
            struct_ser.serialize_field("bcs", v)?;
        }
        if let Some(v) = self.digest.as_ref() {
            struct_ser.serialize_field("digest", v)?;
        }
        if !self.events.is_empty() {
            struct_ser.serialize_field("events", &self.events)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TransactionEvents {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "bcs",
            "digest",
            "events",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Bcs,
            Digest,
            Events,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "bcs" => Ok(GeneratedField::Bcs),
                            "digest" => Ok(GeneratedField::Digest),
                            "events" => Ok(GeneratedField::Events),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TransactionEvents;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.TransactionEvents")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TransactionEvents, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut bcs__ = None;
                let mut digest__ = None;
                let mut events__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Bcs => {
                            if bcs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bcs"));
                            }
                            bcs__ = map_.next_value()?;
                        }
                        GeneratedField::Digest => {
                            if digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("digest"));
                            }
                            digest__ = map_.next_value()?;
                        }
                        GeneratedField::Events => {
                            if events__.is_some() {
                                return Err(serde::de::Error::duplicate_field("events"));
                            }
                            events__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(TransactionEvents {
                    bcs: bcs__,
                    digest: digest__,
                    events: events__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.TransactionEvents", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TransactionExpiration {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind.is_some() {
            len += 1;
        }
        if self.epoch.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.TransactionExpiration", len)?;
        if let Some(v) = self.kind.as_ref() {
            let v = transaction_expiration::TransactionExpirationKind::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if let Some(v) = self.epoch.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("epoch", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TransactionExpiration {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kind",
            "epoch",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Kind,
            Epoch,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kind" => Ok(GeneratedField::Kind),
                            "epoch" => Ok(GeneratedField::Epoch),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TransactionExpiration;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.TransactionExpiration")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TransactionExpiration, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                let mut epoch__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<transaction_expiration::TransactionExpirationKind>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Epoch => {
                            if epoch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("epoch"));
                            }
                            epoch__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(TransactionExpiration {
                    kind: kind__,
                    epoch: epoch__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.TransactionExpiration", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for transaction_expiration::TransactionExpirationKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "TRANSACTION_EXPIRATION_KIND_UNKNOWN",
            Self::None => "NONE",
            Self::Epoch => "EPOCH",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for transaction_expiration::TransactionExpirationKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TRANSACTION_EXPIRATION_KIND_UNKNOWN",
            "NONE",
            "EPOCH",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = transaction_expiration::TransactionExpirationKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "TRANSACTION_EXPIRATION_KIND_UNKNOWN" => Ok(transaction_expiration::TransactionExpirationKind::Unknown),
                    "NONE" => Ok(transaction_expiration::TransactionExpirationKind::None),
                    "EPOCH" => Ok(transaction_expiration::TransactionExpirationKind::Epoch),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for TransactionFinality {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.finality.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.TransactionFinality", len)?;
        if let Some(v) = self.finality.as_ref() {
            match v {
                transaction_finality::Finality::Certified(v) => {
                    struct_ser.serialize_field("certified", v)?;
                }
                transaction_finality::Finality::Checkpointed(v) => {
                    #[allow(clippy::needless_borrow)]
                    #[allow(clippy::needless_borrows_for_generic_args)]
                    struct_ser.serialize_field("checkpointed", ToString::to_string(&v).as_str())?;
                }
                transaction_finality::Finality::QuorumExecuted(v) => {
                    struct_ser.serialize_field("quorumExecuted", &crate::_serde::EmptySerializer(v))?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TransactionFinality {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "certified",
            "checkpointed",
            "quorum_executed",
            "quorumExecuted",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Certified,
            Checkpointed,
            QuorumExecuted,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "certified" => Ok(GeneratedField::Certified),
                            "checkpointed" => Ok(GeneratedField::Checkpointed),
                            "quorumExecuted" | "quorum_executed" => Ok(GeneratedField::QuorumExecuted),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TransactionFinality;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.TransactionFinality")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TransactionFinality, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut finality__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Certified => {
                            if finality__.is_some() {
                                return Err(serde::de::Error::duplicate_field("certified"));
                            }
                            finality__ = map_.next_value::<::std::option::Option<_>>()?.map(transaction_finality::Finality::Certified)
;
                        }
                        GeneratedField::Checkpointed => {
                            if finality__.is_some() {
                                return Err(serde::de::Error::duplicate_field("checkpointed"));
                            }
                            finality__ = map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| transaction_finality::Finality::Checkpointed(x.0));
                        }
                        GeneratedField::QuorumExecuted => {
                            if finality__.is_some() {
                                return Err(serde::de::Error::duplicate_field("quorumExecuted"));
                            }
                            finality__ = map_.next_value::<::std::option::Option<crate::_serde::EmptyDeserializer>>()?.map(|x| transaction_finality::Finality::QuorumExecuted(x.0));
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(TransactionFinality {
                    finality: finality__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.TransactionFinality", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TransactionKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.TransactionKind", len)?;
        if let Some(v) = self.kind.as_ref() {
            match v {
                transaction_kind::Kind::ProgrammableTransaction(v) => {
                    struct_ser.serialize_field("programmableTransaction", v)?;
                }
                transaction_kind::Kind::ProgrammableSystemTransaction(v) => {
                    struct_ser.serialize_field("programmableSystemTransaction", v)?;
                }
                transaction_kind::Kind::ChangeEpoch(v) => {
                    struct_ser.serialize_field("changeEpoch", v)?;
                }
                transaction_kind::Kind::Genesis(v) => {
                    struct_ser.serialize_field("genesis", v)?;
                }
                transaction_kind::Kind::ConsensusCommitPrologueV1(v) => {
                    struct_ser.serialize_field("consensusCommitPrologueV1", v)?;
                }
                transaction_kind::Kind::AuthenticatorStateUpdate(v) => {
                    struct_ser.serialize_field("authenticatorStateUpdate", v)?;
                }
                transaction_kind::Kind::EndOfEpoch(v) => {
                    struct_ser.serialize_field("endOfEpoch", v)?;
                }
                transaction_kind::Kind::RandomnessStateUpdate(v) => {
                    struct_ser.serialize_field("randomnessStateUpdate", v)?;
                }
                transaction_kind::Kind::ConsensusCommitPrologueV2(v) => {
                    struct_ser.serialize_field("consensusCommitPrologueV2", v)?;
                }
                transaction_kind::Kind::ConsensusCommitPrologueV3(v) => {
                    struct_ser.serialize_field("consensusCommitPrologueV3", v)?;
                }
                transaction_kind::Kind::ConsensusCommitPrologueV4(v) => {
                    struct_ser.serialize_field("consensusCommitPrologueV4", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TransactionKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "programmable_transaction",
            "programmableTransaction",
            "programmable_system_transaction",
            "programmableSystemTransaction",
            "change_epoch",
            "changeEpoch",
            "genesis",
            "consensus_commit_prologue_v1",
            "consensusCommitPrologueV1",
            "authenticator_state_update",
            "authenticatorStateUpdate",
            "end_of_epoch",
            "endOfEpoch",
            "randomness_state_update",
            "randomnessStateUpdate",
            "consensus_commit_prologue_v2",
            "consensusCommitPrologueV2",
            "consensus_commit_prologue_v3",
            "consensusCommitPrologueV3",
            "consensus_commit_prologue_v4",
            "consensusCommitPrologueV4",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ProgrammableTransaction,
            ProgrammableSystemTransaction,
            ChangeEpoch,
            Genesis,
            ConsensusCommitPrologueV1,
            AuthenticatorStateUpdate,
            EndOfEpoch,
            RandomnessStateUpdate,
            ConsensusCommitPrologueV2,
            ConsensusCommitPrologueV3,
            ConsensusCommitPrologueV4,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "programmableTransaction" | "programmable_transaction" => Ok(GeneratedField::ProgrammableTransaction),
                            "programmableSystemTransaction" | "programmable_system_transaction" => Ok(GeneratedField::ProgrammableSystemTransaction),
                            "changeEpoch" | "change_epoch" => Ok(GeneratedField::ChangeEpoch),
                            "genesis" => Ok(GeneratedField::Genesis),
                            "consensusCommitPrologueV1" | "consensus_commit_prologue_v1" => Ok(GeneratedField::ConsensusCommitPrologueV1),
                            "authenticatorStateUpdate" | "authenticator_state_update" => Ok(GeneratedField::AuthenticatorStateUpdate),
                            "endOfEpoch" | "end_of_epoch" => Ok(GeneratedField::EndOfEpoch),
                            "randomnessStateUpdate" | "randomness_state_update" => Ok(GeneratedField::RandomnessStateUpdate),
                            "consensusCommitPrologueV2" | "consensus_commit_prologue_v2" => Ok(GeneratedField::ConsensusCommitPrologueV2),
                            "consensusCommitPrologueV3" | "consensus_commit_prologue_v3" => Ok(GeneratedField::ConsensusCommitPrologueV3),
                            "consensusCommitPrologueV4" | "consensus_commit_prologue_v4" => Ok(GeneratedField::ConsensusCommitPrologueV4),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TransactionKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.TransactionKind")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TransactionKind, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ProgrammableTransaction => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("programmableTransaction"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(transaction_kind::Kind::ProgrammableTransaction)
;
                        }
                        GeneratedField::ProgrammableSystemTransaction => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("programmableSystemTransaction"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(transaction_kind::Kind::ProgrammableSystemTransaction)
;
                        }
                        GeneratedField::ChangeEpoch => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("changeEpoch"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(transaction_kind::Kind::ChangeEpoch)
;
                        }
                        GeneratedField::Genesis => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("genesis"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(transaction_kind::Kind::Genesis)
;
                        }
                        GeneratedField::ConsensusCommitPrologueV1 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("consensusCommitPrologueV1"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(transaction_kind::Kind::ConsensusCommitPrologueV1)
;
                        }
                        GeneratedField::AuthenticatorStateUpdate => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("authenticatorStateUpdate"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(transaction_kind::Kind::AuthenticatorStateUpdate)
;
                        }
                        GeneratedField::EndOfEpoch => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("endOfEpoch"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(transaction_kind::Kind::EndOfEpoch)
;
                        }
                        GeneratedField::RandomnessStateUpdate => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("randomnessStateUpdate"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(transaction_kind::Kind::RandomnessStateUpdate)
;
                        }
                        GeneratedField::ConsensusCommitPrologueV2 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("consensusCommitPrologueV2"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(transaction_kind::Kind::ConsensusCommitPrologueV2)
;
                        }
                        GeneratedField::ConsensusCommitPrologueV3 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("consensusCommitPrologueV3"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(transaction_kind::Kind::ConsensusCommitPrologueV3)
;
                        }
                        GeneratedField::ConsensusCommitPrologueV4 => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("consensusCommitPrologueV4"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<_>>()?.map(transaction_kind::Kind::ConsensusCommitPrologueV4)
;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(TransactionKind {
                    kind: kind__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.TransactionKind", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TransferObjects {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.objects.is_empty() {
            len += 1;
        }
        if self.address.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.TransferObjects", len)?;
        if !self.objects.is_empty() {
            struct_ser.serialize_field("objects", &self.objects)?;
        }
        if let Some(v) = self.address.as_ref() {
            struct_ser.serialize_field("address", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TransferObjects {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "objects",
            "address",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Objects,
            Address,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "objects" => Ok(GeneratedField::Objects),
                            "address" => Ok(GeneratedField::Address),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TransferObjects;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.TransferObjects")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TransferObjects, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut objects__ = None;
                let mut address__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Objects => {
                            if objects__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objects"));
                            }
                            objects__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Address => {
                            if address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("address"));
                            }
                            address__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(TransferObjects {
                    objects: objects__.unwrap_or_default(),
                    address: address__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.TransferObjects", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TypeArgumentError {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.type_argument.is_some() {
            len += 1;
        }
        if self.kind.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.TypeArgumentError", len)?;
        if let Some(v) = self.type_argument.as_ref() {
            struct_ser.serialize_field("typeArgument", v)?;
        }
        if let Some(v) = self.kind.as_ref() {
            let v = type_argument_error::TypeArgumentErrorKind::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TypeArgumentError {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "type_argument",
            "typeArgument",
            "kind",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TypeArgument,
            Kind,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "typeArgument" | "type_argument" => Ok(GeneratedField::TypeArgument),
                            "kind" => Ok(GeneratedField::Kind),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TypeArgumentError;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.TypeArgumentError")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TypeArgumentError, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut type_argument__ = None;
                let mut kind__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TypeArgument => {
                            if type_argument__.is_some() {
                                return Err(serde::de::Error::duplicate_field("typeArgument"));
                            }
                            type_argument__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<type_argument_error::TypeArgumentErrorKind>>()?.map(|x| x as i32);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(TypeArgumentError {
                    type_argument: type_argument__,
                    kind: kind__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.TypeArgumentError", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for type_argument_error::TypeArgumentErrorKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "TYPE_ARGUMENT_ERROR_KIND_UNKNOWN",
            Self::TypeNotFound => "TYPE_NOT_FOUND",
            Self::ConstraintNotSatisfied => "CONSTRAINT_NOT_SATISFIED",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for type_argument_error::TypeArgumentErrorKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "TYPE_ARGUMENT_ERROR_KIND_UNKNOWN",
            "TYPE_NOT_FOUND",
            "CONSTRAINT_NOT_SATISFIED",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = type_argument_error::TypeArgumentErrorKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "TYPE_ARGUMENT_ERROR_KIND_UNKNOWN" => Ok(type_argument_error::TypeArgumentErrorKind::Unknown),
                    "TYPE_NOT_FOUND" => Ok(type_argument_error::TypeArgumentErrorKind::TypeNotFound),
                    "CONSTRAINT_NOT_SATISFIED" => Ok(type_argument_error::TypeArgumentErrorKind::ConstraintNotSatisfied),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for TypeOrigin {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.module_name.is_some() {
            len += 1;
        }
        if self.datatype_name.is_some() {
            len += 1;
        }
        if self.package_id.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.TypeOrigin", len)?;
        if let Some(v) = self.module_name.as_ref() {
            struct_ser.serialize_field("moduleName", v)?;
        }
        if let Some(v) = self.datatype_name.as_ref() {
            struct_ser.serialize_field("datatypeName", v)?;
        }
        if let Some(v) = self.package_id.as_ref() {
            struct_ser.serialize_field("packageId", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TypeOrigin {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "module_name",
            "moduleName",
            "datatype_name",
            "datatypeName",
            "package_id",
            "packageId",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ModuleName,
            DatatypeName,
            PackageId,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "moduleName" | "module_name" => Ok(GeneratedField::ModuleName),
                            "datatypeName" | "datatype_name" => Ok(GeneratedField::DatatypeName),
                            "packageId" | "package_id" => Ok(GeneratedField::PackageId),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TypeOrigin;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.TypeOrigin")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TypeOrigin, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut module_name__ = None;
                let mut datatype_name__ = None;
                let mut package_id__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ModuleName => {
                            if module_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("moduleName"));
                            }
                            module_name__ = map_.next_value()?;
                        }
                        GeneratedField::DatatypeName => {
                            if datatype_name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("datatypeName"));
                            }
                            datatype_name__ = map_.next_value()?;
                        }
                        GeneratedField::PackageId => {
                            if package_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("packageId"));
                            }
                            package_id__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(TypeOrigin {
                    module_name: module_name__,
                    datatype_name: datatype_name__,
                    package_id: package_id__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.TypeOrigin", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for TypeParameter {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.constraints.is_empty() {
            len += 1;
        }
        if self.is_phantom.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.TypeParameter", len)?;
        if !self.constraints.is_empty() {
            let v = self.constraints.iter().cloned().map(|v| {
                Ability::try_from(v)
                    .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", v)))
                }).collect::<std::result::Result<Vec<_>, _>>()?;
            struct_ser.serialize_field("constraints", &v)?;
        }
        if let Some(v) = self.is_phantom.as_ref() {
            struct_ser.serialize_field("isPhantom", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for TypeParameter {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "constraints",
            "is_phantom",
            "isPhantom",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Constraints,
            IsPhantom,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "constraints" => Ok(GeneratedField::Constraints),
                            "isPhantom" | "is_phantom" => Ok(GeneratedField::IsPhantom),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = TypeParameter;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.TypeParameter")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<TypeParameter, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut constraints__ = None;
                let mut is_phantom__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Constraints => {
                            if constraints__.is_some() {
                                return Err(serde::de::Error::duplicate_field("constraints"));
                            }
                            constraints__ = Some(map_.next_value::<Vec<Ability>>()?.into_iter().map(|x| x as i32).collect());
                        }
                        GeneratedField::IsPhantom => {
                            if is_phantom__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isPhantom"));
                            }
                            is_phantom__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(TypeParameter {
                    constraints: constraints__.unwrap_or_default(),
                    is_phantom: is_phantom__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.TypeParameter", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UnchangedConsensusObject {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.kind.is_some() {
            len += 1;
        }
        if self.object_id.is_some() {
            len += 1;
        }
        if self.version.is_some() {
            len += 1;
        }
        if self.digest.is_some() {
            len += 1;
        }
        if self.object_type.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.UnchangedConsensusObject", len)?;
        if let Some(v) = self.kind.as_ref() {
            let v = unchanged_consensus_object::UnchangedConsensusObjectKind::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("kind", &v)?;
        }
        if let Some(v) = self.object_id.as_ref() {
            struct_ser.serialize_field("objectId", v)?;
        }
        if let Some(v) = self.version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("version", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.digest.as_ref() {
            struct_ser.serialize_field("digest", v)?;
        }
        if let Some(v) = self.object_type.as_ref() {
            struct_ser.serialize_field("objectType", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UnchangedConsensusObject {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "kind",
            "object_id",
            "objectId",
            "version",
            "digest",
            "object_type",
            "objectType",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Kind,
            ObjectId,
            Version,
            Digest,
            ObjectType,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "kind" => Ok(GeneratedField::Kind),
                            "objectId" | "object_id" => Ok(GeneratedField::ObjectId),
                            "version" => Ok(GeneratedField::Version),
                            "digest" => Ok(GeneratedField::Digest),
                            "objectType" | "object_type" => Ok(GeneratedField::ObjectType),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UnchangedConsensusObject;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.UnchangedConsensusObject")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UnchangedConsensusObject, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut kind__ = None;
                let mut object_id__ = None;
                let mut version__ = None;
                let mut digest__ = None;
                let mut object_type__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Kind => {
                            if kind__.is_some() {
                                return Err(serde::de::Error::duplicate_field("kind"));
                            }
                            kind__ = map_.next_value::<::std::option::Option<unchanged_consensus_object::UnchangedConsensusObjectKind>>()?.map(|x| x as i32);
                        }
                        GeneratedField::ObjectId => {
                            if object_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objectId"));
                            }
                            object_id__ = map_.next_value()?;
                        }
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Digest => {
                            if digest__.is_some() {
                                return Err(serde::de::Error::duplicate_field("digest"));
                            }
                            digest__ = map_.next_value()?;
                        }
                        GeneratedField::ObjectType => {
                            if object_type__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objectType"));
                            }
                            object_type__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(UnchangedConsensusObject {
                    kind: kind__,
                    object_id: object_id__,
                    version: version__,
                    digest: digest__,
                    object_type: object_type__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.UnchangedConsensusObject", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for unchanged_consensus_object::UnchangedConsensusObjectKind {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let variant = match self {
            Self::Unknown => "UNCHANGED_CONSENSUS_OBJECT_KIND_UNKNOWN",
            Self::ReadOnlyRoot => "READ_ONLY_ROOT",
            Self::MutateConsensusStreamEnded => "MUTATE_CONSENSUS_STREAM_ENDED",
            Self::ReadConsensusStreamEnded => "READ_CONSENSUS_STREAM_ENDED",
            Self::Canceled => "CANCELED",
            Self::PerEpochConfig => "PER_EPOCH_CONFIG",
        };
        serializer.serialize_str(variant)
    }
}
impl<'de> serde::Deserialize<'de> for unchanged_consensus_object::UnchangedConsensusObjectKind {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "UNCHANGED_CONSENSUS_OBJECT_KIND_UNKNOWN",
            "READ_ONLY_ROOT",
            "MUTATE_CONSENSUS_STREAM_ENDED",
            "READ_CONSENSUS_STREAM_ENDED",
            "CANCELED",
            "PER_EPOCH_CONFIG",
        ];

        struct GeneratedVisitor;

        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = unchanged_consensus_object::UnchangedConsensusObjectKind;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                write!(formatter, "expected one of: {:?}", &FIELDS)
            }

            fn visit_i64<E>(self, v: i64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Signed(v), &self)
                    })
            }

            fn visit_u64<E>(self, v: u64) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                i32::try_from(v)
                    .ok()
                    .and_then(|x| x.try_into().ok())
                    .ok_or_else(|| {
                        serde::de::Error::invalid_value(serde::de::Unexpected::Unsigned(v), &self)
                    })
            }

            fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                match value {
                    "UNCHANGED_CONSENSUS_OBJECT_KIND_UNKNOWN" => Ok(unchanged_consensus_object::UnchangedConsensusObjectKind::Unknown),
                    "READ_ONLY_ROOT" => Ok(unchanged_consensus_object::UnchangedConsensusObjectKind::ReadOnlyRoot),
                    "MUTATE_CONSENSUS_STREAM_ENDED" => Ok(unchanged_consensus_object::UnchangedConsensusObjectKind::MutateConsensusStreamEnded),
                    "READ_CONSENSUS_STREAM_ENDED" => Ok(unchanged_consensus_object::UnchangedConsensusObjectKind::ReadConsensusStreamEnded),
                    "CANCELED" => Ok(unchanged_consensus_object::UnchangedConsensusObjectKind::Canceled),
                    "PER_EPOCH_CONFIG" => Ok(unchanged_consensus_object::UnchangedConsensusObjectKind::PerEpochConfig),
                    _ => Err(serde::de::Error::unknown_variant(value, FIELDS)),
                }
            }
        }
        deserializer.deserialize_any(GeneratedVisitor)
    }
}
impl serde::Serialize for Upgrade {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if !self.modules.is_empty() {
            len += 1;
        }
        if !self.dependencies.is_empty() {
            len += 1;
        }
        if self.package.is_some() {
            len += 1;
        }
        if self.ticket.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.Upgrade", len)?;
        if !self.modules.is_empty() {
            struct_ser.serialize_field("modules", &self.modules.iter().map(crate::_serde::base64::encode).collect::<Vec<_>>())?;
        }
        if !self.dependencies.is_empty() {
            struct_ser.serialize_field("dependencies", &self.dependencies)?;
        }
        if let Some(v) = self.package.as_ref() {
            struct_ser.serialize_field("package", v)?;
        }
        if let Some(v) = self.ticket.as_ref() {
            struct_ser.serialize_field("ticket", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Upgrade {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "modules",
            "dependencies",
            "package",
            "ticket",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Modules,
            Dependencies,
            Package,
            Ticket,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "modules" => Ok(GeneratedField::Modules),
                            "dependencies" => Ok(GeneratedField::Dependencies),
                            "package" => Ok(GeneratedField::Package),
                            "ticket" => Ok(GeneratedField::Ticket),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Upgrade;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.Upgrade")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Upgrade, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut modules__ = None;
                let mut dependencies__ = None;
                let mut package__ = None;
                let mut ticket__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Modules => {
                            if modules__.is_some() {
                                return Err(serde::de::Error::duplicate_field("modules"));
                            }
                            modules__ = 
                                Some(map_.next_value::<Vec<crate::_serde::BytesDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::Dependencies => {
                            if dependencies__.is_some() {
                                return Err(serde::de::Error::duplicate_field("dependencies"));
                            }
                            dependencies__ = Some(map_.next_value()?);
                        }
                        GeneratedField::Package => {
                            if package__.is_some() {
                                return Err(serde::de::Error::duplicate_field("package"));
                            }
                            package__ = map_.next_value()?;
                        }
                        GeneratedField::Ticket => {
                            if ticket__.is_some() {
                                return Err(serde::de::Error::duplicate_field("ticket"));
                            }
                            ticket__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Upgrade {
                    modules: modules__.unwrap_or_default(),
                    dependencies: dependencies__.unwrap_or_default(),
                    package: package__,
                    ticket: ticket__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.Upgrade", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for UserSignature {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.bcs.is_some() {
            len += 1;
        }
        if self.scheme.is_some() {
            len += 1;
        }
        if self.signature.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.UserSignature", len)?;
        if let Some(v) = self.bcs.as_ref() {
            struct_ser.serialize_field("bcs", v)?;
        }
        if let Some(v) = self.scheme.as_ref() {
            let v = SignatureScheme::try_from(*v)
                .map_err(|_| serde::ser::Error::custom(format!("Invalid variant {}", *v)))?;
            struct_ser.serialize_field("scheme", &v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            match v {
                user_signature::Signature::Simple(v) => {
                    struct_ser.serialize_field("simple", v)?;
                }
                user_signature::Signature::Multisig(v) => {
                    struct_ser.serialize_field("multisig", v)?;
                }
                user_signature::Signature::Zklogin(v) => {
                    struct_ser.serialize_field("zklogin", v)?;
                }
                user_signature::Signature::Passkey(v) => {
                    struct_ser.serialize_field("passkey", v)?;
                }
            }
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for UserSignature {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "bcs",
            "scheme",
            "simple",
            "multisig",
            "zklogin",
            "passkey",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Bcs,
            Scheme,
            Simple,
            Multisig,
            Zklogin,
            Passkey,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "bcs" => Ok(GeneratedField::Bcs),
                            "scheme" => Ok(GeneratedField::Scheme),
                            "simple" => Ok(GeneratedField::Simple),
                            "multisig" => Ok(GeneratedField::Multisig),
                            "zklogin" => Ok(GeneratedField::Zklogin),
                            "passkey" => Ok(GeneratedField::Passkey),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = UserSignature;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.UserSignature")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<UserSignature, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut bcs__ = None;
                let mut scheme__ = None;
                let mut signature__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Bcs => {
                            if bcs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bcs"));
                            }
                            bcs__ = map_.next_value()?;
                        }
                        GeneratedField::Scheme => {
                            if scheme__.is_some() {
                                return Err(serde::de::Error::duplicate_field("scheme"));
                            }
                            scheme__ = map_.next_value::<::std::option::Option<SignatureScheme>>()?.map(|x| x as i32);
                        }
                        GeneratedField::Simple => {
                            if signature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("simple"));
                            }
                            signature__ = map_.next_value::<::std::option::Option<_>>()?.map(user_signature::Signature::Simple)
;
                        }
                        GeneratedField::Multisig => {
                            if signature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("multisig"));
                            }
                            signature__ = map_.next_value::<::std::option::Option<_>>()?.map(user_signature::Signature::Multisig)
;
                        }
                        GeneratedField::Zklogin => {
                            if signature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("zklogin"));
                            }
                            signature__ = map_.next_value::<::std::option::Option<_>>()?.map(user_signature::Signature::Zklogin)
;
                        }
                        GeneratedField::Passkey => {
                            if signature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("passkey"));
                            }
                            signature__ = map_.next_value::<::std::option::Option<_>>()?.map(user_signature::Signature::Passkey)
;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(UserSignature {
                    bcs: bcs__,
                    scheme: scheme__,
                    signature: signature__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.UserSignature", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for Validator {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.address.is_some() {
            len += 1;
        }
        if self.description.is_some() {
            len += 1;
        }
        if self.image_url.is_some() {
            len += 1;
        }
        if self.project_url.is_some() {
            len += 1;
        }
        if self.protocol_public_key.is_some() {
            len += 1;
        }
        if self.proof_of_possession.is_some() {
            len += 1;
        }
        if self.network_public_key.is_some() {
            len += 1;
        }
        if self.worker_public_key.is_some() {
            len += 1;
        }
        if self.network_address.is_some() {
            len += 1;
        }
        if self.p2p_address.is_some() {
            len += 1;
        }
        if self.primary_address.is_some() {
            len += 1;
        }
        if self.worker_address.is_some() {
            len += 1;
        }
        if self.next_epoch_protocol_public_key.is_some() {
            len += 1;
        }
        if self.next_epoch_proof_of_possession.is_some() {
            len += 1;
        }
        if self.next_epoch_network_public_key.is_some() {
            len += 1;
        }
        if self.next_epoch_worker_public_key.is_some() {
            len += 1;
        }
        if self.next_epoch_network_address.is_some() {
            len += 1;
        }
        if self.next_epoch_p2p_address.is_some() {
            len += 1;
        }
        if self.next_epoch_primary_address.is_some() {
            len += 1;
        }
        if self.next_epoch_worker_address.is_some() {
            len += 1;
        }
        if self.metadata_extra_fields.is_some() {
            len += 1;
        }
        if self.voting_power.is_some() {
            len += 1;
        }
        if self.operation_cap_id.is_some() {
            len += 1;
        }
        if self.gas_price.is_some() {
            len += 1;
        }
        if self.staking_pool.is_some() {
            len += 1;
        }
        if self.commission_rate.is_some() {
            len += 1;
        }
        if self.next_epoch_stake.is_some() {
            len += 1;
        }
        if self.next_epoch_gas_price.is_some() {
            len += 1;
        }
        if self.next_epoch_commission_rate.is_some() {
            len += 1;
        }
        if self.extra_fields.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.Validator", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.address.as_ref() {
            struct_ser.serialize_field("address", v)?;
        }
        if let Some(v) = self.description.as_ref() {
            struct_ser.serialize_field("description", v)?;
        }
        if let Some(v) = self.image_url.as_ref() {
            struct_ser.serialize_field("imageUrl", v)?;
        }
        if let Some(v) = self.project_url.as_ref() {
            struct_ser.serialize_field("projectUrl", v)?;
        }
        if let Some(v) = self.protocol_public_key.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("protocolPublicKey", crate::_serde::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.proof_of_possession.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("proofOfPossession", crate::_serde::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.network_public_key.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("networkPublicKey", crate::_serde::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.worker_public_key.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("workerPublicKey", crate::_serde::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.network_address.as_ref() {
            struct_ser.serialize_field("networkAddress", v)?;
        }
        if let Some(v) = self.p2p_address.as_ref() {
            struct_ser.serialize_field("p2pAddress", v)?;
        }
        if let Some(v) = self.primary_address.as_ref() {
            struct_ser.serialize_field("primaryAddress", v)?;
        }
        if let Some(v) = self.worker_address.as_ref() {
            struct_ser.serialize_field("workerAddress", v)?;
        }
        if let Some(v) = self.next_epoch_protocol_public_key.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("nextEpochProtocolPublicKey", crate::_serde::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.next_epoch_proof_of_possession.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("nextEpochProofOfPossession", crate::_serde::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.next_epoch_network_public_key.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("nextEpochNetworkPublicKey", crate::_serde::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.next_epoch_worker_public_key.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("nextEpochWorkerPublicKey", crate::_serde::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.next_epoch_network_address.as_ref() {
            struct_ser.serialize_field("nextEpochNetworkAddress", v)?;
        }
        if let Some(v) = self.next_epoch_p2p_address.as_ref() {
            struct_ser.serialize_field("nextEpochP2pAddress", v)?;
        }
        if let Some(v) = self.next_epoch_primary_address.as_ref() {
            struct_ser.serialize_field("nextEpochPrimaryAddress", v)?;
        }
        if let Some(v) = self.next_epoch_worker_address.as_ref() {
            struct_ser.serialize_field("nextEpochWorkerAddress", v)?;
        }
        if let Some(v) = self.metadata_extra_fields.as_ref() {
            struct_ser.serialize_field("metadataExtraFields", v)?;
        }
        if let Some(v) = self.voting_power.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("votingPower", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.operation_cap_id.as_ref() {
            struct_ser.serialize_field("operationCapId", v)?;
        }
        if let Some(v) = self.gas_price.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("gasPrice", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.staking_pool.as_ref() {
            struct_ser.serialize_field("stakingPool", v)?;
        }
        if let Some(v) = self.commission_rate.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("commissionRate", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.next_epoch_stake.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("nextEpochStake", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.next_epoch_gas_price.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("nextEpochGasPrice", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.next_epoch_commission_rate.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("nextEpochCommissionRate", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.extra_fields.as_ref() {
            struct_ser.serialize_field("extraFields", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for Validator {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "address",
            "description",
            "image_url",
            "imageUrl",
            "project_url",
            "projectUrl",
            "protocol_public_key",
            "protocolPublicKey",
            "proof_of_possession",
            "proofOfPossession",
            "network_public_key",
            "networkPublicKey",
            "worker_public_key",
            "workerPublicKey",
            "network_address",
            "networkAddress",
            "p2p_address",
            "p2pAddress",
            "primary_address",
            "primaryAddress",
            "worker_address",
            "workerAddress",
            "next_epoch_protocol_public_key",
            "nextEpochProtocolPublicKey",
            "next_epoch_proof_of_possession",
            "nextEpochProofOfPossession",
            "next_epoch_network_public_key",
            "nextEpochNetworkPublicKey",
            "next_epoch_worker_public_key",
            "nextEpochWorkerPublicKey",
            "next_epoch_network_address",
            "nextEpochNetworkAddress",
            "next_epoch_p2p_address",
            "nextEpochP2pAddress",
            "next_epoch_primary_address",
            "nextEpochPrimaryAddress",
            "next_epoch_worker_address",
            "nextEpochWorkerAddress",
            "metadata_extra_fields",
            "metadataExtraFields",
            "voting_power",
            "votingPower",
            "operation_cap_id",
            "operationCapId",
            "gas_price",
            "gasPrice",
            "staking_pool",
            "stakingPool",
            "commission_rate",
            "commissionRate",
            "next_epoch_stake",
            "nextEpochStake",
            "next_epoch_gas_price",
            "nextEpochGasPrice",
            "next_epoch_commission_rate",
            "nextEpochCommissionRate",
            "extra_fields",
            "extraFields",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Address,
            Description,
            ImageUrl,
            ProjectUrl,
            ProtocolPublicKey,
            ProofOfPossession,
            NetworkPublicKey,
            WorkerPublicKey,
            NetworkAddress,
            P2pAddress,
            PrimaryAddress,
            WorkerAddress,
            NextEpochProtocolPublicKey,
            NextEpochProofOfPossession,
            NextEpochNetworkPublicKey,
            NextEpochWorkerPublicKey,
            NextEpochNetworkAddress,
            NextEpochP2pAddress,
            NextEpochPrimaryAddress,
            NextEpochWorkerAddress,
            MetadataExtraFields,
            VotingPower,
            OperationCapId,
            GasPrice,
            StakingPool,
            CommissionRate,
            NextEpochStake,
            NextEpochGasPrice,
            NextEpochCommissionRate,
            ExtraFields,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "address" => Ok(GeneratedField::Address),
                            "description" => Ok(GeneratedField::Description),
                            "imageUrl" | "image_url" => Ok(GeneratedField::ImageUrl),
                            "projectUrl" | "project_url" => Ok(GeneratedField::ProjectUrl),
                            "protocolPublicKey" | "protocol_public_key" => Ok(GeneratedField::ProtocolPublicKey),
                            "proofOfPossession" | "proof_of_possession" => Ok(GeneratedField::ProofOfPossession),
                            "networkPublicKey" | "network_public_key" => Ok(GeneratedField::NetworkPublicKey),
                            "workerPublicKey" | "worker_public_key" => Ok(GeneratedField::WorkerPublicKey),
                            "networkAddress" | "network_address" => Ok(GeneratedField::NetworkAddress),
                            "p2pAddress" | "p2p_address" => Ok(GeneratedField::P2pAddress),
                            "primaryAddress" | "primary_address" => Ok(GeneratedField::PrimaryAddress),
                            "workerAddress" | "worker_address" => Ok(GeneratedField::WorkerAddress),
                            "nextEpochProtocolPublicKey" | "next_epoch_protocol_public_key" => Ok(GeneratedField::NextEpochProtocolPublicKey),
                            "nextEpochProofOfPossession" | "next_epoch_proof_of_possession" => Ok(GeneratedField::NextEpochProofOfPossession),
                            "nextEpochNetworkPublicKey" | "next_epoch_network_public_key" => Ok(GeneratedField::NextEpochNetworkPublicKey),
                            "nextEpochWorkerPublicKey" | "next_epoch_worker_public_key" => Ok(GeneratedField::NextEpochWorkerPublicKey),
                            "nextEpochNetworkAddress" | "next_epoch_network_address" => Ok(GeneratedField::NextEpochNetworkAddress),
                            "nextEpochP2pAddress" | "next_epoch_p2p_address" => Ok(GeneratedField::NextEpochP2pAddress),
                            "nextEpochPrimaryAddress" | "next_epoch_primary_address" => Ok(GeneratedField::NextEpochPrimaryAddress),
                            "nextEpochWorkerAddress" | "next_epoch_worker_address" => Ok(GeneratedField::NextEpochWorkerAddress),
                            "metadataExtraFields" | "metadata_extra_fields" => Ok(GeneratedField::MetadataExtraFields),
                            "votingPower" | "voting_power" => Ok(GeneratedField::VotingPower),
                            "operationCapId" | "operation_cap_id" => Ok(GeneratedField::OperationCapId),
                            "gasPrice" | "gas_price" => Ok(GeneratedField::GasPrice),
                            "stakingPool" | "staking_pool" => Ok(GeneratedField::StakingPool),
                            "commissionRate" | "commission_rate" => Ok(GeneratedField::CommissionRate),
                            "nextEpochStake" | "next_epoch_stake" => Ok(GeneratedField::NextEpochStake),
                            "nextEpochGasPrice" | "next_epoch_gas_price" => Ok(GeneratedField::NextEpochGasPrice),
                            "nextEpochCommissionRate" | "next_epoch_commission_rate" => Ok(GeneratedField::NextEpochCommissionRate),
                            "extraFields" | "extra_fields" => Ok(GeneratedField::ExtraFields),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = Validator;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.Validator")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<Validator, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut address__ = None;
                let mut description__ = None;
                let mut image_url__ = None;
                let mut project_url__ = None;
                let mut protocol_public_key__ = None;
                let mut proof_of_possession__ = None;
                let mut network_public_key__ = None;
                let mut worker_public_key__ = None;
                let mut network_address__ = None;
                let mut p2p_address__ = None;
                let mut primary_address__ = None;
                let mut worker_address__ = None;
                let mut next_epoch_protocol_public_key__ = None;
                let mut next_epoch_proof_of_possession__ = None;
                let mut next_epoch_network_public_key__ = None;
                let mut next_epoch_worker_public_key__ = None;
                let mut next_epoch_network_address__ = None;
                let mut next_epoch_p2p_address__ = None;
                let mut next_epoch_primary_address__ = None;
                let mut next_epoch_worker_address__ = None;
                let mut metadata_extra_fields__ = None;
                let mut voting_power__ = None;
                let mut operation_cap_id__ = None;
                let mut gas_price__ = None;
                let mut staking_pool__ = None;
                let mut commission_rate__ = None;
                let mut next_epoch_stake__ = None;
                let mut next_epoch_gas_price__ = None;
                let mut next_epoch_commission_rate__ = None;
                let mut extra_fields__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map_.next_value()?;
                        }
                        GeneratedField::Address => {
                            if address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("address"));
                            }
                            address__ = map_.next_value()?;
                        }
                        GeneratedField::Description => {
                            if description__.is_some() {
                                return Err(serde::de::Error::duplicate_field("description"));
                            }
                            description__ = map_.next_value()?;
                        }
                        GeneratedField::ImageUrl => {
                            if image_url__.is_some() {
                                return Err(serde::de::Error::duplicate_field("imageUrl"));
                            }
                            image_url__ = map_.next_value()?;
                        }
                        GeneratedField::ProjectUrl => {
                            if project_url__.is_some() {
                                return Err(serde::de::Error::duplicate_field("projectUrl"));
                            }
                            project_url__ = map_.next_value()?;
                        }
                        GeneratedField::ProtocolPublicKey => {
                            if protocol_public_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("protocolPublicKey"));
                            }
                            protocol_public_key__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ProofOfPossession => {
                            if proof_of_possession__.is_some() {
                                return Err(serde::de::Error::duplicate_field("proofOfPossession"));
                            }
                            proof_of_possession__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NetworkPublicKey => {
                            if network_public_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("networkPublicKey"));
                            }
                            network_public_key__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::WorkerPublicKey => {
                            if worker_public_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("workerPublicKey"));
                            }
                            worker_public_key__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NetworkAddress => {
                            if network_address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("networkAddress"));
                            }
                            network_address__ = map_.next_value()?;
                        }
                        GeneratedField::P2pAddress => {
                            if p2p_address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("p2pAddress"));
                            }
                            p2p_address__ = map_.next_value()?;
                        }
                        GeneratedField::PrimaryAddress => {
                            if primary_address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("primaryAddress"));
                            }
                            primary_address__ = map_.next_value()?;
                        }
                        GeneratedField::WorkerAddress => {
                            if worker_address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("workerAddress"));
                            }
                            worker_address__ = map_.next_value()?;
                        }
                        GeneratedField::NextEpochProtocolPublicKey => {
                            if next_epoch_protocol_public_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nextEpochProtocolPublicKey"));
                            }
                            next_epoch_protocol_public_key__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NextEpochProofOfPossession => {
                            if next_epoch_proof_of_possession__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nextEpochProofOfPossession"));
                            }
                            next_epoch_proof_of_possession__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NextEpochNetworkPublicKey => {
                            if next_epoch_network_public_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nextEpochNetworkPublicKey"));
                            }
                            next_epoch_network_public_key__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NextEpochWorkerPublicKey => {
                            if next_epoch_worker_public_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nextEpochWorkerPublicKey"));
                            }
                            next_epoch_worker_public_key__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NextEpochNetworkAddress => {
                            if next_epoch_network_address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nextEpochNetworkAddress"));
                            }
                            next_epoch_network_address__ = map_.next_value()?;
                        }
                        GeneratedField::NextEpochP2pAddress => {
                            if next_epoch_p2p_address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nextEpochP2pAddress"));
                            }
                            next_epoch_p2p_address__ = map_.next_value()?;
                        }
                        GeneratedField::NextEpochPrimaryAddress => {
                            if next_epoch_primary_address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nextEpochPrimaryAddress"));
                            }
                            next_epoch_primary_address__ = map_.next_value()?;
                        }
                        GeneratedField::NextEpochWorkerAddress => {
                            if next_epoch_worker_address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nextEpochWorkerAddress"));
                            }
                            next_epoch_worker_address__ = map_.next_value()?;
                        }
                        GeneratedField::MetadataExtraFields => {
                            if metadata_extra_fields__.is_some() {
                                return Err(serde::de::Error::duplicate_field("metadataExtraFields"));
                            }
                            metadata_extra_fields__ = map_.next_value()?;
                        }
                        GeneratedField::VotingPower => {
                            if voting_power__.is_some() {
                                return Err(serde::de::Error::duplicate_field("votingPower"));
                            }
                            voting_power__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::OperationCapId => {
                            if operation_cap_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("operationCapId"));
                            }
                            operation_cap_id__ = map_.next_value()?;
                        }
                        GeneratedField::GasPrice => {
                            if gas_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("gasPrice"));
                            }
                            gas_price__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::StakingPool => {
                            if staking_pool__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stakingPool"));
                            }
                            staking_pool__ = map_.next_value()?;
                        }
                        GeneratedField::CommissionRate => {
                            if commission_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("commissionRate"));
                            }
                            commission_rate__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NextEpochStake => {
                            if next_epoch_stake__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nextEpochStake"));
                            }
                            next_epoch_stake__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NextEpochGasPrice => {
                            if next_epoch_gas_price__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nextEpochGasPrice"));
                            }
                            next_epoch_gas_price__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::NextEpochCommissionRate => {
                            if next_epoch_commission_rate__.is_some() {
                                return Err(serde::de::Error::duplicate_field("nextEpochCommissionRate"));
                            }
                            next_epoch_commission_rate__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ExtraFields => {
                            if extra_fields__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extraFields"));
                            }
                            extra_fields__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(Validator {
                    name: name__,
                    address: address__,
                    description: description__,
                    image_url: image_url__,
                    project_url: project_url__,
                    protocol_public_key: protocol_public_key__,
                    proof_of_possession: proof_of_possession__,
                    network_public_key: network_public_key__,
                    worker_public_key: worker_public_key__,
                    network_address: network_address__,
                    p2p_address: p2p_address__,
                    primary_address: primary_address__,
                    worker_address: worker_address__,
                    next_epoch_protocol_public_key: next_epoch_protocol_public_key__,
                    next_epoch_proof_of_possession: next_epoch_proof_of_possession__,
                    next_epoch_network_public_key: next_epoch_network_public_key__,
                    next_epoch_worker_public_key: next_epoch_worker_public_key__,
                    next_epoch_network_address: next_epoch_network_address__,
                    next_epoch_p2p_address: next_epoch_p2p_address__,
                    next_epoch_primary_address: next_epoch_primary_address__,
                    next_epoch_worker_address: next_epoch_worker_address__,
                    metadata_extra_fields: metadata_extra_fields__,
                    voting_power: voting_power__,
                    operation_cap_id: operation_cap_id__,
                    gas_price: gas_price__,
                    staking_pool: staking_pool__,
                    commission_rate: commission_rate__,
                    next_epoch_stake: next_epoch_stake__,
                    next_epoch_gas_price: next_epoch_gas_price__,
                    next_epoch_commission_rate: next_epoch_commission_rate__,
                    extra_fields: extra_fields__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.Validator", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ValidatorAggregatedSignature {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.epoch.is_some() {
            len += 1;
        }
        if self.signature.is_some() {
            len += 1;
        }
        if !self.bitmap.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ValidatorAggregatedSignature", len)?;
        if let Some(v) = self.epoch.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("epoch", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.signature.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("signature", crate::_serde::base64::encode(&v).as_str())?;
        }
        if !self.bitmap.is_empty() {
            struct_ser.serialize_field("bitmap", &self.bitmap)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ValidatorAggregatedSignature {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "epoch",
            "signature",
            "bitmap",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Epoch,
            Signature,
            Bitmap,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "epoch" => Ok(GeneratedField::Epoch),
                            "signature" => Ok(GeneratedField::Signature),
                            "bitmap" => Ok(GeneratedField::Bitmap),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ValidatorAggregatedSignature;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ValidatorAggregatedSignature")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ValidatorAggregatedSignature, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut epoch__ = None;
                let mut signature__ = None;
                let mut bitmap__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Epoch => {
                            if epoch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("epoch"));
                            }
                            epoch__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Signature => {
                            if signature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("signature"));
                            }
                            signature__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Bitmap => {
                            if bitmap__.is_some() {
                                return Err(serde::de::Error::duplicate_field("bitmap"));
                            }
                            bitmap__ = 
                                Some(map_.next_value::<Vec<crate::_serde::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ValidatorAggregatedSignature {
                    epoch: epoch__,
                    signature: signature__,
                    bitmap: bitmap__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ValidatorAggregatedSignature", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ValidatorCommittee {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.epoch.is_some() {
            len += 1;
        }
        if !self.members.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ValidatorCommittee", len)?;
        if let Some(v) = self.epoch.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("epoch", ToString::to_string(&v).as_str())?;
        }
        if !self.members.is_empty() {
            struct_ser.serialize_field("members", &self.members)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ValidatorCommittee {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "epoch",
            "members",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Epoch,
            Members,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "epoch" => Ok(GeneratedField::Epoch),
                            "members" => Ok(GeneratedField::Members),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ValidatorCommittee;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ValidatorCommittee")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ValidatorCommittee, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut epoch__ = None;
                let mut members__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Epoch => {
                            if epoch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("epoch"));
                            }
                            epoch__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Members => {
                            if members__.is_some() {
                                return Err(serde::de::Error::duplicate_field("members"));
                            }
                            members__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ValidatorCommittee {
                    epoch: epoch__,
                    members: members__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ValidatorCommittee", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ValidatorCommitteeMember {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.public_key.is_some() {
            len += 1;
        }
        if self.weight.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ValidatorCommitteeMember", len)?;
        if let Some(v) = self.public_key.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("publicKey", crate::_serde::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.weight.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("weight", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ValidatorCommitteeMember {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "public_key",
            "publicKey",
            "weight",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            PublicKey,
            Weight,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "publicKey" | "public_key" => Ok(GeneratedField::PublicKey),
                            "weight" => Ok(GeneratedField::Weight),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ValidatorCommitteeMember;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ValidatorCommitteeMember")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ValidatorCommitteeMember, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut public_key__ = None;
                let mut weight__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::PublicKey => {
                            if public_key__.is_some() {
                                return Err(serde::de::Error::duplicate_field("publicKey"));
                            }
                            public_key__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Weight => {
                            if weight__.is_some() {
                                return Err(serde::de::Error::duplicate_field("weight"));
                            }
                            weight__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ValidatorCommitteeMember {
                    public_key: public_key__,
                    weight: weight__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ValidatorCommitteeMember", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ValidatorExecutionTimeObservation {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.validator.is_some() {
            len += 1;
        }
        if self.duration.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ValidatorExecutionTimeObservation", len)?;
        if let Some(v) = self.validator.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("validator", crate::_serde::base64::encode(&v).as_str())?;
        }
        if let Some(v) = self.duration.as_ref() {
            struct_ser.serialize_field("duration", &crate::_serde::DurationSerializer(v))?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ValidatorExecutionTimeObservation {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "validator",
            "duration",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Validator,
            Duration,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "validator" => Ok(GeneratedField::Validator),
                            "duration" => Ok(GeneratedField::Duration),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ValidatorExecutionTimeObservation;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ValidatorExecutionTimeObservation")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ValidatorExecutionTimeObservation, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut validator__ = None;
                let mut duration__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Validator => {
                            if validator__.is_some() {
                                return Err(serde::de::Error::duplicate_field("validator"));
                            }
                            validator__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::BytesDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Duration => {
                            if duration__.is_some() {
                                return Err(serde::de::Error::duplicate_field("duration"));
                            }
                            duration__ = map_.next_value::<::std::option::Option<crate::_serde::DurationDeserializer>>()?.map(|x| x.0.into());
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ValidatorExecutionTimeObservation {
                    validator: validator__,
                    duration: duration__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ValidatorExecutionTimeObservation", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ValidatorReportRecord {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.reported.is_some() {
            len += 1;
        }
        if !self.reporters.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ValidatorReportRecord", len)?;
        if let Some(v) = self.reported.as_ref() {
            struct_ser.serialize_field("reported", v)?;
        }
        if !self.reporters.is_empty() {
            struct_ser.serialize_field("reporters", &self.reporters)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ValidatorReportRecord {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "reported",
            "reporters",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Reported,
            Reporters,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "reported" => Ok(GeneratedField::Reported),
                            "reporters" => Ok(GeneratedField::Reporters),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ValidatorReportRecord;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ValidatorReportRecord")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ValidatorReportRecord, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut reported__ = None;
                let mut reporters__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Reported => {
                            if reported__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reported"));
                            }
                            reported__ = map_.next_value()?;
                        }
                        GeneratedField::Reporters => {
                            if reporters__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reporters"));
                            }
                            reporters__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ValidatorReportRecord {
                    reported: reported__,
                    reporters: reporters__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ValidatorReportRecord", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ValidatorSet {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.total_stake.is_some() {
            len += 1;
        }
        if !self.active_validators.is_empty() {
            len += 1;
        }
        if self.pending_active_validators.is_some() {
            len += 1;
        }
        if !self.pending_removals.is_empty() {
            len += 1;
        }
        if self.staking_pool_mappings.is_some() {
            len += 1;
        }
        if self.inactive_validators.is_some() {
            len += 1;
        }
        if self.validator_candidates.is_some() {
            len += 1;
        }
        if !self.at_risk_validators.is_empty() {
            len += 1;
        }
        if self.extra_fields.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ValidatorSet", len)?;
        if let Some(v) = self.total_stake.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("totalStake", ToString::to_string(&v).as_str())?;
        }
        if !self.active_validators.is_empty() {
            struct_ser.serialize_field("activeValidators", &self.active_validators)?;
        }
        if let Some(v) = self.pending_active_validators.as_ref() {
            struct_ser.serialize_field("pendingActiveValidators", v)?;
        }
        if !self.pending_removals.is_empty() {
            struct_ser.serialize_field("pendingRemovals", &self.pending_removals.iter().map(ToString::to_string).collect::<Vec<_>>())?;
        }
        if let Some(v) = self.staking_pool_mappings.as_ref() {
            struct_ser.serialize_field("stakingPoolMappings", v)?;
        }
        if let Some(v) = self.inactive_validators.as_ref() {
            struct_ser.serialize_field("inactiveValidators", v)?;
        }
        if let Some(v) = self.validator_candidates.as_ref() {
            struct_ser.serialize_field("validatorCandidates", v)?;
        }
        if !self.at_risk_validators.is_empty() {
            let v: std::collections::BTreeMap<_, _> = self.at_risk_validators.iter()
                .map(|(k, v)| (k, v.to_string())).collect();
            struct_ser.serialize_field("atRiskValidators", &v)?;
        }
        if let Some(v) = self.extra_fields.as_ref() {
            struct_ser.serialize_field("extraFields", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ValidatorSet {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "total_stake",
            "totalStake",
            "active_validators",
            "activeValidators",
            "pending_active_validators",
            "pendingActiveValidators",
            "pending_removals",
            "pendingRemovals",
            "staking_pool_mappings",
            "stakingPoolMappings",
            "inactive_validators",
            "inactiveValidators",
            "validator_candidates",
            "validatorCandidates",
            "at_risk_validators",
            "atRiskValidators",
            "extra_fields",
            "extraFields",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            TotalStake,
            ActiveValidators,
            PendingActiveValidators,
            PendingRemovals,
            StakingPoolMappings,
            InactiveValidators,
            ValidatorCandidates,
            AtRiskValidators,
            ExtraFields,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "totalStake" | "total_stake" => Ok(GeneratedField::TotalStake),
                            "activeValidators" | "active_validators" => Ok(GeneratedField::ActiveValidators),
                            "pendingActiveValidators" | "pending_active_validators" => Ok(GeneratedField::PendingActiveValidators),
                            "pendingRemovals" | "pending_removals" => Ok(GeneratedField::PendingRemovals),
                            "stakingPoolMappings" | "staking_pool_mappings" => Ok(GeneratedField::StakingPoolMappings),
                            "inactiveValidators" | "inactive_validators" => Ok(GeneratedField::InactiveValidators),
                            "validatorCandidates" | "validator_candidates" => Ok(GeneratedField::ValidatorCandidates),
                            "atRiskValidators" | "at_risk_validators" => Ok(GeneratedField::AtRiskValidators),
                            "extraFields" | "extra_fields" => Ok(GeneratedField::ExtraFields),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ValidatorSet;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ValidatorSet")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ValidatorSet, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut total_stake__ = None;
                let mut active_validators__ = None;
                let mut pending_active_validators__ = None;
                let mut pending_removals__ = None;
                let mut staking_pool_mappings__ = None;
                let mut inactive_validators__ = None;
                let mut validator_candidates__ = None;
                let mut at_risk_validators__ = None;
                let mut extra_fields__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::TotalStake => {
                            if total_stake__.is_some() {
                                return Err(serde::de::Error::duplicate_field("totalStake"));
                            }
                            total_stake__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::ActiveValidators => {
                            if active_validators__.is_some() {
                                return Err(serde::de::Error::duplicate_field("activeValidators"));
                            }
                            active_validators__ = Some(map_.next_value()?);
                        }
                        GeneratedField::PendingActiveValidators => {
                            if pending_active_validators__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pendingActiveValidators"));
                            }
                            pending_active_validators__ = map_.next_value()?;
                        }
                        GeneratedField::PendingRemovals => {
                            if pending_removals__.is_some() {
                                return Err(serde::de::Error::duplicate_field("pendingRemovals"));
                            }
                            pending_removals__ = 
                                Some(map_.next_value::<Vec<crate::_serde::NumberDeserialize<_>>>()?
                                    .into_iter().map(|x| x.0).collect())
                            ;
                        }
                        GeneratedField::StakingPoolMappings => {
                            if staking_pool_mappings__.is_some() {
                                return Err(serde::de::Error::duplicate_field("stakingPoolMappings"));
                            }
                            staking_pool_mappings__ = map_.next_value()?;
                        }
                        GeneratedField::InactiveValidators => {
                            if inactive_validators__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inactiveValidators"));
                            }
                            inactive_validators__ = map_.next_value()?;
                        }
                        GeneratedField::ValidatorCandidates => {
                            if validator_candidates__.is_some() {
                                return Err(serde::de::Error::duplicate_field("validatorCandidates"));
                            }
                            validator_candidates__ = map_.next_value()?;
                        }
                        GeneratedField::AtRiskValidators => {
                            if at_risk_validators__.is_some() {
                                return Err(serde::de::Error::duplicate_field("atRiskValidators"));
                            }
                            at_risk_validators__ = Some(
                                map_.next_value::<std::collections::BTreeMap<_, crate::_serde::NumberDeserialize<u64>>>()?
                                    .into_iter().map(|(k,v)| (k, v.0)).collect()
                            );
                        }
                        GeneratedField::ExtraFields => {
                            if extra_fields__.is_some() {
                                return Err(serde::de::Error::duplicate_field("extraFields"));
                            }
                            extra_fields__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ValidatorSet {
                    total_stake: total_stake__,
                    active_validators: active_validators__.unwrap_or_default(),
                    pending_active_validators: pending_active_validators__,
                    pending_removals: pending_removals__.unwrap_or_default(),
                    staking_pool_mappings: staking_pool_mappings__,
                    inactive_validators: inactive_validators__,
                    validator_candidates: validator_candidates__,
                    at_risk_validators: at_risk_validators__.unwrap_or_default(),
                    extra_fields: extra_fields__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ValidatorSet", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for VariantDescriptor {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.name.is_some() {
            len += 1;
        }
        if self.position.is_some() {
            len += 1;
        }
        if !self.fields.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.VariantDescriptor", len)?;
        if let Some(v) = self.name.as_ref() {
            struct_ser.serialize_field("name", v)?;
        }
        if let Some(v) = self.position.as_ref() {
            struct_ser.serialize_field("position", v)?;
        }
        if !self.fields.is_empty() {
            struct_ser.serialize_field("fields", &self.fields)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for VariantDescriptor {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "name",
            "position",
            "fields",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Name,
            Position,
            Fields,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "name" => Ok(GeneratedField::Name),
                            "position" => Ok(GeneratedField::Position),
                            "fields" => Ok(GeneratedField::Fields),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VariantDescriptor;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.VariantDescriptor")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<VariantDescriptor, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut name__ = None;
                let mut position__ = None;
                let mut fields__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Name => {
                            if name__.is_some() {
                                return Err(serde::de::Error::duplicate_field("name"));
                            }
                            name__ = map_.next_value()?;
                        }
                        GeneratedField::Position => {
                            if position__.is_some() {
                                return Err(serde::de::Error::duplicate_field("position"));
                            }
                            position__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Fields => {
                            if fields__.is_some() {
                                return Err(serde::de::Error::duplicate_field("fields"));
                            }
                            fields__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(VariantDescriptor {
                    name: name__,
                    position: position__,
                    fields: fields__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.VariantDescriptor", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for VerifySignatureRequest {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.message.is_some() {
            len += 1;
        }
        if self.signature.is_some() {
            len += 1;
        }
        if self.address.is_some() {
            len += 1;
        }
        if !self.jwks.is_empty() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.VerifySignatureRequest", len)?;
        if let Some(v) = self.message.as_ref() {
            struct_ser.serialize_field("message", v)?;
        }
        if let Some(v) = self.signature.as_ref() {
            struct_ser.serialize_field("signature", v)?;
        }
        if let Some(v) = self.address.as_ref() {
            struct_ser.serialize_field("address", v)?;
        }
        if !self.jwks.is_empty() {
            struct_ser.serialize_field("jwks", &self.jwks)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for VerifySignatureRequest {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "message",
            "signature",
            "address",
            "jwks",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Message,
            Signature,
            Address,
            Jwks,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "message" => Ok(GeneratedField::Message),
                            "signature" => Ok(GeneratedField::Signature),
                            "address" => Ok(GeneratedField::Address),
                            "jwks" => Ok(GeneratedField::Jwks),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VerifySignatureRequest;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.VerifySignatureRequest")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<VerifySignatureRequest, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut message__ = None;
                let mut signature__ = None;
                let mut address__ = None;
                let mut jwks__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Message => {
                            if message__.is_some() {
                                return Err(serde::de::Error::duplicate_field("message"));
                            }
                            message__ = map_.next_value()?;
                        }
                        GeneratedField::Signature => {
                            if signature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("signature"));
                            }
                            signature__ = map_.next_value()?;
                        }
                        GeneratedField::Address => {
                            if address__.is_some() {
                                return Err(serde::de::Error::duplicate_field("address"));
                            }
                            address__ = map_.next_value()?;
                        }
                        GeneratedField::Jwks => {
                            if jwks__.is_some() {
                                return Err(serde::de::Error::duplicate_field("jwks"));
                            }
                            jwks__ = Some(map_.next_value()?);
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(VerifySignatureRequest {
                    message: message__,
                    signature: signature__,
                    address: address__,
                    jwks: jwks__.unwrap_or_default(),
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.VerifySignatureRequest", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for VerifySignatureResponse {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.is_valid.is_some() {
            len += 1;
        }
        if self.reason.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.VerifySignatureResponse", len)?;
        if let Some(v) = self.is_valid.as_ref() {
            struct_ser.serialize_field("isValid", v)?;
        }
        if let Some(v) = self.reason.as_ref() {
            struct_ser.serialize_field("reason", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for VerifySignatureResponse {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "is_valid",
            "isValid",
            "reason",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            IsValid,
            Reason,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "isValid" | "is_valid" => Ok(GeneratedField::IsValid),
                            "reason" => Ok(GeneratedField::Reason),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VerifySignatureResponse;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.VerifySignatureResponse")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<VerifySignatureResponse, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut is_valid__ = None;
                let mut reason__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::IsValid => {
                            if is_valid__.is_some() {
                                return Err(serde::de::Error::duplicate_field("isValid"));
                            }
                            is_valid__ = map_.next_value()?;
                        }
                        GeneratedField::Reason => {
                            if reason__.is_some() {
                                return Err(serde::de::Error::duplicate_field("reason"));
                            }
                            reason__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(VerifySignatureResponse {
                    is_valid: is_valid__,
                    reason: reason__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.VerifySignatureResponse", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for VersionAssignment {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.object_id.is_some() {
            len += 1;
        }
        if self.start_version.is_some() {
            len += 1;
        }
        if self.version.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.VersionAssignment", len)?;
        if let Some(v) = self.object_id.as_ref() {
            struct_ser.serialize_field("objectId", v)?;
        }
        if let Some(v) = self.start_version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("startVersion", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.version.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("version", ToString::to_string(&v).as_str())?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for VersionAssignment {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "object_id",
            "objectId",
            "start_version",
            "startVersion",
            "version",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ObjectId,
            StartVersion,
            Version,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "objectId" | "object_id" => Ok(GeneratedField::ObjectId),
                            "startVersion" | "start_version" => Ok(GeneratedField::StartVersion),
                            "version" => Ok(GeneratedField::Version),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = VersionAssignment;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.VersionAssignment")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<VersionAssignment, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut object_id__ = None;
                let mut start_version__ = None;
                let mut version__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ObjectId => {
                            if object_id__.is_some() {
                                return Err(serde::de::Error::duplicate_field("objectId"));
                            }
                            object_id__ = map_.next_value()?;
                        }
                        GeneratedField::StartVersion => {
                            if start_version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("startVersion"));
                            }
                            start_version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Version => {
                            if version__.is_some() {
                                return Err(serde::de::Error::duplicate_field("version"));
                            }
                            version__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(VersionAssignment {
                    object_id: object_id__,
                    start_version: start_version__,
                    version: version__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.VersionAssignment", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ZkLoginAuthenticator {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.inputs.is_some() {
            len += 1;
        }
        if self.max_epoch.is_some() {
            len += 1;
        }
        if self.signature.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ZkLoginAuthenticator", len)?;
        if let Some(v) = self.inputs.as_ref() {
            struct_ser.serialize_field("inputs", v)?;
        }
        if let Some(v) = self.max_epoch.as_ref() {
            #[allow(clippy::needless_borrow)]
            #[allow(clippy::needless_borrows_for_generic_args)]
            struct_ser.serialize_field("maxEpoch", ToString::to_string(&v).as_str())?;
        }
        if let Some(v) = self.signature.as_ref() {
            struct_ser.serialize_field("signature", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ZkLoginAuthenticator {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "inputs",
            "max_epoch",
            "maxEpoch",
            "signature",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Inputs,
            MaxEpoch,
            Signature,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "inputs" => Ok(GeneratedField::Inputs),
                            "maxEpoch" | "max_epoch" => Ok(GeneratedField::MaxEpoch),
                            "signature" => Ok(GeneratedField::Signature),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ZkLoginAuthenticator;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ZkLoginAuthenticator")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ZkLoginAuthenticator, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut inputs__ = None;
                let mut max_epoch__ = None;
                let mut signature__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Inputs => {
                            if inputs__.is_some() {
                                return Err(serde::de::Error::duplicate_field("inputs"));
                            }
                            inputs__ = map_.next_value()?;
                        }
                        GeneratedField::MaxEpoch => {
                            if max_epoch__.is_some() {
                                return Err(serde::de::Error::duplicate_field("maxEpoch"));
                            }
                            max_epoch__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::Signature => {
                            if signature__.is_some() {
                                return Err(serde::de::Error::duplicate_field("signature"));
                            }
                            signature__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ZkLoginAuthenticator {
                    inputs: inputs__,
                    max_epoch: max_epoch__,
                    signature: signature__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ZkLoginAuthenticator", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ZkLoginClaim {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.value.is_some() {
            len += 1;
        }
        if self.index_mod_4.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ZkLoginClaim", len)?;
        if let Some(v) = self.value.as_ref() {
            struct_ser.serialize_field("value", v)?;
        }
        if let Some(v) = self.index_mod_4.as_ref() {
            struct_ser.serialize_field("indexMod4", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ZkLoginClaim {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "value",
            "index_mod_4",
            "indexMod4",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Value,
            IndexMod4,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "value" => Ok(GeneratedField::Value),
                            "indexMod4" | "index_mod_4" => Ok(GeneratedField::IndexMod4),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ZkLoginClaim;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ZkLoginClaim")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ZkLoginClaim, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut value__ = None;
                let mut index_mod_4__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Value => {
                            if value__.is_some() {
                                return Err(serde::de::Error::duplicate_field("value"));
                            }
                            value__ = map_.next_value()?;
                        }
                        GeneratedField::IndexMod4 => {
                            if index_mod_4__.is_some() {
                                return Err(serde::de::Error::duplicate_field("indexMod4"));
                            }
                            index_mod_4__ = 
                                map_.next_value::<::std::option::Option<crate::_serde::NumberDeserialize<_>>>()?.map(|x| x.0)
                            ;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ZkLoginClaim {
                    value: value__,
                    index_mod_4: index_mod_4__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ZkLoginClaim", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ZkLoginInputs {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.proof_points.is_some() {
            len += 1;
        }
        if self.iss_base64_details.is_some() {
            len += 1;
        }
        if self.header_base64.is_some() {
            len += 1;
        }
        if self.address_seed.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ZkLoginInputs", len)?;
        if let Some(v) = self.proof_points.as_ref() {
            struct_ser.serialize_field("proofPoints", v)?;
        }
        if let Some(v) = self.iss_base64_details.as_ref() {
            struct_ser.serialize_field("issBase64Details", v)?;
        }
        if let Some(v) = self.header_base64.as_ref() {
            struct_ser.serialize_field("headerBase64", v)?;
        }
        if let Some(v) = self.address_seed.as_ref() {
            struct_ser.serialize_field("addressSeed", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ZkLoginInputs {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "proof_points",
            "proofPoints",
            "iss_base64_details",
            "issBase64Details",
            "header_base64",
            "headerBase64",
            "address_seed",
            "addressSeed",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            ProofPoints,
            IssBase64Details,
            HeaderBase64,
            AddressSeed,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "proofPoints" | "proof_points" => Ok(GeneratedField::ProofPoints),
                            "issBase64Details" | "iss_base64_details" => Ok(GeneratedField::IssBase64Details),
                            "headerBase64" | "header_base64" => Ok(GeneratedField::HeaderBase64),
                            "addressSeed" | "address_seed" => Ok(GeneratedField::AddressSeed),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ZkLoginInputs;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ZkLoginInputs")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ZkLoginInputs, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut proof_points__ = None;
                let mut iss_base64_details__ = None;
                let mut header_base64__ = None;
                let mut address_seed__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::ProofPoints => {
                            if proof_points__.is_some() {
                                return Err(serde::de::Error::duplicate_field("proofPoints"));
                            }
                            proof_points__ = map_.next_value()?;
                        }
                        GeneratedField::IssBase64Details => {
                            if iss_base64_details__.is_some() {
                                return Err(serde::de::Error::duplicate_field("issBase64Details"));
                            }
                            iss_base64_details__ = map_.next_value()?;
                        }
                        GeneratedField::HeaderBase64 => {
                            if header_base64__.is_some() {
                                return Err(serde::de::Error::duplicate_field("headerBase64"));
                            }
                            header_base64__ = map_.next_value()?;
                        }
                        GeneratedField::AddressSeed => {
                            if address_seed__.is_some() {
                                return Err(serde::de::Error::duplicate_field("addressSeed"));
                            }
                            address_seed__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ZkLoginInputs {
                    proof_points: proof_points__,
                    iss_base64_details: iss_base64_details__,
                    header_base64: header_base64__,
                    address_seed: address_seed__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ZkLoginInputs", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ZkLoginProof {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.a.is_some() {
            len += 1;
        }
        if self.b.is_some() {
            len += 1;
        }
        if self.c.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ZkLoginProof", len)?;
        if let Some(v) = self.a.as_ref() {
            struct_ser.serialize_field("a", v)?;
        }
        if let Some(v) = self.b.as_ref() {
            struct_ser.serialize_field("b", v)?;
        }
        if let Some(v) = self.c.as_ref() {
            struct_ser.serialize_field("c", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ZkLoginProof {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "a",
            "b",
            "c",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            A,
            B,
            C,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "a" => Ok(GeneratedField::A),
                            "b" => Ok(GeneratedField::B),
                            "c" => Ok(GeneratedField::C),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ZkLoginProof;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ZkLoginProof")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ZkLoginProof, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut a__ = None;
                let mut b__ = None;
                let mut c__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::A => {
                            if a__.is_some() {
                                return Err(serde::de::Error::duplicate_field("a"));
                            }
                            a__ = map_.next_value()?;
                        }
                        GeneratedField::B => {
                            if b__.is_some() {
                                return Err(serde::de::Error::duplicate_field("b"));
                            }
                            b__ = map_.next_value()?;
                        }
                        GeneratedField::C => {
                            if c__.is_some() {
                                return Err(serde::de::Error::duplicate_field("c"));
                            }
                            c__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ZkLoginProof {
                    a: a__,
                    b: b__,
                    c: c__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ZkLoginProof", FIELDS, GeneratedVisitor)
    }
}
impl serde::Serialize for ZkLoginPublicIdentifier {
    #[allow(deprecated)]
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut len = 0;
        if self.iss.is_some() {
            len += 1;
        }
        if self.address_seed.is_some() {
            len += 1;
        }
        let mut struct_ser = serializer.serialize_struct("sui.rpc.v2beta2.ZkLoginPublicIdentifier", len)?;
        if let Some(v) = self.iss.as_ref() {
            struct_ser.serialize_field("iss", v)?;
        }
        if let Some(v) = self.address_seed.as_ref() {
            struct_ser.serialize_field("addressSeed", v)?;
        }
        struct_ser.end()
    }
}
impl<'de> serde::Deserialize<'de> for ZkLoginPublicIdentifier {
    #[allow(deprecated)]
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        const FIELDS: &[&str] = &[
            "iss",
            "address_seed",
            "addressSeed",
        ];

        #[allow(clippy::enum_variant_names)]
        enum GeneratedField {
            Iss,
            AddressSeed,
            __SkipField__,
        }
        impl<'de> serde::Deserialize<'de> for GeneratedField {
            fn deserialize<D>(deserializer: D) -> std::result::Result<GeneratedField, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct GeneratedVisitor;

                impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
                    type Value = GeneratedField;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, "expected one of: {:?}", &FIELDS)
                    }

                    #[allow(unused_variables)]
                    fn visit_str<E>(self, value: &str) -> std::result::Result<GeneratedField, E>
                    where
                        E: serde::de::Error,
                    {
                        match value {
                            "iss" => Ok(GeneratedField::Iss),
                            "addressSeed" | "address_seed" => Ok(GeneratedField::AddressSeed),
                            _ => Ok(GeneratedField::__SkipField__),
                        }
                    }
                }
                deserializer.deserialize_identifier(GeneratedVisitor)
            }
        }
        struct GeneratedVisitor;
        #[allow(clippy::useless_conversion)]
        #[allow(clippy::unit_arg)]
        impl<'de> serde::de::Visitor<'de> for GeneratedVisitor {
            type Value = ZkLoginPublicIdentifier;

            fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                formatter.write_str("struct sui.rpc.v2beta2.ZkLoginPublicIdentifier")
            }

            fn visit_map<V>(self, mut map_: V) -> std::result::Result<ZkLoginPublicIdentifier, V::Error>
                where
                    V: serde::de::MapAccess<'de>,
            {
                let mut iss__ = None;
                let mut address_seed__ = None;
                while let Some(k) = map_.next_key()? {
                    match k {
                        GeneratedField::Iss => {
                            if iss__.is_some() {
                                return Err(serde::de::Error::duplicate_field("iss"));
                            }
                            iss__ = map_.next_value()?;
                        }
                        GeneratedField::AddressSeed => {
                            if address_seed__.is_some() {
                                return Err(serde::de::Error::duplicate_field("addressSeed"));
                            }
                            address_seed__ = map_.next_value()?;
                        }
                        GeneratedField::__SkipField__ => {
                            let _ = map_.next_value::<serde::de::IgnoredAny>()?;
                        }
                    }
                }
                Ok(ZkLoginPublicIdentifier {
                    iss: iss__,
                    address_seed: address_seed__,
                })
            }
        }
        deserializer.deserialize_struct("sui.rpc.v2beta2.ZkLoginPublicIdentifier", FIELDS, GeneratedVisitor)
    }
}
